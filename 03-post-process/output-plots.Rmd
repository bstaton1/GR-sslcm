---
title: "Output Summary"
subtitle: "`r c('CAT' = 'Catherine Creek', 'LOS' = 'Lostine', 'UGR' = 'Upper Grande Ronde')[params$pop]`"
output: html_document
params:
  pop:
    label: "Population"
    value: CAT
    input: select
    choices: [CAT, LOS, UGR]
  mcmc_plots:
    label: "Make MCMC Plots"
    input: checkbox
    value: FALSE
editor_options: 
  chunk_output_type: console
---

```{r directories, include = F}
# set root directory to the project directory: one level up from this location
knitr::opts_knit$set(root.dir = "../")
```

```{r setup, include = FALSE}
# set global knitting options
knitr::opts_chunk$set(echo = FALSE, fig.align = "center")

# load packages
source("00-packages.R")

# load all necessary functions
invisible(sapply(list.files(path = "01-functions", pattern = "\\.R$", full.names = T), source))

# set the input directory
in_dir = "02-model/model-output"

# read information from this model
model_info = readRDS(file.path(in_dir, paste0(params$pop, "-output.rds")))

# extract the two key structures from this object
post = model_info$post
jags_data = model_info$jags_data

# which years are "observable"?
observable = (jags_data$kmax+1):jags_data$ny
```

The code used to render this output relies heavily on Staton's 'postpack' package (now available on CRAN). Take a look at [this vignette](https://bstaton1.github.io/postpack/articles/feature-overview.html) for a primer on how to use it.

# MCMC Information {.tabset .tabset-pills}

## Attributes

This table shows some dimensions of the MCMC run.

```{r mcmc-dims}
# query the dimensions of the posterior samples
dims = post_dim(post)

# build a data frame for printing
df = data.frame(Quantity = c("Burn-in + Adapt Iters", "Post Burn-in Iters", "Thinning Interval", "Chains", "Saved Iters", "Monitored Quantities"), Value = unname(dims))

# render the table
kable(df, format.args = list(big.mark = ",")) %>%
  kable_styling(full_width = F, bootstrap_options = "condensed")
```

## Diagnostic Summaries

This table shows the number of parameters that fail to meet some diagnostic threshold. Lower Rhat values are good, larger Neff values are good, and lower MCMC SE/Mean values are good.

The "match" column shows the kinds of parameters summarized in that row. E.g., `^mu_phi` covers all parameter names that start with `mu_phi` and are followed by anything else (`r paste(match_params(post, "^mu_phi"), collapse = ", ")`).

This model was ran for a very short time, and I'm impressed with how well the sampling performed even considering this.

```{r mcmc-diags}
# groups of parameters to match and calculate diagnostic summaries for separately
diag_params = list(
  c("alpha", "beta", "sigma_Pb"),
  "gamma",
  "^mu_phi",
  "^mu_psi",
  "^mu_omega",
  "^mu_pi",
  "^sig_Lphi",
  "^sig_Lpsi",
  c("^sig_Lomega", "^sig_Lpi"),
  "^Pb[", 
  "init_recruits", 
  "^phi_Ma_M", "^phi_Mb_Ma[.+,2]", "^phi_Pa_Mb[.+,1]", "^phi_Pa_Mb[.+,2]",
  "^phi_Mb_M["
)

# calculate the diagnostic statistics for each group
diags = lapply(diag_params, function(param) post_summ(post, param, Rhat = T, neff = T, mcse = T)[c("mean", "Rhat", "neff", "mcse_mean"),])

# count up the number of parameters by group that fail to meet certain thresholds
diag_summ = t(sapply(diags, function(param) {
  mc_cv = (param["mcse_mean",]/param["mean",]) * 100
  c(
    n_total = ncol(param),
    n_Rhat_1 = sum(param["Rhat",] > 1.05),
    n_Rhat_2 = sum(param["Rhat",] > 1.1),
    n_Rhat_3 = sum(param["Rhat",] > 1.2),
    n_neff_1 = sum(param["neff",] < 2000),
    n_neff_2 = sum(param["neff",] < 1000),
    n_neff_3 = sum(param["neff",] < 500),
    mc_cv_1 = sum(mc_cv > 1),
    mc_cv_2 = sum(mc_cv > 5),
    mc_cv_3 = sum(mc_cv > 10)
  )
}))

# format to a table
diag_summ = as.data.frame(diag_summ)
colnames(diag_summ) = c("Total Params", ">1.05", ">1.1", ">1.2", "<3000", "<1000", "<500", ">1%", ">5%", ">10%")
df = cbind("Match" = unlist(lapply(diag_params, paste, collapse = ", ")), diag_summ)

# render the table
kable(df, align = "lcccccccccc") %>%
  kable_styling(full_width = F, bootstrap_options = c("condensed", "striped")) %>%
  add_header_above(c(" " = 2, "Rhat" = 3, "Neff" = 3, "MCMC SE/Mean * 100%" = 3)) %>%
  column_spec(1, monospace = T) %>%
  column_spec(c(2,5,8), border_right = T)

```

`r if (params$mcmc_plots) "## Diagnostic Plots {.tabset .tabset-pills}"`

`r if (params$mcmc_plots) "### $\\alpha$, $\\beta$"`

```{r alpha-beta-diag-plots, eval = params$mcmc_plots, fig.width = 4, fig.height = 5}
diag_plots(post, c("alpha", "beta"), layout = "2x1")
```

`r if (params$mcmc_plots) "### $\\gamma$"`

```{r gamma-diag-plots, eval = params$mcmc_plots, fig.width = 3, fig.height = 6}
diag_plots(post, "gamma", layout = "4x1")
```

`r if (params$mcmc_plots) "### $\\mu$"`

```{r mu-diag-plots, eval = params$mcmc_plots, fig.width = 7, fig.height = 7}
diag_plots(post, "^mu", layout = "5x3")
```

`r if (params$mcmc_plots) "### $$\\sigma$"`

```{r sig-diag-plots, eval = params$mcmc_plots, fig.width = 7, fig.height = 7}
diag_plots(post, "^sig", layout = "5x3")
```

`r if (params$mcmc_plots) "### init_recruits"`

```{r init-recruits-diag-plots, eval = params$mcmc_plots, fig.width = 5, fig.height = 7}
diag_plots(post, "init_recruits", layout = "4x2")
```

# Fit to Data {.tabset .tabset-pills}

In the figures below, the thick red line is the posterior median value each year, the red region is the equal-tailed 95% credible interval, and blue points are "observed" data (estimated from raw data external to the model).

## Abundance Data

```{r abundance-data-fits, fig.width = 3, fig.height = 5}
par(mfcol = c(3,1), oma = c(1.5,1.5,0,0))
plot_tseries(post_summ(post, "^Pa[.+,1]$"), jags_data$Pa_obs[observable,1], main = "Fall Trap Abundance")
plot_tseries(post_summ(post, "^Mb[.+,2,1]$"), jags_data$Mb_obs[observable,2,1], main = "Spring Trap Abundance")
plot_tseries(post_summ(post, "^Ra_tot["), jags_data$Ra_obs[observable], main = "Weir Abundance")
mtext(side = 1, outer = T, line = 0.25, "Brood Year")
mtext(side = 2, outer = T, line = 0.25, "Abundance")
```

## Survival Data

```{r survival-data-fits, fig.width = 3, fig.height = 5}
par(mfcol = c(3,1), oma = c(1.5,1.5,0,0))

plot_tseries(post_summ(post, "^phi_Pb_Ma["), expit(jags_data$Lphi_obs_Pb_Ma[observable]), main = "Summer Tagging to LGD")
plot_tseries(post_summ(post, "^phi_Pa_Ma[.+,1]$"), expit(jags_data$Lphi_obs_Pa_Ma[observable,1]), main = "Fall Trap to LGD")
plot_tseries(post_summ(post, "^phi_Mb_Ma[.+,2]$"), expit(jags_data$Lphi_obs_Mb_Ma[observable,2]), main = "Spring Trap to LGD")
mtext(side = 1, outer = T, line = 0.25, "Brood Year")
mtext(side = 2, outer = T, line = 0.25, "Survival")
```

## Composition Data {.tabset .tabset-pills .tabset-fade}

Within a single year, the values across all panels sum to one.

### Weir Sampling

```{r weir-comp-data-fits, fig.width = 8, fig.height = 5}
# calculate observed q
q_obs = t(apply(jags_data$weir_x_obs, 1, function(y) y/sum(y)))

par(mfcol = c(3,4), oma = c(1.5,1.5,0,0))
plot_tseries(post_summ(post, "^q_Ra[.+,1]$"), q_obs[observable,1], main = "Nat. Female Age 3")
plot_tseries(post_summ(post, "^q_Ra[.+,2]$"), q_obs[observable,2], main = "Nat. Female Age 4")
plot_tseries(post_summ(post, "^q_Ra[.+,3]$"), q_obs[observable,3], main = "Nat. Female Age 5")
plot_tseries(post_summ(post, "^q_Ra[.+,4]$"), q_obs[observable,4], main = "Nat. Male Age 3")
plot_tseries(post_summ(post, "^q_Ra[.+,5]$"), q_obs[observable,5], main = "Nat. Male Age 4")
plot_tseries(post_summ(post, "^q_Ra[.+,6]$"), q_obs[observable,6], main = "Nat. Male Age 5")
plot_tseries(post_summ(post, "^q_Ra[.+,7]$"), q_obs[observable,7], main = "Hat. Female Age 3")
plot_tseries(post_summ(post, "^q_Ra[.+,8]$"), q_obs[observable,8], main = "Hat. Female Age 4")
plot_tseries(post_summ(post, "^q_Ra[.+,9]$"), q_obs[observable,9], main = "Hat. Female Age 5")
plot_tseries(post_summ(post, "^q_Ra[.+,10]$"), q_obs[observable,10], main = "Hat. Male Age 3")
plot_tseries(post_summ(post, "^q_Ra[.+,11]$"), q_obs[observable,11], main = "Hat. Male Age 4")
plot_tseries(post_summ(post, "^q_Ra[.+,12]$"), q_obs[observable,12], main = "Hat. Male Age 5")
mtext(side = 1, outer = T, line = 0.25, "Brood Year")
mtext(side = 2, outer = T, line = 0.25, "Proportion of Return")
```

### Carcass Sampling

```{r carc-comp-data-fits, fig.width = 8, fig.height = 5}
# calculate observed q
q_obs = t(apply(jags_data$carc_x_obs, 1, function(y) y/sum(y)))

par(mfcol = c(3,4), oma = c(1.5,1.5,0,0))
plot_tseries(post_summ(post, "^q_Sa_adj[.+,1]$"), q_obs[observable,1], main = "Nat. Female Age 3")
plot_tseries(post_summ(post, "^q_Sa_adj[.+,2]$"), q_obs[observable,2], main = "Nat. Female Age 4")
plot_tseries(post_summ(post, "^q_Sa_adj[.+,3]$"), q_obs[observable,3], main = "Nat. Female Age 5")
plot_tseries(post_summ(post, "^q_Sa_adj[.+,4]$"), q_obs[observable,4], main = "Nat. Male Age 3")
plot_tseries(post_summ(post, "^q_Sa_adj[.+,5]$"), q_obs[observable,5], main = "Nat. Male Age 4")
plot_tseries(post_summ(post, "^q_Sa_adj[.+,6]$"), q_obs[observable,6], main = "Nat. Male Age 5")
plot_tseries(post_summ(post, "^q_Sa_adj[.+,7]$"), q_obs[observable,7], main = "Hat. Female Age 3")
plot_tseries(post_summ(post, "^q_Sa_adj[.+,8]$"), q_obs[observable,8], main = "Hat. Female Age 4")
plot_tseries(post_summ(post, "^q_Sa_adj[.+,9]$"), q_obs[observable,9], main = "Hat. Female Age 5")
plot_tseries(post_summ(post, "^q_Sa_adj[.+,10]$"), q_obs[observable,10], main = "Hat. Male Age 3")
plot_tseries(post_summ(post, "^q_Sa_adj[.+,11]$"), q_obs[observable,11], main = "Hat. Male Age 4")
plot_tseries(post_summ(post, "^q_Sa_adj[.+,12]$"), q_obs[observable,12], main = "Hat. Male Age 5")
mtext(side = 1, outer = T, line = 0.25, "Brood Year")
mtext(side = 2, outer = T, line = 0.25, "Proportion of Return")
```

## Spawn Status Data

```{r spawn-status-fits, fig.width = 3.5, fig.height = 5}
par(oma = c(1.5,1.5,0,0))
layout(matrix(c(1,2), 2, 1), heights = c(1, 0.65))
plot_tseries(post_summ(post, "^phi_Sb_Sa["), with(jags_data, carcs_spawned/carcs_sampled)[observable], main = "Successful Spawning")
mtext(side = 2, "Survival Probability", line = 1.5)

at_x = seq(1, length(observable), 4)
par(mar = c(2,2,0,1), yaxs = "i")
mp = barplot(jags_data$carcs_sampled[observable], xaxt = "n", ylim = c(0, max(jags_data$carcs_sampled, na.rm = T)) + c(0, 5))
axis(side = 1, at = mp[at_x], labels = substr( names(jags_data$carcs_sampled[observable]), 3, 4)[at_x])
box()
mtext(side = 2, "Carcasses Sampled", line = 1.5)
mtext(side = 1, "Brood Year", line = 1.5)
```

# Spawner-to-Parr Relationship

All red components are posterior summaries (medians and 95% credible intervals). The black curve is from an `nls()` fit on reconstructed parr and spawners -- the grey region is the confidence interval around this fit (from a parametric bootstrap).

```{r spawners-to-parr, fig.width = 6, fig.height = 4}
# extract posterior samples of the BH productivity and capacity parameters
bh_params = post_subset(post, c("alpha", "beta"), matrix = T)

# extract posterior summaries of total spawners by brood year
Sa_tot = post_summ(post, "Sa_tot")

# extract posterior summaries of total parr recruits by brood year
Pb = post_summ(post, "^Pb[")

# predict parr recruits along a sequence of spawner abundances
Sa_pred = seq(0, max(Sa_tot[5,]), length = 30)
Pb_pred = t(sapply(1:post_dim(post, "saved"), function(i) BH(Sa_pred, bh_params[i,1], bh_params[i,2])))
colnames(Pb_pred) = paste0("Pb_pred[", 1:length(Sa_pred), "]")
Pb_pred = post_convert(cbind(postpack:::id_mat(post), Pb_pred))
Pb_pred = post_summ(Pb_pred, "Pb_pred")

# fit ordinary least squares version
ols_fit = fit_basic_BH(jags_data)$BH_fit

# draw 1000 random parameters
ols_params = exp(rmvnorm(1000, coef(ols_fit), vcov(ols_fit)))

# calculate predicted curve at each pair/summarize
ols_R_pred = t(sapply(1:1000, function(i) BH(Sa_pred, ols_params[i,1], ols_params[i,2])))
ols_R_pred = apply(ols_R_pred, 2, function(x) quantile(x, c(0.5, 0.025, 0.975)))

# graphical parameters
par(mar = c(3,3,1,1), mgp = c(2,0.3,0), tcl = -0.2)

# empty plot
plot(1, 1, type = "n", xlim = range(0, Sa_tot[5,]), ylim = range(0, Pb[5,], Pb_pred[5,]),
     xlab = "Spawners", ylab = "Parr Recruits")

# draw fitted relationship: Bayesian
polygon(c(Sa_pred, rev(Sa_pred)), c(Pb_pred[4,], rev(Pb_pred[5,])), col = alpha("salmon", 0.5), border = NA)
lines(Pb_pred[4,] ~ Sa_pred, col = "red", lty = 2)
lines(Pb_pred[5,] ~ Sa_pred, col = "red", lty = 2)

# draw fitted relationship: OLS
polygon(c(Sa_pred, rev(Sa_pred)), c(ols_R_pred[2,], rev(ols_R_pred[3,])), col = alpha("grey", 0.5), border = NA)
lines(ols_R_pred[1,] ~ Sa_pred, lwd = 2)
lines(ols_R_pred[2,] ~ Sa_pred, lty = 2)
lines(ols_R_pred[3,] ~ Sa_pred, lty = 2)
lines(Pb_pred[3,] ~ Sa_pred, col = "red", lwd = 2)

# draw state pairs + uncertainty
segments(Sa_tot[4,], Pb[3,], Sa_tot[5,], Pb[3,], col = "red")
segments(Sa_tot[3,], Pb[4,], Sa_tot[3,], Pb[5,], col = "red")
points(Pb[3,] ~ Sa_tot[3,], pch = 21, col = "red", bg = alpha("salmon", 0.5))
```

# Overwinter Survival Relationships

```{r overwinter-survival, fig.width = 4, fig.height = 7}

# extract parr, scale it to PEU, and add to posterior samples
Pa = post_subset(post, "^Pa[", matrix = T)
Pa_scaled = Pa/jags_data$peu
colnames(Pa_scaled) = gsub("Pa", "Pa_scaled", x = colnames(Pa_scaled))
post = post_bind(post, Pa_scaled)

# summarize posterior of scaled parr
Pa_scaled_mean = array_format(post_summ(post, "Pa_scaled")["mean",])
Pa_scaled_lwr = array_format(post_summ(post, "Pa_scaled")["2.5%",])
Pa_scaled_upr = array_format(post_summ(post, "Pa_scaled")["97.5%",])

# create vectors to predict survival at: for credible regions and mean curve
Pa_scaled_seq = matrix(NA, 30, 2)
Pa_scaled_seq[,1] = seq(min(Pa_scaled_lwr[,1], na.rm = T), max(Pa_scaled_upr[,1], na.rm = T), length = 30)
Pa_scaled_seq[,2] = seq(min(Pa_scaled_lwr[,2], na.rm = T), max(Pa_scaled_upr[,2], na.rm = T), length = 30)

# extract posteriors of coefficients
gamma0 = post_subset(post, "gamma0", matrix = T)
gamma1 = post_subset(post, "gamma1", matrix = T)

# extract/format posterior summaries of realized survivals
phi_Pa_Mb_mean = array_format(post_summ(post, "^phi_Pa_Mb[")["mean",])
phi_Pa_Mb_lwr = array_format(post_summ(post, "^phi_Pa_Mb[")["2.5%",])
phi_Pa_Mb_upr = array_format(post_summ(post, "^phi_Pa_Mb[")["97.5%",])

# function to create predicted survival curves for one posterior sample
f = function(i) {
  pred_phi_Pa_Mb1 = plogis(gamma0[i,1] + gamma1[i,1] * Pa_scaled_seq[,1])
  pred_phi_Pa_Mb2 = plogis(gamma0[i,2] + gamma1[i,2] * Pa_scaled_seq[,2])

  names(pred_phi_Pa_Mb1) = paste0("pred_phi_Pa_Mb[", 1:30, ",1]")
  names(pred_phi_Pa_Mb2) = paste0("pred_phi_Pa_Mb[", 1:30, ",2]")

  c(pred_phi_Pa_Mb1, pred_phi_Pa_Mb2)
}

# calculate predicted survivals and add to posterior samples
pred_phi_Pa_Mb = t(sapply(1:post_dim(post, "saved"), f))
post = post_bind(post, pred_phi_Pa_Mb)

# summarize predicted survivals
pred_phi_Pa_Mb_mean = array_format(post_summ(post, "pred_phi_Pa_Mb")["mean",])
pred_phi_Pa_Mb_lwr = array_format(post_summ(post, "pred_phi_Pa_Mb")["2.5%",])
pred_phi_Pa_Mb_upr = array_format(post_summ(post, "pred_phi_Pa_Mb")["97.5%",])

# function to draw plot for one LH-type
plot_fun = function(i) {
  # blank plot of correct dimensions
  plot(1,1, type = "n", 
       ylim = range(pred_phi_Pa_Mb_lwr[,i], pred_phi_Pa_Mb_upr[,i], phi_Pa_Mb_lwr[,i], phi_Pa_Mb_upr[,i], na.rm = T),
       xlim = range(0, Pa_scaled_seq), 
       main = c("Fall Migrants", "Spring Migrants")[i]
  )
  
  # expected relationship
  polygon(c(Pa_scaled_seq[,i], rev(Pa_scaled_seq[,i])), c(pred_phi_Pa_Mb_lwr[,i], rev(pred_phi_Pa_Mb_upr[,i])), border = NA, col = alpha("salmon", 0.5))
  lines(pred_phi_Pa_Mb_lwr[,i] ~ Pa_scaled_seq[,i], col = "red", lty = 2)
  lines(pred_phi_Pa_Mb_upr[,i] ~ Pa_scaled_seq[,i], col = "red", lty = 2)
  lines(pred_phi_Pa_Mb_mean[,i] ~ Pa_scaled_seq[,i], col = "red", lwd = 2)
  
  # realized survivals
  segments(Pa_scaled_lwr[,i], phi_Pa_Mb_mean[,i], Pa_scaled_upr[,i], phi_Pa_Mb_mean[,i], col = alpha("red", 0.5))
  segments(Pa_scaled_mean[,i], phi_Pa_Mb_lwr[,i], Pa_scaled_mean[,i], phi_Pa_Mb_upr[,i], col = alpha("red", 0.5))
  points(phi_Pa_Mb_mean[,i] ~ Pa_scaled_mean[,i], pch = 21, col = "red", bg = alpha("salmon", 0.5))
}

# create the plot
par(mfrow = c(2,1), mgp = c(2,0.35, 0), tcl = -0.15, mar = c(1,1,2,1), oma = c(2,2,0,0))
plot_fun(1)
plot_fun(2)
mtext(side = 1, line = 1, outer = T, "LH-Specific Parr/PEU", cex = 1.2)
mtext(side = 2, line = 1, outer = T, "Overwinter Survival", cex = 1.2)
```

# Parameter Estimates {.tabset .tabset-pills}

**Quick refresher on parameter names**
_In alphabetical order, as displayed in figures_

* `mu_omega[1]`: mean probability of being a female at ocean entry
* `mu_phi_Ma_M`: mean probability of surviving from LGD to ocean entry
* `mu_phi_Mb_M`: mean probability of surviving from hatchery release in spring to estuary (hatchery fish)
* `mu_phi_Mb_Ma`: mean probability of surviving movement from tributary to LGD (same for both LH types)
* `mu_phi_Pa_Mb`: mean probability of surviving overwinter in tributary (`[1]`: fall migrants, `[2]`: spring migrants)
* `mu_pi[1]`: mean probability of becoming a fall migrant LH type at end of summer
* `mu_psi_O1_Rb`: mean probability of maturing at age 3 given survived to that point (`[1]`: females, `[2]`: males)
* `mu_psi_O2_Rb`: mean probability of maturing at age 4 given did not mature at age 3 and survived to that point (`[1]`: females, `[2]`: males)

`sig_L*` are the among-year logit-normal standard deviations of these quantities. `sigma_Pb` is lognormal standard deviation of parr recruitment.

## Means

```{r mu-boxplots, fig.width = 6, fig.height = 6}
# parameters to display
keep = match_params(post, "mu")

# remove redundant elements
keep = keep[-which(keep %in% c("mu_init_recruits", "mu_omega[2]", "mu_phi_Mb_Ma[2]", "mu_pi[2]"))]

# extract posterior samples of these parameters: for drawing initial box plot
post_samples = post_subset(post, keep, T)

# calculate custom summaries of these parameters: for drawing actual box plot
post_summaries = post_summ(post, keep, probs = c(0.025, 0.25, 0.5, 0.75, 0.975))[-c(1:2),]

# graphical parameters
par(mar = c(8,3,1,1), mgp = c(2,0.3,0), tcl = -0.2)

# set up a box plot and replace the stats with the custom stats
bp = boxplot(post_samples, plot = F)
bp$stats = post_summaries

# draw the box plot
bxp(bp, ylim = c(0,1), outline = F, las = 2, boxcol = "red", medcol = "red", whiskcol = "red", staplecol = "red", boxfill = alpha("salmon", 0.5))
```

## Standard Deviations

```{r sig-boxplots, fig.width = 6, fig.height = 6}
# parameters to display
keep = match_params(post, "sig")

# remove redundant elements
keep = keep[-which(keep %in% c("sig_init_lrecruits", "sig_Lphi_Mb_Ma[2]"))]

# extract posterior samples of these parameters: for drawing initial box plot
post_samples = post_subset(post, keep, T)

# calculate custom summaries of these parameters: for drawing actual box plot
post_summaries = post_summ(post, keep, probs = c(0.025, 0.25, 0.5, 0.75, 0.975))[-c(1:2),]

# graphical parameters
par(mar = c(8,3,1,1), mgp = c(2,0.3,0), tcl = -0.2)

# set up a box plot and replace the stats with the custom stats
bp = boxplot(post_samples, plot = F)
bp$stats = post_summaries

# draw the box plot
bxp(bp, ylim = c(0,max(post_summaries)), outline = F, las = 2, boxcol = "red", medcol = "red", whiskcol = "red", staplecol = "red", boxfill = alpha("salmon", 0.5))
```

