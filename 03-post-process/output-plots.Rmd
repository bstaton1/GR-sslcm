---
title: "Output Summary"
subtitle: "`r paste0('Model Scenario: ', params$scenario)`" 
date: "`r paste0('Date Rendered: ', Sys.Date())`"
output: 
  html_document:
    toc: true
    toc_float: true
params:
  scenario:
    label: "Scenario"
    value: "size-based-surv"
    input: text
  include_sim_years:
    label: "Include Simulated Years on Plots?"
    value: TRUE
    input: checkbox
  thin_percent:
    label: "Proportion of Posterior Samples to Retain?"
    value: 1
    input: numeric
editor_options: 
  chunk_output_type: console
---

```{r directories, include = F}
# set root directory to the project directory: one level up from this location
knitr::opts_knit$set(root.dir = "../")
```

```{r setup, include = FALSE}
# set global knitting options
knitr::opts_chunk$set(echo = FALSE, fig.align = "center")

# load packages
source("00-packages.R")

# load all necessary functions
invisible(sapply(list.files(path = "01-functions", pattern = "\\.R$", full.names = T), source))

# set the input directory
in_dir = "02-model/model-output"

# read information from this model
model_info = readRDS(file.path(in_dir, paste0("output-", params$scenario, ".rds")))

# extract the posterior samples
# post-MCMC thinning allowed to reduce run time of this document
if (params$thin_percent < 1) {
  post = post_thin(model_info$post, keep_percent = params$thin_percent)
} else {
  post = model_info$post
}

# extract the model data 
jags_data = model_info$jags_data
```

```{r dimension-ids}
# the years included by the model
all_yrs = as.numeric(dimnames(jags_data$phi_SL)[[1]])

# which years are "observable" for at least some quantities?
observable = 2:jags_data$ny_obs

# which years are simulated for at least some quantities?
simulated = which(!(all_yrs %in% all_yrs[observable]) & all_yrs > min(all_yrs[observable]))

# which years should be included in time series plots?
if (params$include_sim_years) {
  ts_yrs = c(observable, simulated)
} else {
  ts_yrs = observable
}

# which years can be plotted for SARs? Drop off last kmax years
# since brood year adult returns not complete
sar_yrs = ts_yrs[-((length(ts_yrs) - jags_data$kmax + 1):length(ts_yrs))]

# population names
pops = colnames(jags_data$Ra_obs)

# origin names
origins = c("NOR", "HOR")

# dimension IDs
i_fall   = 1  # fall migrants are i = 1
i_spring = 2  # spring migrants are i = 2,
o_nor    = 1  # natural origin are o = 1,
o_hor    = 2  # hatchery origin are o = 2,
j_cat    = 1  # Catherine Creek is j = 1
j_los    = 2  # Lostine River is j = 2
j_min    = 3  # Minam River is j = 3
j_ugr    = 4  # Upper Grande Ronde River is j = 4
k_3      = 1  # age 3 is k = 1
k_4      = 2  # age 4 is k = 2
k_5      = 3  # age 5 is k = 3

# ko represents "age/origin" combo
# e.g., ko = 1 is age 3 NORs
# e.g., ko = 5 is age 4 HORs
# these objects specify which elements of ko are for different aggregations of these
ko_age = list(
  ko_3 = c(1, 4),
  ko_4 = c(2, 5),
  ko_5 = c(3, 6)
)

ko_origin = list(
  ko_nor = 1:3,
  ko_hor = 4:6
)

# make the labels for which elements of the rho matrices contain unique elements
dummy_cols = matrix(rep(1:jags_data$nj, each = jags_data$nj), jags_data$nj, jags_data$nj)
dummy_rows = matrix(rep(1:jags_data$nj, jags_data$nj), jags_data$nj, jags_data$nj)
vcov_cols = dummy_cols[lower.tri(dummy_cols)]
vcov_rows = dummy_rows[lower.tri(dummy_rows)]
vcov_labels = paste0(pops[vcov_rows], "-", pops[vcov_cols])
```

# MCMC Information {.tabset .tabset-pills}

## Time Information

```{r mcmc-time-info}
# Calculate hours per 10,000 iterations
hrs_per_ten_thousand_iters = with(model_info$jags_dims, {
  # calculation of total iters differs if parallel or not
  if (parallel) {
    total_iters = n_adapt + n_post + n_burn
  } else {
    total_iters = (n_adapt + n_post + n_burn) * n_chains
  }
  ten_thousands_of_total_iters = total_iters/10000
  
  # calculate hours elapsed
  time_diff = as.POSIXct.default(model_info$jags_time["stoptime"]) - as.POSIXct.default(model_info$jags_time["starttime"])
  time_number = as.numeric(time_diff)
  time_units = attributes(time_diff)$units
  hour_convert = switch(time_units,
                        "secs" = 3600,
                        "mins" = 60,
                        "hours" = 1,
                        "days" = 1/24)
  hours_diff = time_number/hour_convert
  
  # calculate/round rate
  round(hours_diff/ten_thousands_of_total_iters, 2)
})

# combine relevant info into a data frame
df = data.frame(Value = c(model_info$jags_time, ifelse(model_info$jags_dims$parallel, "Yes", "No"), hrs_per_ten_thousand_iters))
rownames(df) = c("Time Started", "Time Ended", "Time Elapsed", "Chains Ran in Parallel?", "Hours Per 10,000 Iterations")

# make a kable for printing in output
kable(df) %>%
  kable_styling(full_width = F, bootstrap_options = "condensed") %>%
  column_spec(1, bold = TRUE)
```

## Attributes

This table shows some dimensions of the MCMC run.

```{r mcmc-dims}
# query the dimensions of the posterior samples
dims = post_dim(post)

# build a data frame for printing
df = data.frame(Quantity = c("Burn-in + Adapt Iters", "Post Burn-in Iters", "Thinning Interval", "Chains", "Saved Iters", "Monitored Quantities"), Value = unname(dims))

# render the table
kable(df, format.args = list(big.mark = ",")) %>%
  kable_styling(full_width = F, bootstrap_options = c("striped", "condensed")) %>%
  column_spec(1, bold = TRUE)
```

## Sampling Diagnostics {.tabset .tabset-pills}

```{r make-diag-post}
# make a reduced diagnostic posterior: drop out all quantities associated with simulated years
# there is no point in calculating diagnostic summaries for future years
if (length(simulated) > 0) {
  diag_post = suppressMessages(post_remove(post, paste0("[", simulated), ask = FALSE))
} else {
  diag_post = post
}

# discard duplicate correlation terms: all rho parameters for a given process are equal
all_rho = match_params(post, "^rho")
rho_keep = match_params(post, "^rho_.+[2,1")
rho_discard = all_rho[!(all_rho %in% rho_keep)]
diag_post = suppressMessages(post_remove(diag_post, rho_discard, ask = FALSE))
```

```{r mcmc-diag-function}
# a function to get MCMC diagnoses for a group of parameters
# params: a string to match with postpack::match_params()
# L1: a "Level-1" group label; such as component of the model (e.g., LH apportionment)
# L2: a "Level-2" group label; such as type of parameter (e.g., mean, sd, or year-specific value)
# L3: a "Level-3" group label; such as NOR or HOR

summarize_posterior = function(params, L1 = NA, L2 = NA, L3 = NA) {
  # extract the posteriors of interest and format for 'posterior' package
  post_sub = as_draws_df(post_subset(diag_post, params))

  # summarize the posteriors
  diags = summarize_draws(post_sub, mean, ~quantile(.x, c(0.025, 0.975)), rhat, ess_mean, ~ess_quantile(.x, probs = c(0.025, 0.975)), mcse_mean, ~mcse_quantile(.x, probs = c(0.025, 0.975)))
  
  # discard any parameters that were the same value every MCMC iteration
  # (will have an NA for rhat)
  diags = diags[!is.na(diags$rhat),]
  
  # append the level names and return
  cbind(
    L1 = L1, L2 = L2, L3 = L3,
    diags
  )
}

summarize_diags = function(diags) {
  
  # add "Monte Carlo CV"
  diags$mccv_mean = diags$mcse_mean/diags$mean
  diags$mccv_q2.5 = diags$mcse_q2.5/diags$`2.5%`
  diags$mccv_q97.5 = diags$mcse_q97.5/diags$`97.5%`
  
  # summarize the summaries
  data.frame(
    L1 = unique(diags$L1),
    L2 = unique(diags$L2),
    L3 = unique(diags$L3),
    match = unique(postpack:::drop_index(diags$variable)),
    n_params = nrow(diags),
    Rhat_1.01 = sum(diags$rhat >= 1.01),
    Rhat_1.05 = sum(diags$rhat >= 1.05),
    Rhat_1.1 = sum(diags$rhat >= 1.1),
    Rhat_1.2 = sum(diags$rhat >= 1.2),
    ess_mean_400 = sum(diags$ess_mean < 400),
    ess_q2.5_400 = sum(diags$ess_q2.5 < 400),
    ess_q97.5_400 = sum(diags$ess_q97.5 < 400),
    mccv_mean_0.05 = sum(diags$mccv_mean > 0.05),
    mccv_q2.5_0.05 = sum(diags$mccv_q2.5 > 0.05),
    mccv_q97.5_0.05 = sum(diags$mccv_q97.5 > 0.05)
  )
}
```

```{r calculate-mcmc-diagnostics}
# containers
diags_out = NULL
summs_out = NULL

# parr recruitment
L1 = "Egg-to-Parr Survival"
L2 = c("BH Productivity", "BH Capacity", "Capacity vs. Habitat Slope", "Capacity vs. slope SD", "Process SD", "Among-pop Correlation", "Realized")
match = c("alpha", "^beta[", "lambda", "sig_lbeta", "sig_Lphi_E_Pb", "rho_Lphi_E_Pb", "^phi_E_Pb[")
tmp_diags = lapply(1:length(match), function(i) summarize_posterior(match[i], L1 = L1, L2 = L2[i]))
tmp_summ = lapply(tmp_diags, function(i) summarize_diags(i))
diags_out = rbind(diags_out, do.call(rbind, tmp_diags))
summs_out = rbind(summs_out, do.call(rbind, tmp_summ))

# summer parr mean length
L1 = "Density-Dependent Summer Length"
L2 = c("Intercept", "Slope", "Process SD", "Among-pop Correlation", "Realized")
match = c("omega0", "omega1", "sig_lL_Pb", "rho_lL_Pb", "^L_Pb[")
tmp_diags = lapply(1:length(match), function(i) summarize_posterior(match[i], L1 = L1, L2 = L2[i]))
tmp_summ = lapply(tmp_diags, function(i) summarize_diags(i))
diags_out = rbind(diags_out, do.call(rbind, tmp_diags))
summs_out = rbind(summs_out, do.call(rbind, tmp_summ))

# LH apportionment
L1 = "Life History Apportionment"
L2 = c("Mean", "Process SD", "Among-pop Correlation", "Realized")
match = c("mu_pi[1,.]", "sig_Lpi", "rho_Lpi", "^pi[.+,1,.]")
tmp_diags = lapply(1:length(match), function(i) summarize_posterior(match[i], L1 = L1, L2 = L2[i]))
tmp_summ = lapply(tmp_diags, function(i) summarize_diags(i))
diags_out = rbind(diags_out, do.call(rbind, tmp_diags))
summs_out = rbind(summs_out, do.call(rbind, tmp_summ))

# parr survival from summer to winter tagging
L1 = "Survival From Summer to Winter"
match = c("phi_Pb_Pa[2,.]")
tmp_diags = lapply(1:length(match), function(i) summarize_posterior(match[i], L1 = L1))
tmp_summ = lapply(tmp_diags, function(i) summarize_diags(i))
diags_out = rbind(diags_out, do.call(rbind, tmp_diags))
summs_out = rbind(summs_out, do.call(rbind, tmp_summ))

# Overwinter survival: Fall Migrants
L1 = "Overwinter Survival"
L2 = c("Intercept", "Slope", "Process SD", "Among-pop Correlation", "Realized")
base = list("gamma0[LH_type,pop]", "gamma1[LH_type,pop]", "sig_Lphi_Pa_Mb[LH_type,pop]", "rho_Lphi_Pa_Mb[.,.,LH_type]", "^phi_Pa_Mb[year,LH_type,pop]")
match = sub_index(base, year = ".+", LH_type = i_fall, pop = ".")
tmp_diags = lapply(1:length(match), function(i) summarize_posterior(match[i], L1 = L1, L2 = L2[i], L3 = "Fall Migrants"))
tmp_summ = lapply(tmp_diags, function(i) summarize_diags(i))
diags_out = rbind(diags_out, do.call(rbind, tmp_diags))
summs_out = rbind(summs_out, do.call(rbind, tmp_summ))

# Overwinter survival: Spring Migrants
L1 = "Overwinter Survival"
L2 = c("Intercept", "Slope", "Process SD", "Among-pop Correlation", "Realized")
base = list("gamma0[LH_type,pop]", "gamma1[LH_type,pop]", "sig_Lphi_Pa_Mb[LH_type,pop]", "rho_Lphi_Pa_Mb[.,.,LH_type]", "^phi_Pa_Mb[year,LH_type,pop]")
match = sub_index(base, year = ".+", LH_type = i_spring, pop = ".")
tmp_diags = lapply(1:length(match), function(i) summarize_posterior(match[i], L1 = L1, L2 = L2[i], L3 = "Spring Migrants"))
tmp_summ = lapply(tmp_diags, function(i) summarize_diags(i))
diags_out = rbind(diags_out, do.call(rbind, tmp_diags))
summs_out = rbind(summs_out, do.call(rbind, tmp_summ))

# growth from summer to spring
# summer parr mean length
L1 = "Summer to Spring Growth"
L2 = c("Mean", "Process SD", "Among-pop Correlation", "Realized")
match = c("mu_growth", "sig_lgrowth", "rho_lgrowth", "^growth[")
tmp_diags = lapply(1:length(match), function(i) summarize_posterior(match[i], L1 = L1, L2 = L2[i]))
tmp_summ = lapply(tmp_diags, function(i) summarize_diags(i))
diags_out = rbind(diags_out, do.call(rbind, tmp_diags))
summs_out = rbind(summs_out, do.call(rbind, tmp_summ))

# trib to LGR Migration survival: NOR 
L1 = "Migration Survival (Trib to LGR)"
L2 = c("Intercept", "Slope", "Process SD", "Among-pop Correlation", "Realized")
base = c("tau0", "tau1", "sig_Lphi_Mb_Ma[pop,origin]", "rho_Lphi_Mb_Ma[.,.,origin]", "^phi_Mb_Ma[.+,LH_type,origin,pop]")
match = sub_index(base, LH_type = i_spring, origin = o_nor, pop = ".", year = ".+")
tmp_diags = lapply(1:length(match), function(i) summarize_posterior(match[i], L1 = L1, L2 = L2[i], L3 = "NOR"))
tmp_summ = lapply(tmp_diags, function(i) summarize_diags(i))
diags_out = rbind(diags_out, do.call(rbind, tmp_diags))
summs_out = rbind(summs_out, do.call(rbind, tmp_summ))

# trib to LGR Migration survival: HOR 
L1 = "Migration Survival (Trib to LGR)"
L2 = c("Mean", "Process SD", "Among-pop Correlation", "Realized")
base = list("mu_phi_Mb_Ma[LH_type,origin,pop]", "sig_Lphi_Mb_Ma[pop,origin]", "rho_Lphi_Mb_Ma[.,.,origin]", "phi_Mb_Ma[year,LH_type,origin,pop]")
match = sub_index(base, year = ".+", LH_type = i_spring, origin = o_hor, pop = ".")
tmp_diags = lapply(1:length(match), function(i) summarize_posterior(match[i], L1 = L1, L2 = L2[i], L3 = "HOR"))
tmp_summ = lapply(tmp_diags, function(i) summarize_diags(i))
diags_out = rbind(diags_out, do.call(rbind, tmp_diags))
summs_out = rbind(summs_out, do.call(rbind, tmp_summ))

# LGR to Ocean Migration survival: NOR
L1 = "Migration Survival (LGR to Ocean)"
L2 = c("Mean", "Process SD", "Realized")
base = c("mu_phi_Ma_O0[origin]", "sig_Lphi_Ma_O0[origin]", "phi_Ma_O0[year,origin]")
match = sub_index(base, year = ".+", origin = o_nor)
tmp_diags = lapply(1:length(match), function(i) summarize_posterior(match[i], L1 = L1, L2 = L2[i], L3 = "NOR"))
tmp_summ = lapply(tmp_diags, function(i) summarize_diags(i))
diags_out = rbind(diags_out, do.call(rbind, tmp_diags))
summs_out = rbind(summs_out, do.call(rbind, tmp_summ))

# LGR to Ocean Migration survival: HOR
L1 = "Migration Survival (LGR to Ocean)"
L2 = c("Mean", "Process SD", "Realized")
base = c("mu_phi_Ma_O0[origin]", "sig_Lphi_Ma_O0[origin]", "phi_Ma_O0[year,origin]")
match = sub_index(base, year = ".+", origin = o_hor)
tmp_diags = lapply(1:length(match), function(i) summarize_posterior(match[i], L1 = L1, L2 = L2[i], L3 = "HOR"))
tmp_summ = lapply(tmp_diags, function(i) summarize_diags(i))
diags_out = rbind(diags_out, do.call(rbind, tmp_diags))
summs_out = rbind(summs_out, do.call(rbind, tmp_summ))

# LGR to Ocean Migration survival correlation among origins
tmp_diags = summarize_posterior("rho_Lphi_Ma_O0[2,1]", L1 = L1, L2 ="Among-origin Correlation")
tmp_summ =  summarize_diags(tmp_diags)
diags_out = rbind(diags_out, tmp_diags)
summs_out = rbind(summs_out, tmp_summ)

# Probability of Maturing at Age-3: NOR
L1 = "Pr(Mature at Age-3)"
L2 = c("Mean", "Process SD", "Among-pop Correlation", "Realized")
base = c("mu_psi_O1[origin,pop]", "sig_Lpsi_O1[origin,pop]", "rho_Lpsi_O1[.,.,origin]", "psi_O1[.+,origin,pop]")
match = sub_index(base, year = ".+", origin = o_nor, pop = ".")
tmp_diags = lapply(1:length(match), function(i) summarize_posterior(match[i], L1 = L1, L2 = L2[i], L3 = "NOR"))
tmp_summ = lapply(tmp_diags, function(i) summarize_diags(i))
diags_out = rbind(diags_out, do.call(rbind, tmp_diags))
summs_out = rbind(summs_out, do.call(rbind, tmp_summ))

# Probability of Maturing at Age-3: HOR
L1 = "Pr(Mature at Age-3)"
L2 = c("Mean", "Process SD", "Among-pop Correlation", "Realized")
base = c("mu_psi_O1[origin,pop]", "sig_Lpsi_O1[origin,pop]", "rho_Lpsi_O1[.,.,origin]", "psi_O1[.+,origin,pop]")
match = sub_index(base, year = ".+", origin = o_hor, pop = ".")
tmp_diags = lapply(1:length(match), function(i) summarize_posterior(match[i], L1 = L1, L2 = L2[i], L3 = "HOR"))
tmp_summ = lapply(tmp_diags, function(i) summarize_diags(i))
diags_out = rbind(diags_out, do.call(rbind, tmp_diags))
summs_out = rbind(summs_out, do.call(rbind, tmp_summ))

# Probability of Maturing at Age-4: NOR
L1 = "Pr(Mature at Age-4)"
L2 = c("Mean", "Process SD", "Among-pop Correlation", "Realized")
base = c("mu_psi_O2[origin,pop]", "sig_Lpsi_O2[origin,pop]", "rho_Lpsi_O2[.,.,origin]", "psi_O2[.+,origin,pop]")
match = sub_index(base, year = ".+", origin = o_nor, pop = ".")
tmp_diags = lapply(1:length(match), function(i) summarize_posterior(match[i], L1 = L1, L2 = L2[i], L3 = "NOR"))
tmp_summ = lapply(tmp_diags, function(i) summarize_diags(i))
diags_out = rbind(diags_out, do.call(rbind, tmp_diags))
summs_out = rbind(summs_out, do.call(rbind, tmp_summ))

# Probability of Maturing at Age-4: HOR
L1 = "Pr(Mature at Age-4)"
L2 = c("Mean", "Process SD", "Among-pop Correlation", "Realized")
base = c("mu_psi_O2[origin,pop]", "sig_Lpsi_O2[origin,pop]", "rho_Lpsi_O2[.,.,origin]", "psi_O2[.+,origin,pop]")
match = sub_index(base, year = ".+", origin = o_hor, pop = ".")
tmp_diags = lapply(1:length(match), function(i) summarize_posterior(match[i], L1 = L1, L2 = L2[i], L3 = "HOR"))
tmp_summ = lapply(tmp_diags, function(i) summarize_diags(i))
diags_out = rbind(diags_out, do.call(rbind, tmp_diags))
summs_out = rbind(summs_out, do.call(rbind, tmp_summ))

# Year 1 ocean survival
L1 = "Year 1 Ocean Survival"
L2 = c("Mean", "Process SD", "Among-pop Correlation", "Realized")
base = c("mu_phi_O0_O1[origin,pop]", "sig_Lphi_O0_O1[pop]", "rho_Lphi_O0_O1", "phi_O0_O1[year,origin,pop]")
match = sub_index(base, year = ".+", origin = o_nor, pop = ".+")
tmp_diags = lapply(1:length(match), function(i) summarize_posterior(match[i], L1 = L1, L2 = L2[i]))
tmp_summ = lapply(tmp_diags, function(i) summarize_diags(i))
diags_out = rbind(diags_out, do.call(rbind, tmp_diags))
summs_out = rbind(summs_out, do.call(rbind, tmp_summ))

# Year 2 ocean survival
L1 = "Year 2 Ocean Survival"
L2 = c("Mean")
base = c("mu_phi_O1_O2[origin,pop]")
match = sub_index(base, year = ".+", origin = o_nor, pop = ".+")
tmp_diags = lapply(1:length(match), function(i) summarize_posterior(match[i], L1 = L1, L2 = L2[i]))
tmp_summ = lapply(tmp_diags, function(i) summarize_diags(i))
diags_out = rbind(diags_out, do.call(rbind, tmp_diags))
summs_out = rbind(summs_out, do.call(rbind, tmp_summ))

# Year 2 ocean survival
L1 = "Year 3 Ocean Survival"
L2 = c("Mean")
base = c("mu_phi_O2_O3[origin,pop]")
match = sub_index(base, year = ".+", origin = o_nor, pop = ".+")
tmp_diags = lapply(1:length(match), function(i) summarize_posterior(match[i], L1 = L1, L2 = L2[i]))
tmp_summ = lapply(tmp_diags, function(i) summarize_diags(i))
diags_out = rbind(diags_out, do.call(rbind, tmp_diags))
summs_out = rbind(summs_out, do.call(rbind, tmp_summ))

# Misc ocean survival
L1 = "Misc Ocean Survival"
L2 = c("Yr1 NOR:HOR Scaler", "Yr2 NOR:HOR Scaler", "Yr3 NOR:HOR Scaler", "Yr1 Initial Residual", "Yr 1 AR(1) Coefficient")
base = c("delta_O0_O1[pop]", "delta_O1_O2[pop]", "delta_O2_O3[pop]", "Lphi_O0_O1_resid[5,1,pop]", "kappa_phi_O0_O1[pop]")
match = sub_index(base, pop = ".")
tmp_diags = lapply(1:length(match), function(i) summarize_posterior(match[i], L1 = L1, L2 = L2[i]))
tmp_summ = lapply(tmp_diags, function(i) summarize_diags(i))
diags_out = rbind(diags_out, do.call(rbind, tmp_diags))
summs_out = rbind(summs_out, do.call(rbind, tmp_summ))

# BON to LGR Migration survival: NOR 
L1 = "Migration Survival (BON to LGR)"
L2 = c("Mean", "Process SD", "Realized")
base = c("mu_phi_Rb_Ra[origin]", "sig_Lphi_Rb_Ra[origin]", "phi_Rb_Ra[year,origin]")
match = sub_index(base, year = ".+", origin = o_nor)
tmp_diags = lapply(1:length(match), function(i) summarize_posterior(match[i], L1 = L1, L2 = L2[i], L3 = "NOR"))
tmp_summ = lapply(tmp_diags, function(i) summarize_diags(i))
diags_out = rbind(diags_out, do.call(rbind, tmp_diags))
summs_out = rbind(summs_out, do.call(rbind, tmp_summ))

# BON to LGR Migration survival: HOR 
L1 = "Migration Survival (BON to LGR)"
L2 = c("Mean", "Process SD", "Realized")
base = c("mu_phi_Rb_Ra[origin]", "sig_Lphi_Rb_Ra[origin]", "phi_Rb_Ra[year,origin]")
match = sub_index(base, year = ".+", origin = o_hor)
tmp_diags = lapply(1:length(match), function(i) summarize_posterior(match[i], L1 = L1, L2 = L2[i], L3 = "HOR"))
tmp_summ = lapply(tmp_diags, function(i) summarize_diags(i))
diags_out = rbind(diags_out, do.call(rbind, tmp_diags))
summs_out = rbind(summs_out, do.call(rbind, tmp_summ))

# LGR to Ocean Migration survival correlation among origins
tmp_diags = summarize_posterior("rho_Lphi_Rb_Ra[2,1]", L1 = L1, L2 ="Among-origin Correlation")
tmp_summ =  summarize_diags(tmp_diags)
diags_out = rbind(diags_out, tmp_diags)
summs_out = rbind(summs_out, tmp_summ)

# Pre-spawn Survival
L1 = "Pre-spawn Survival"
L2 = c("Mean", "Process SD", "Among-pop Correlation", "Realized")
match = c("mu_phi_Sb_Sa[.]", "sig_Lphi_Sb_Sa[.]", "rho_Lphi_Sb_Sa", "phi_Sb_Sa[.+,.]")
tmp_diags = lapply(1:length(match), function(i) summarize_posterior(match[i], L1 = L1, L2 = L2[i]))
tmp_summ = lapply(tmp_diags, function(i) summarize_diags(i))
diags_out = rbind(diags_out, do.call(rbind, tmp_diags))
summs_out = rbind(summs_out, do.call(rbind, tmp_summ))

# Carcass Correction
L1 = "Carcass Correction Factor"
L2 = c("Among-Pop Mean", "Among-Pop SD", "Pop-Specific")
match = c("mu_z[.]", "sig_z[.]", "^z[.,.]")
tmp_diags = lapply(1:length(match), function(i) summarize_posterior(match[i], L1 = L1, L2 = L2[i]))
tmp_summ = lapply(tmp_diags, function(i) summarize_diags(i))
diags_out = rbind(diags_out, do.call(rbind, tmp_diags))
summs_out = rbind(summs_out, do.call(rbind, tmp_summ))

# Initial adult recruitment
L1 = "Initial Adult Returns"
L2 = c("Age-3", "Age-4", "Age-5")
match = c("Rb\\[[2|3|4],1,1,.\\]", "Rb\\[[2|3|4|5],2,1,.\\]", "Rb\\[[2|3|4|5|6],3,1,.\\]")
tmp_diags = lapply(1:length(match), function(i) summarize_posterior(match[i], L1 = L1, L2 = L2[i]))
tmp_summ = lapply(tmp_diags, function(i) summarize_diags(i))
diags_out = rbind(diags_out, do.call(rbind, tmp_diags))
summs_out = rbind(summs_out, do.call(rbind, tmp_summ))

# Straying
L1 = "Strays"
L2 = c("Realized Total Number", "Age Comp")
match = c(sub_index("G[.,origin,pop]", origin = o_hor, pop = "."), sub_index("p_G[age,origin,pop]", age = ".", origin = o_hor, pop = "."))
tmp_diags = lapply(1:length(match), function(i) summarize_posterior(match[i], L1 = L1, L2 = L2[i]))
tmp_summ = lapply(tmp_diags, function(i) summarize_diags(i))
diags_out = rbind(diags_out, do.call(rbind, tmp_diags))
summs_out = rbind(summs_out, do.call(rbind, tmp_summ))

# remove any summaries for nodes that don't have diagnostics
# e.g., if that "parameter" takes on a fixed value in the model
diags_table = summs_out
diags_table = diags_table[diags_table$n_params > 0,]
```

### Summary Table

This table displays summaries of MCMC diagnostics for all unobserved stochastic nodes in the model. Values in cells represent the percentage of parameters of a given type that fail a diagnostic check. E.g., 50% in the "Rhat > 1.05" column means that half of the parameters of that type had $\hat{R}$ values greater than 1.05. Cells with no color indicate no offense and darker reds indicate greater frequency of an offense.

* $\boldsymbol{\hat{R}}$ measures convergence of multiple chains to a common target distribution. Values close to 1 are ideal, greater than 1.1 are problematic but possibly passable, and greater than 1.2 should probably not be used for inference (general rules).
* **ESS** measures the number of effective MCMC samples are available to estimate a given summary statistic of the posterior -- here the posterior mean and quantiles of the 95% equal-tailed CRI. Percentages shown represent the fraction of parameters that have fewer than 400 ESS -- which Vehtari et al. [2021](https://projecteuclid.org/journals/bayesian-analysis/advance-publication/Rank-Normalization-Folding-and-Localization--An-Improved-R%cb%86-for/10.1214/20-BA1221.full) suggest as a good rule of thumb.
* **MCCV** is Monte Carlo Standard Error of a summary statistic divided by the estimated posterior summary statistic, intended to represent a measure of precision for estimating posterior summary statistics -- here the posterior mean and quantiles of the 95% equal-tailed CRI. Percentages shown represent the fraction of parameters that have greater than 5% MCCV -- which Staton has (arbitrarily and at this time) chosen as the greatest amount of acceptable imprecision.

The calculations behind this table are implemented using the '[posterior](https://mc-stan.org/posterior/articles/posterior.html)' R package, which contains updated MCMC diagnostics (Vehtari et al. [2021](https://projecteuclid.org/journals/bayesian-analysis/advance-publication/Rank-Normalization-Folding-and-Localization--An-Improved-R%cb%86-for/10.1214/20-BA1221.full)).

```{r mcmc-diag-table, warning = FALSE}
# duplicate the diagnostic output
kable_table = diags_table

# order the rows
kable_table$L1 = factor(kable_table$L1, levels = unique(kable_table$L1))
kable_table = diags_table[order(kable_table$L1, kable_table$L2, kable_table$L3),]

# keep only relevant columns for kable
kable_table = kable_table[,-which(colnames(diags_table) %in% c("match", "mean_value", "Rhat_mean", "ess_bulk_mean"))]

# convert counts of offending parameters to percentages
kable_table$Rhat_1.01 = paste0(round(kable_table$Rhat_1.01/kable_table$n_params, 2) * 100, "%")
kable_table$Rhat_1.05 = paste0(round(kable_table$Rhat_1.05/kable_table$n_params, 2) * 100, "%")
kable_table$Rhat_1.1 = paste0(round(kable_table$Rhat_1.1/kable_table$n_params, 2) * 100, "%")
kable_table$Rhat_1.2 = paste0(round(kable_table$Rhat_1.2/kable_table$n_params, 2) * 100, "%")
kable_table$ess_mean_400 = paste0(round(kable_table$ess_mean_400/kable_table$n_params, 2) * 100, "%")
kable_table$ess_q2.5_400 = paste0(round(kable_table$ess_q2.5_400/kable_table$n_params, 2) * 100, "%")
kable_table$ess_q97.5_400 = paste0(round(kable_table$ess_q97.5_400/kable_table$n_params, 2) * 100, "%")
kable_table$mccv_mean_0.05 = paste0(round(kable_table$mccv_mean_0.05/kable_table$n_params, 2) * 100, "%")
kable_table$mccv_q2.5_0.05 = paste0(round(kable_table$mccv_q2.5_0.05/kable_table$n_params, 2) * 100, "%")
kable_table$mccv_q97.5_0.05 = paste0(round(kable_table$mccv_q97.5_0.05/kable_table$n_params, 2) * 100, "%")

# add basic formatting
colnames(kable_table) = c("Model Component", "Parameter Type", "Group", "N", "> 1.01", "> 1.05", "> 1.1", "> 1.2", "Mean", "q2.5", "q97.5", "Mean", "q2.5", "q97.5")
kable_table$Group[is.na(kable_table$Group)] = " "
kable_table$`Parameter Type`[is.na(kable_table$`Parameter Type`)] = " "

assign_color = function(x, colors = c("white","red")) {
  pal = colorRampPalette(colors)
  cols = pal(6)
  bin_names = levels(cut(rbeta(1e6, 1, 1) * 100, breaks = c(0,0.001,20,40,60,80,100), include.lowest = TRUE))
  names(cols) = bin_names
  x[is.na(x)] = 0
  bins = cut(x, breaks = c(0,0.001,20,40,60,80,100), include.lowest = TRUE)
  cols_use = cols[as.character(bins)]
  alpha(unname(cols_use), 0.5)
}

# produce the kable
kable(kable_table, row.names = FALSE, align = c("lllcccccccccc")) %>%
  kable_styling(full_width = TRUE, fixed_thead = TRUE, bootstrap_options = c("condensed")) %>%
  add_header_above(c(" " = 4, "Rhat" = 4, "ESS < 400" = 3, "MCCV > 5%" = 3)) %>%
  column_spec(2:3, width = "150px") %>%
  column_spec(c(4,8,11), border_right = TRUE) %>%
  column_spec(5, background = assign_color(as.numeric(stringr::str_remove(kable_table[,5], "%")))) %>%
  column_spec(6, background = assign_color(as.numeric(stringr::str_remove(kable_table[,6], "%")))) %>%
  column_spec(7, background = assign_color(as.numeric(stringr::str_remove(kable_table[,7], "%")))) %>%
  column_spec(8, background = assign_color(as.numeric(stringr::str_remove(kable_table[,8], "%")))) %>%
  column_spec(9, background = assign_color(as.numeric(stringr::str_remove(kable_table[,9], "%")))) %>%
  column_spec(10, background = assign_color(as.numeric(stringr::str_remove(kable_table[,10], "%")))) %>%
  column_spec(11, background = assign_color(as.numeric(stringr::str_remove(kable_table[,11], "%")))) %>%
  column_spec(12, background = assign_color(as.numeric(stringr::str_remove(kable_table[,12], "%")))) %>%
  column_spec(13, background = assign_color(as.numeric(stringr::str_remove(kable_table[,13], "%")))) %>%
  column_spec(14, background = assign_color(as.numeric(stringr::str_remove(kable_table[,14], "%")))) %>%
  collapse_rows(columns = 1:2)
```

### Figures {.tabset .tabset-pills}

```{r mcmc-diag-plots-prep}
n_max_draw = 30

# which parameters fall in each Rhat bin
rhat_1_params = subset(diags_out, rhat >= 0.8 & rhat < 1.05)$variable
rhat_2_params = subset(diags_out, rhat >= 1.05 & rhat < 1.1)$variable
rhat_3_params = subset(diags_out, rhat >= 1.1 & rhat < 1.5)$variable

# extract the Rhat values and the names of the parameters with the 
# worst Rhat values by bin
rhat_1 = diags_out$rhat[diags_out$variable %in% rhat_1_params]
rhat_1_params_draw = rhat_1_params[order(rhat_1, decreasing = TRUE)][1:min(n_max_draw, length(rhat_1_params))]
rhat_2 = diags_out$rhat[diags_out$variable %in% rhat_2_params]
rhat_2_params_draw = rhat_2_params[order(rhat_2, decreasing = TRUE)][1:min(n_max_draw, length(rhat_2_params))]
rhat_3 = diags_out$rhat[diags_out$variable %in% rhat_3_params]
rhat_3_params_draw = rhat_3_params[order(rhat_3, decreasing = TRUE)][1:min(n_max_draw, length(rhat_3_params))]

# subset out these parameters: makes postpack::diag_plots() much faster
post_sub_1 = post_subset(post, rhat_1_params_draw)
post_sub_2 = post_subset(post, rhat_2_params_draw)
post_sub_3 = post_subset(post, rhat_3_params_draw)

# function to plot a histogram of rhat values
rhat_hist = function(rhat) {
  par(mgp = c(2,0.35, 0), tcl = -0.15, xaxs = "i", yaxs = "i", mar = c(3,3,1,1))
  breaks = seq(min(rhat), max(rhat), length = 20)
  max_count = max(hist(rhat, breaks = breaks, plot = FALSE)$count)
  hist(rhat, breaks = breaks, col = "grey50", border = "white", ylim = c(0, max_count) * 1.025, xlab = TeX("$\\hat{R}$"), main = "")
  usr = par("usr")
  segments(usr[1], usr[3], usr[2], usr[3], xpd = TRUE)
  segments(usr[1], usr[3], usr[1], usr[4], xpd = TRUE)
}
```

#### $1 < \hat{R} < 1.05$ {.tabset .tabset-pills}

##### Distribution

There were **`r length(rhat_1_params)`** of **`r nrow(diags_out)`** unobserved stochastic nodes with $\hat{R}$ in this group. Here is their distribution:

```{r rhat-hist-1, fig.width = 6, fig.height = 4}
rhat_hist(rhat_1)
```

##### Least Converged

Density and trace plots by chain for the `r min(n_max_draw, length(rhat_1_params))` parameters with the highest $\hat{R}$ values in this group are shown.

```{r mcmc-diag-plots-1, fig.width = 11, fig.height = 8.5}
diag_plots(post_sub_1, "", show_diags = "never")
```

#### $1.05 < \hat{R} < 1.1$ {.tabset .tabset-pills}

##### Distribution

There were **`r length(rhat_2_params)`** of **`r nrow(diags_out)`** unobserved stochastic nodes in this group. Here is their distribution:

```{r rhat-hist-2, fig.width = 6, fig.height = 4}
rhat_hist(rhat_2)
```

##### Least Converged

Density and trace plots by chain for the `r min(n_max_draw, length(rhat_2_params))` parameters with the highest $\hat{R}$ values in this group are shown.

```{r mcmc-diag-plots-2, fig.width = 11, fig.height = 8.5}
diag_plots(post_sub_2, "", show_diags = "never")
```

#### $\hat{R} > 1.1$ {.tabset .tabset-pills}

##### Distribution

There were **`r length(rhat_3_params)`** of **`r nrow(diags_out)`** unobserved stochastic nodes in this group. Here is their distribution:

```{r rhat-hist-3, fig.width = 6, fig.height = 4}
rhat_hist(rhat_3)
```

##### Least Converged

Density and trace plots by chain for the `r min(n_max_draw, length(rhat_3_params))` parameters with the highest $\hat{R}$ values in this group are shown.

```{r mcmc-diag-plots-3, fig.width = 11, fig.height = 8.5}
diag_plots(post_sub_3, "", show_diags = "never")
```


## WAIC

WAIC is a measure of model parsimony. The quantity `pD` is an index of model complexity (i.e., "effective parameters") and `deviance` is an index of model fit to the data. There are two methods of calculating `pD`, both are shown below. As for other measures like AIC or BIC, these numbers are really only relevant for comparing among models fitted to the same data set.

```{r calculate-waic, eval = model_info$do_lppd}
summarize_lppd = function(param, LH_type = NULL, origin = NULL, pop = NULL) {
  # calculate total lppd summed across all data sets within a given year
  total_lppd = sapply(observable, function(y) rowSums(post_subset(post, sub_index(param, year = y, LH_type = LH_type, origin = origin, pop = pop), matrix = TRUE)))
  
  tmp_log = log(apply(exp(total_lppd), 2, mean))
  tmp_sum = -2 * sum(tmp_log)
  
  pD1 = 2 * sum(tmp_log - apply(total_lppd, 2, mean))
  pD2 = sum(apply(total_lppd, 2, var))
  round(c(deviance = tmp_sum, pD1 = pD1, pD2 = pD2, WAIC1 = tmp_sum + 2 * pD1, WAIC2 = tmp_sum + 2 * pD2))
}

waic_out = summarize_lppd("_lppd[year,.+]$")

waic_out = as.data.frame(as.list(waic_out))
waic_out %>%
  kbl(format.args = list(big.mark = ",")) %>%
  kable_styling(full_width = FALSE, bootstrap_options = c("condensed"))
```

```{r dont-calculate-waic, eval = !model_info$do_lppd, results='asis'}
cat("_Calculation of log posterior predictive density values needed to calculate WAIC was toggled off when fitting this model, so this output is omitted._")
```

## Posterior Predictive Checks

This output is a diagnostic of the consistency of variability in the data with the variability assumed by the model. For each observed data point and MCMC iteration, a value was simulated from the model. The fit of the observed and simulated data was calculated, and the proportion of MCMC iterations in which the observed data fitted more poorly than the simulated data (i.e., a Bayesian p-value) was calculated. P-values close the 0.5 are ideal (0.4 -- 0.6 have no color below), values closer to 1 (red below) indicate over-dispersion (i.e., model fits real data worse than expected), and values closer to 0 (blue below) indicate under-dispersion (i.e., model fits real data better than expected). Across years within a data set, p-values were summarized as the median and central 95% intervals. The left two columns show the percent of years that had extreme p-values, providing another indication of how often the model fit the real data far better (<0.05) or worse (>0.95) than expected.

The fit criterion differed depending on the likelihood function used to fit the model to the data set:

* **Log-normal**: squared difference of the log-scale observation and log-scale expectation. This applies to all abundance data.
* **Logit-normal**: squared difference of the logit-scale observation and logit-scale expectation. This applies to all survival data, except the BON to LGR and the pre-spawn survival which were fitted using binomial distributions.
* **Binomial/Multinomial**: Freeman-Tukey fit statistic, which is similar to the $\chi^2$ statistic but better handles small bin probabilities. This applies to all composition data, the survival from BON to LGR data, and the pre-spawn survival data.

```{r calculate-bayesian-pvals, eval = model_info$do_pp_check}
# function to summarize bayesian p-values within a data source
summarize_bp = function(bp) {
  data.frame(
    "N" = apply(bp, 2, function(x) sum(!is.na(x))),
    "median" = apply(bp, 2, median, na.rm = TRUE),
    "q2.5" = apply(bp, 2, function(x) quantile(x, 0.025, na.rm = TRUE)),
    "q97.5" = apply(bp, 2, function(x) quantile(x, 0.975, na.rm = TRUE)),
    "p_lt_0.05" = apply(bp, 2, function(x) sum(x < 0.05 & !is.na(x))/sum(!is.na(x))),
    "p_gt_0.95" = apply(bp, 2, function(x) sum(x > 0.95 & !is.na(x))/sum(!is.na(x)))
  )
}

### CALCULATE BAYESIAN P-VALUES: ABUNDANCE DATA SOURCES ###

# fall trap
new = post_subset(post, "Pa_obs_new_dev", TRUE)
obs = post_subset(post, "Pa_obs_dev", TRUE)
bp = array_format(colMeans(obs > new))
dimnames(bp) = list(all_yrs[1:dim(bp)[1]], "fall-mig", pops)
bp = bp[,"fall-mig",]
Pa_bp = data.frame(
  name = rep("Juveniles", 4), pop = pops,
  origin = rep("NOR", 4), LH_type = rep("Fall Migrants", 4),
  summarize_bp(bp)
)
rownames(Pa_bp) = NULL

# spring trap
new = post_subset(post, "^Mb_obs_new_dev", TRUE)
obs = post_subset(post, "^Mb_obs_dev", TRUE)
bp = array_format(colMeans(obs > new))
dimnames(bp) = list(all_yrs[1:dim(bp)[1]], c("fall-mig", "spring-mig"), "NOR", pops)
bp = bp[,"spring-mig","NOR",]
Mb_bp = data.frame(
  name = rep("Juveniles", 4), pop = pops,
  origin = rep("NOR", 4), LH_type = rep("Spring Migrants", 4),
  summarize_bp(bp)
)
rownames(Mb_bp) = NULL

# adult abundance
new = post_subset(post, "Ra_obs_new_dev", TRUE)
obs = post_subset(post, "Ra_obs_dev", TRUE)
bp = array_format(colMeans(obs > new))
dimnames(bp) = list(all_yrs[1:dim(bp)[1]], pops)
Ra_bp = data.frame(
  name = rep("Adults", 4), pop = pops,
  origin = rep("Combined", 4), LH_type = rep("Combined", 4),
  summarize_bp(bp)
)
rownames(Ra_bp) = NULL

### CALCULATE BAYESIAN P-VALUES: SURVIVAL DATA SOURCES ###

# summer tagging survival
new = post_subset(post, "Lphi_obs_new_Pb_Ma_dev", TRUE)
obs = post_subset(post, "Lphi_obs_Pb_Ma_dev", TRUE)
bp = array_format(colMeans(obs > new))
dimnames(bp) = list(all_yrs[1:dim(bp)[1]], pops)
phi_Pb_Ma_bp = data.frame(
  name = rep("Summer Tagging to LGR", 4), pop = pops,
  origin = rep("NOR", 4), LH_type = rep("Combined", 4),
  summarize_bp(bp)
)
rownames(phi_Pb_Ma_bp) = NULL

# fall & winter trap survival
new = post_subset(post, "Lphi_obs_new_Pa_Ma_dev", TRUE)
obs = post_subset(post, "Lphi_obs_Pa_Ma_dev", TRUE)
bp = array_format(colMeans(obs > new))
dimnames(bp) = list(all_yrs[1:dim(bp)[1]], c("fall-mig", "spring-mig"), pops)
bp = cbind(CAT_fall = bp[,"fall-mig","CAT"], CAT_spring = bp[,"spring-mig","CAT"],
           LOS_fall = bp[,"fall-mig","LOS"], LOS_spring = bp[,"spring-mig","LOS"],
           MIN_fall = bp[,"fall-mig","MIN"], MIN_spring = bp[,"spring-mig","MIN"],
           UGR_fall = bp[,"fall-mig","UGR"], UGR_spring = bp[,"spring-mig","UGR"])
phi_Pa_Ma_bp = data.frame(
  name = rep(c("Fall Trap to LGR", "Winter Tagging"), each = 4), pop = rep(pops, 2),
  origin = rep("NOR", 8),   LH_type = rep(c("Fall Migrants", "Spring Migrants"), each = 4),
  summarize_bp(bp)
)
rownames(phi_Pa_Ma_bp) = NULL

# trib to lgr survival
new = post_subset(post, "Lphi_obs_new_Mb_Ma_dev", TRUE)
obs = post_subset(post, "Lphi_obs_Mb_Ma_dev", TRUE)
bp = array_format(colMeans(obs > new))
dimnames(bp) = list(all_yrs[1:dim(bp)[1]], c("fall-mig", "spring-mig"), origins, pops)
bp = bp[,"spring-mig",,]
bp = cbind(CAT_NOR = bp[,"NOR","CAT"], CAT_HOR = bp[,"HOR","CAT"],
           LOS_NOR = bp[,"NOR","LOS"], LOS_HOR = bp[,"HOR","LOS"],
           MIN_NOR = bp[,"NOR","MIN"], MIN_HOR = bp[,"HOR","MIN"],
           UGR_NOR = bp[,"NOR","UGR"], UGR_HOR = bp[,"HOR","UGR"])
phi_Mb_Ma_bp = data.frame(
  name = rep("Spring Trap/Release to LGR", 8), pop = rep(pops, each = 2),
  origin = rep(origins, 4), LH_type = rep("Spring Migrants", 8),
  summarize_bp(bp)
)
rownames(phi_Mb_Ma_bp) = NULL

# hydropower survival
new = post_subset(post, "Lphi_obs_new_Ma_O0_dev", TRUE)
obs = post_subset(post, "Lphi_obs_Ma_O0_dev", TRUE)
bp = array_format(colMeans(obs > new))
dimnames(bp) = list(all_yrs[1:dim(bp)[1]], origins)
phi_Ma_O0_bp = data.frame(
  name = rep("Hydrosystem (Downstream)", 2), pop = rep("Combined", 2),
  origin = origins, LH_type = rep("Combined", 2),
  summarize_bp(bp)
)
rownames(phi_Ma_O0_bp) = NULL

### CALCULATE BAYESIAN P-VALUES: LENGTH DATA SOURCES ###

# summer length
new = post_subset(post, "L_Pb_obs_new_dev", TRUE)
obs = post_subset(post, "L_Pb_obs_dev", TRUE)
bp = array_format(colMeans(obs > new))
dimnames(bp) = list(all_yrs[1:dim(bp)[1]], pops)
L_Pb_bp = data.frame(
  name = rep("Summer Length", 4), pop = pops,
  origin = rep("NOR", 4), LH_type = rep("Combined", 4),
  summarize_bp(bp)
)
rownames(L_Pb_bp) = NULL

# spring length
new = post_subset(post, "L_Mb_obs_new_dev", TRUE)
obs = post_subset(post, "L_Mb_obs_dev", TRUE)
bp = array_format(colMeans(obs > new))
dimnames(bp) = list(all_yrs[1:dim(bp)[1]], pops)
L_Mb_bp = data.frame(
  name = rep("Spring Length", 4), pop = pops,
  origin = rep("NOR", 4), LH_type = rep("Combined", 4),
  summarize_bp(bp)
)
rownames(L_Mb_bp) = NULL

### CALCULATE BAYESIAN P-VALUES: COMPOSITION DATA SOURCES ###

# weir composition
new = post_subset(post, "x_Ra_new_dev", TRUE)
obs = post_subset(post, "x_Ra_dev", TRUE)
bp = array_format(colMeans(obs > new))
dimnames(bp) = list(all_yrs[1:dim(bp)[1]], pops)
bp[jags_data$nx_Ra == 0 | is.na(jags_data$nx_Ra)] = NA
x_Ra_bp = data.frame(
  name = rep("Weir", 4), pop = pops,
  origin = rep("Combined", 4), LH_type = rep("Combined", 4),
  summarize_bp(bp)
)
rownames(x_Ra_bp) = NULL

# carcass composition
new = post_subset(post, "x_Sa_prime_new_dev", TRUE)
obs = post_subset(post, "x_Sa_prime_dev", TRUE)
bp = array_format(colMeans(obs > new))
dimnames(bp) = list(all_yrs[1:dim(bp)[1]], pops)
bp[jags_data$nx_Sa_prime == 0 | is.na(jags_data$nx_Sa_prime)] = NA
x_Sa_prime_bp = data.frame(
  name = rep("Carcasses", 4), pop = pops,
  origin = rep("Combined", 4), LH_type = rep("Combined", 4),
  summarize_bp(bp)
)
rownames(x_Sa_prime_bp) = NULL

# pre-spawn survival
new = post_subset(post, "x_carcass_spawned_new_dev", TRUE)
obs = post_subset(post, "x_carcass_spawned_dev", TRUE)
bp = array_format(colMeans(obs > new))
dimnames(bp) = list(all_yrs[1:dim(bp)[1]], pops)
x_carcass_spawned_bp = data.frame(
  name = rep("Prespawn", 4), pop = pops,
  origin = rep("Combined", 4), LH_type = rep("Combined", 4),
  summarize_bp(bp)
)
rownames(x_carcass_spawned_bp) = NULL

# movement survival from BON to LGR
new = post_subset(post, "x_LGR_new_dev", TRUE)
obs = post_subset(post, "x_LGR_dev", TRUE)
bp = array_format(colMeans(obs > new))
dimnames(bp) = list(all_yrs[1:dim(bp)[1]], origins)
x_LGR_bp = data.frame(
  name = rep("Hydrosystem (Upstream)", 2), pop = rep("Combined", 2),
  origin = origins, LH_type = rep("Combined", 2),
  summarize_bp(bp)
)
rownames(x_LGR_bp) = NULL

### COMBINE INTO ONE TABLE ###
bp_tab = rbind(
  Pa_bp, Mb_bp, Ra_bp,
  phi_Pb_Ma_bp, phi_Pa_Ma_bp, phi_Mb_Ma_bp,
  phi_Ma_O0_bp, L_Pb_bp, L_Mb_bp, x_Ra_bp, x_Sa_prime_bp, x_carcass_spawned_bp, x_LGR_bp
)

# add a main data category variable
category = rep(NA, nrow(bp_tab))
category = ifelse(bp_tab$name %in% c("Adults", "Juveniles"), "Abundance", category)
category = ifelse(bp_tab$name %in% c("Weir", "Carcasses"), "Composition", category)
category = ifelse(bp_tab$name %in% c("Summer Length", "Spring Length"), "Mean Length", category)
category[is.na(category)] = "Survival"
bp_tab = data.frame(category = category, bp_tab)

# drop the several cases with no data
# MIN HOR survival to LGR and MIN weir data
bp_tab = bp_tab[bp_tab$N > 0,]

# re-order output/misc formatting
bp_tab = bp_tab[order(bp_tab$category, bp_tab$name, bp_tab$pop, bp_tab$origin),]
bp_tab = bp_tab[,c("category", "name", "pop", "LH_type", "origin", "N", "median", "q2.5", "q97.5", "p_lt_0.05", "p_gt_0.95")]
bp_tab$p_lt_0.05 = paste0(round(bp_tab$p_lt_0.05 * 100), "%")
bp_tab$p_gt_0.95 = paste0(round(bp_tab$p_gt_0.95 * 100), "%")
rownames(bp_tab) = NULL
```

```{r bayesian-pvals-table, eval = model_info$do_pp_check}
# a function to color cells depending on the value
assign_color = function(x) {
  red_pal = colorRampPalette(c("white", "red"))
  blue_pal = colorRampPalette(c("blue", "white"))
  red_cols = red_pal(5)
  blue_cols = blue_pal(5)
  cols = c(blue_cols, red_cols)
  bin_names = levels(cut(rbeta(1e6, 1, 1), breaks = seq(0,1,0.1), include.lowest = TRUE))
  names(cols) = bin_names
  bins = cut(x, breaks = seq(0,1,0.1), include.lowest = TRUE)
  cols_use = cols[as.character(bins)]
  alpha(unname(cols_use), 0.5)
}

# produce the kable
bp_tab %>%
  kbl(digits = 2, col.names = c("Class", "Lifestage", "Population", "Migratory Type", "Origin", "Years w/Data", "Median", "2.5%", "97.5%", "<0.05", ">0.95"),
      align = c("lllllcccccc")) %>%
  kable_styling(full_width = FALSE, bootstrap_options = c("condensed")) %>%
  add_header_above(c("Data Type Information" = 5, "P-value Summaries" = 4, "% of Extreme P-values" = 2)) %>%
  column_spec(7, background = assign_color(bp_tab[,7])) %>%
  column_spec(8, background = assign_color(bp_tab[,8])) %>%
  column_spec(9, background = assign_color(bp_tab[,9])) %>%
  collapse_rows(1:5) 
```

```{r dont-calculate-bayesian-pvals, eval = !model_info$do_pp_check, results='asis'}
cat("_Generation of simulated data that can be compared to the observed data in terms of model fit was toggled off when fitting this model, so this output is omitted._")
```

# Fit to Data

In all figures below, the thick red line is the posterior median value each year, the red region is the equal-tailed 95% credible interval, and blue points are "observed" data (estimated from raw data external to the model).

## Abundance Data {.tabset .tabset-pills}

### Fall Parr Abundance

```{r fall-trap-N-fit, fig.width = 6, fig.height = 5}
plot_f = function(j) {
  plot_tseries(post_summ(post, sub_index("^Pa[year,LH_type,pop]$", year = ts_yrs, LH_type = i_fall, pop = j)),
               get_obs_ests_log_normal(log(jags_data$Pa_obs[observable,i_fall,j]), jags_data$sig_Pa_obs[observable,i_fall,j]),
               yrs = all_yrs[ts_yrs],
               main = pops[j])
}

par(mfrow = c(2,2), oma = c(1.5,1.5,0,0))
junk = sapply(1:jags_data$nj, plot_f)
mtext(side = 1, outer = T, line = 0.25, "Brood Year")
mtext(side = 2, outer = T, line = 0.25, "Fall Parr Abundance")
```

### Spring Smolt Abundance

```{r spring-trap-N-fit, fig.width = 6, fig.height = 5}
plot_f = function(j) {
  plot_tseries(post_summ(post, sub_index("^Mb[year,LH_type,origin,pop]$", year = ts_yrs, origin = o_nor, LH_type = i_spring, pop = j)), 
               get_obs_ests_log_normal(log(jags_data$Mb_obs[observable,i_spring,o_nor,j]), jags_data$sig_Mb_obs[observable,i_spring,o_nor,j]),
               main = pops[j],
               yrs = all_yrs[ts_yrs])
}

par(mfrow = c(2,2), oma = c(1.5,1.5,0,0))
junk = sapply(1:jags_data$nj, plot_f)
mtext(side = 1, outer = T, line = 0.25, "Brood Year")
mtext(side = 2, outer = T, line = 0.25, "Spring Smolt Abundance")
```

### Adult Return Abundance

```{r adult-N-fit, fig.width = 6, fig.height = 5}
plot_f = function(j) {
  plot_tseries(post_summ(post, sub_index("^Ra_tot[year,pop]$", year = ts_yrs, pop = j)),
               get_obs_ests_log_normal(log(jags_data$Ra_obs[observable,j]), jags_data$sig_Ra_obs[observable,j]),
               main = pops[j],
               yrs = all_yrs[ts_yrs])
}

par(mfrow = c(2,2), oma = c(1.5,1.5,0,0))
junk = sapply(1:jags_data$nj, plot_f)
mtext(side = 1, outer = T, line = 0.25, "Return Year")
mtext(side = 2, outer = T, line = 0.25, "Adult Return Abundance")
```

## Survival Data {.tabset .tabset-pills}

### Summer Parr $\rightarrow$ LGR

```{r summer-surv-fit, fig.width = 6, fig.height = 5}
plot_f = function(j) {
  plot_tseries(post_summ(post, sub_index("^phi_Pb_Ma[year,pop]", year = ts_yrs, pop = j)),
               get_obs_ests_logit_normal(jags_data$Lphi_obs_Pb_Ma[observable,j], jags_data$sig_Lphi_obs_Pb_Ma[observable,j]),
               main = pops[j],
               yrs = all_yrs[ts_yrs])
}

par(mfrow = c(2,2), oma = c(1.5,1.5,0,0))
junk = sapply(1:jags_data$nj, plot_f)
mtext(side = 1, outer = T, line = 0.25, "Brood Year")
mtext(side = 2, outer = T, line = 0.25, TeX("$Summer\\,Parr \\rightarrow LGR\\,Survival$"))
```

### Fall Parr $\rightarrow$ LGR

```{r fall-surv-fit, fig.width = 6, fig.height = 5}
plot_f = function(j) {
  plot_tseries(post_summ(post, sub_index("^phi_Pa_Ma[year,LH_type,pop]$", year = ts_yrs, LH_type = i_fall, pop = j)),
               get_obs_ests_logit_normal(jags_data$Lphi_obs_Pa_Ma[observable,i_fall,j], jags_data$sig_Lphi_obs_Pa_Ma[observable,i_fall,j]),
               main = pops[j],
               yrs = all_yrs[ts_yrs])
}

par(mfrow = c(2,2), oma = c(1.5,1.5,0,0))
junk = sapply(1:jags_data$nj, plot_f)
mtext(side = 1, outer = T, line = 0.25, "Brood Year")
mtext(side = 2, outer = T, line = 0.25, TeX("$Fall\\,Parr \\rightarrow LGR\\,Survival$"))
```

### Winter Parr $\rightarrow$ LGR

```{r winter-surv-fit, fig.width = 6, fig.height = 5}
plot_f = function(j) {
  plot_tseries(post_summ(post, sub_index("^phi_Pa_Ma[year,LH_type,pop]$", year = ts_yrs, LH_type = i_spring, pop = j)),
               get_obs_ests_logit_normal(jags_data$Lphi_obs_Pa_Ma[observable,i_spring,j], jags_data$sig_Lphi_obs_Pa_Ma[observable,i_spring,j]),
               main = pops[j],
               yrs = all_yrs[ts_yrs])
}

par(mfrow = c(2,2), oma = c(1.5,1.5,0,0))
junk = sapply(1:jags_data$nj, plot_f)
mtext(side = 1, outer = T, line = 0.25, "Brood Year")
mtext(side = 2, outer = T, line = 0.25, TeX("$Winter\\,Parr \\rightarrow LGR\\,Survival$"))
```

### Spring Smolt $\rightarrow$ LGR (NOR)

```{r spring-surv-fit-nor, fig.width = 6, fig.height = 5}
plot_f = function(j) {
  plot_tseries(post_summ(post, sub_index("^phi_Mb_Ma[year,LH_type,origin,pop]$", year = ts_yrs, LH_type = i_spring, origin = o_nor, pop = j)),
               get_obs_ests_logit_normal(jags_data$Lphi_obs_Mb_Ma[observable,i_spring,o_nor,j], jags_data$sig_Lphi_obs_Mb_Ma[observable,i_spring,o_nor,j]),
               main = pops[j], yrs = all_yrs[ts_yrs])
}

par(mfrow = c(2,2), oma = c(1.5,1.5,0,0))
junk = sapply(1:jags_data$nj, plot_f)
mtext(side = 1, outer = T, line = 0.25, "Brood Year")
mtext(side = 2, outer = T, line = 0.25, TeX("$Spring\\,Smolt \\rightarrow LGR\\,Survival\\,(NOR)$"))
```

### Spring Smolt $\rightarrow$ LGR (HOR)

```{r spring-surv-fit-hor, fig.width = 6, fig.height = 5}
plot_f = function(j) {
  plot_tseries(post_summ(post, sub_index("^phi_Mb_Ma[year,LH_type,origin,pop]$", year = ts_yrs, LH_type = i_spring, origin = o_hor, pop = j)),
               get_obs_ests_logit_normal(jags_data$Lphi_obs_Mb_Ma[observable,i_spring,o_hor,j], jags_data$sig_Lphi_obs_Mb_Ma[observable,i_spring,o_hor,j]),
               main = pops[j], yrs = all_yrs[ts_yrs])
}

par(mfrow = c(2,2), oma = c(1.5,1.5,0,0))
junk = sapply(1:jags_data$nj, plot_f)
mtext(side = 1, outer = T, line = 0.25, "Brood Year")
mtext(side = 2, outer = T, line = 0.25, TeX("$Spring\\,Smolt \\rightarrow LGR\\,Survival\\,(HOR)"))
```

### LGR Smolt $\rightarrow O_0$ (NOR)

```{r hydro-nor-surv-fit, fig.width = 6, fig.height = 5}
par(oma = c(1.5,1.5,0,0), mfrow = c(1,1))
plot_tseries(post_summ(post, sub_index("^phi_Ma_O0[year,origin]$", year = ts_yrs, origin = o_nor)),
             get_obs_ests_logit_normal(jags_data$Lphi_obs_Ma_O0[observable,o_nor], jags_data$sig_Lphi_obs_Ma_O0[observable,o_nor]),
             main = TeX("$LGR\\,Smolt \\rightarrow O_0\\,Survival\\,(NOR)"),
             yrs = all_yrs[ts_yrs])
mtext(side = 1, outer = T, line = 0.25, "Brood Year")
mtext(side = 2, outer = T, line = 0.25, "Survival")
```

### LGR Smolt $\rightarrow O_0$ (HOR)

```{r hydro-hor-surv-fit, fig.width = 6, fig.height = 5}
par(oma = c(1.5,1.5,0,0), mfrow = c(1,1))
plot_tseries(post_summ(post, sub_index("^phi_Ma_O0[year,origin]$", year = ts_yrs, origin = o_hor)),
             get_obs_ests_logit_normal(jags_data$Lphi_obs_Ma_O0[observable,o_hor], jags_data$sig_Lphi_obs_Ma_O0[observable,o_hor]),
             main = TeX("$LGR\\,Smolt \\rightarrow O_0\\,Survival\\,(HOR)"),
             yrs = all_yrs[ts_yrs])
mtext(side = 1, outer = T, line = 0.25, "Brood Year")
mtext(side = 2, outer = T, line = 0.25, "Survival")
```

### BON Adults $\rightarrow$ LGR (NOR)

```{r BON-LGR-surv-fit-nor, fig.width = 6, fig.height = 5}
par(oma = c(1.5,1.5,0,0), mfrow = c(1,1))
plot_tseries(post_summ(post, sub_index("^phi_Rb_Ra[year,origin]$", year = ts_yrs, origin = o_nor)),
             get_obs_ests_multinomial(cbind(jags_data$x_LGR[observable,o_nor], jags_data$x_BON[observable,o_nor] - jags_data$x_LGR[observable,o_nor]), 1),
             main = TeX("$BON\\,Adults \\rightarrow LGR\\,Survival\\,(NOR)"),
             yrs = all_yrs[ts_yrs])
mtext(side = 1, outer = T, line = 0.25, "Return Year")
mtext(side = 2, outer = T, line = 0.25, "Survival")
```

### BON Adults $\rightarrow$ LGR (HOR)

```{r BON-LGR-surv-fit-hor, fig.width = 6, fig.height = 5}
par(oma = c(1.5,1.5,0,0), mfrow = c(1,1))
plot_tseries(post_summ(post, sub_index("^phi_Rb_Ra[year,origin]$", year = ts_yrs, origin = o_hor)),
             get_obs_ests_multinomial(cbind(jags_data$x_LGR[observable,o_hor], jags_data$x_BON[observable,o_hor] - jags_data$x_LGR[observable,o_hor]), 1),
             main = TeX("$BON\\,Adults \\rightarrow LGR\\,Survival\\,(HOR)"),
             yrs = all_yrs[ts_yrs])
mtext(side = 1, outer = T, line = 0.25, "Return Year")
mtext(side = 2, outer = T, line = 0.25, "Survival")
```

## Composition Data {.tabset .tabset-pills .tabset-fade}

```{r calculate-aggregated-comps-model}
# extract the full posteriors of the two composition sets
p_Ra_full = post_subset(post, "p_Ra", matrix = TRUE)
p_Sa_prime_full = post_subset(post, "p_Sa", matrix = TRUE)

# primary containers: will store final recalculated output
p_Ra_age = p_Sa_prime_age = p_Ra_origin = p_Sa_prime_origin = NULL

# number of posterior samples
n = post_dim(post, "saved")

# loop through posterior samples, calculate various aggregates of composition by type
for (i in 1:n) {
  
  # format the posterior draw as arrays -- easier to subset
  p_Ra = array_format(p_Ra_full[i,])
  p_Sa_prime = array_format(p_Sa_prime_full[i,])
  
  ## BY AGE, AGGREGATED ACROSS ORIGINS
  
  # containers
  p_Ra_age_tmp = p_Sa_prime_age_tmp = array(NA, dim = c(jags_data$ny, jags_data$nk, jags_data$nj))
  inds_1_age = inds_2_age = inds_3_age = p_Ra_age_tmp
  for (j in 1:jags_data$nj) {
    for (k in 1:jags_data$nk) {
      # calculate aggregate proportions for each age
      p_Ra_age_tmp[,k,j] = rowSums(p_Ra[,ko_age[[k]],j])
      p_Sa_prime_age_tmp[,k,j] = rowSums(p_Sa_prime[,ko_age[[k]],j])
      
      # build the element identifiers - for building names later
      inds_1_age[,k,j] = 1:jags_data$ny
      inds_2_age[,k,j] = k
      inds_3_age[,k,j] = j
    }
  }
  
  # vectorize, add names, and remove NAs
  p_Ra_age_v = as.numeric(p_Ra_age_tmp)
  p_Sa_prime_age_v = as.numeric(p_Sa_prime_age_tmp)
  names(p_Ra_age_v) = paste0("p_Ra_age[", as.numeric(inds_1_age), ",", as.numeric(inds_2_age), ",", as.numeric(inds_3_age), "]")
  names(p_Sa_prime_age_v) = paste0("p_Sa_prime_age[", as.numeric(inds_1_age), ",", as.numeric(inds_2_age), ",", as.numeric(inds_3_age), "]")
  p_Ra_age_v = p_Ra_age_v[!is.na(p_Ra_age_v)]
  p_Sa_prime_age_v = p_Sa_prime_age_v[!is.na(p_Sa_prime_age_v)]
  
  ## BY ORIGIN, AGGREGATED ACROSS AGES
  
  # containers
  p_Ra_origin_tmp = p_Sa_prime_origin_tmp = array(NA, dim = c(jags_data$ny, jags_data$no, jags_data$nj))
  inds_1_origin = inds_2_origin = inds_3_origin = p_Ra_origin_tmp
  for (j in 1:jags_data$nj) {
    for (o in 1:jags_data$no) {
      # calculate aggregate proportions for each origin
      p_Ra_origin_tmp[,o,j] = rowSums(p_Ra[,ko_origin[[o]],j])
      p_Sa_prime_origin_tmp[,o,j] = rowSums(p_Sa_prime[,ko_origin[[o]],j])
      
      # build the element identifiers - for building names later
      inds_1_origin[,o,j] = 1:jags_data$ny
      inds_2_origin[,o,j] = o
      inds_3_origin[,o,j] = j
    }
  }
  
  # vectorize, add names, and remove NAs
  p_Ra_origin_v = as.numeric(p_Ra_origin_tmp)
  p_Sa_prime_origin_v = as.numeric(p_Sa_prime_origin_tmp)
  names(p_Ra_origin_v) = paste0("p_Ra_origin[", as.numeric(inds_1_origin), ",", as.numeric(inds_2_origin), ",", as.numeric(inds_3_origin), "]")
  names(p_Sa_prime_origin_v) = paste0("p_Sa_prime_origin[", as.numeric(inds_1_origin), ",", as.numeric(inds_2_origin), ",", as.numeric(inds_3_origin), "]")
  p_Ra_origin_v = p_Ra_origin_v[!is.na(p_Ra_origin_v)]
  p_Sa_prime_origin_v = p_Sa_prime_origin_v[!is.na(p_Sa_prime_origin_v)]
  
  ## COMBINE NEW CALCULATED QUANTITIES ACROSS POSTERIOR SAMPLES
  
  p_Ra_age = rbind(p_Ra_age, p_Ra_age_v)
  p_Sa_prime_age = rbind(p_Sa_prime_age, p_Sa_prime_age_v)
  p_Ra_origin = rbind(p_Ra_origin, p_Ra_origin_v)
  p_Sa_prime_origin = rbind(p_Sa_prime_origin, p_Sa_prime_origin_v)
  
}

# combine new calculated quantities into a big matrix
q_new = cbind(p_Ra_age, p_Sa_prime_age, p_Ra_origin, p_Sa_prime_origin)

# combine with the rest of the posterior samples
post = post_bind(post, q_new)

```

```{r calculate-aggregated-comps-data}

# these are the observed proportions by age (aggregated across origins) and origin (aggregated across ages)

# containers
x_Ra_age_obs = x_Sa_prime_age_obs = array(NA, dim = c(jags_data$ny_obs, jags_data$nk, jags_data$nj))
x_Ra_origin_obs = x_Sa_prime_origin_obs = array(NA, dim = c(jags_data$ny_obs, jags_data$no, jags_data$nj))

for (j in 1:jags_data$nj) {
  # calculate aggregate proportions for each age
  for (k in 1:jags_data$nk) {
    x_Ra_age_obs[,k,j] = rowSums(jags_data$x_Ra[,ko_age[[k]],j])
    x_Sa_prime_age_obs[,k,j] = rowSums(jags_data$x_Sa_prime[,ko_age[[k]],j])
  }
  
  # calculate aggregate proportions for each origin
  for (o in 1:jags_data$no) {
    x_Ra_origin_obs[,o,j] = rowSums(jags_data$x_Ra[,ko_origin[[o]],j])
    x_Sa_prime_origin_obs[,o,j] = rowSums(jags_data$x_Sa_prime[,ko_origin[[o]],j])
  }
}

dimnames(x_Ra_age_obs)[[1]] = dimnames(x_Ra_origin_obs)[[1]] = dimnames(x_Sa_prime_age_obs)[[1]] = dimnames(x_Sa_prime_origin_obs)[[1]] = dimnames(jags_data$x_Ra)[[1]]

x_Ra_new_obs = list(
  x_Ra_age_obs = x_Ra_age_obs,
  x_Ra_origin_obs = x_Ra_origin_obs
)

x_Sa_prime_new_obs = list(
  x_Sa_prime_age_obs = x_Sa_prime_age_obs,
  x_Sa_prime_origin_obs = x_Sa_prime_origin_obs
)

```

Within a single year, the values across all panels sum to one.

### Weir Sampling {.tabset .tabset-pills}

```{r weir-comp-fit-funcs}

# for multinomial sample size
weir_sample_size = function(j) {
  par(mar = c(3,3,1.5,0.5), tcl = -0.15, mgp = c(2,0.35,0))
  mp = barplot(jags_data$nx_Ra[observable,j], xaxt = "n", col = alpha("skyblue2", 0.5), border = "blue",
               ylim = c(0, max(jags_data$nx_Ra[observable,j], na.rm = TRUE)),
               xlab = "Return Year", ylab = "Adults at Weir Sampled for Composition")
  usr = par("usr")
  at_x = seq(1, length(observable), 4)
  axis(side = 1, at = mp[at_x], labels = substr(names(jags_data$nx_Ra[observable,j]), 3, 4)[at_x])
  segments(usr[1], usr[3], usr[2], usr[3], xpd = TRUE)
}

# for completely disaggregated fits
weir_comp_fit_plot = function(j) {

  par(mfrow = c(2,3), oma = c(1.5,1.5,0,0))#, mar = c(1.5,1.5,1.5,0.5))
  plot_tseries(post_summ(post, sub_index("^p_Ra[year,1,pop]$", pop = j, year = ts_yrs)), get_obs_ests_multinomial(jags_data$x_Ra[observable,,j], 1), main = TeX("$Age\\,3\\,(NOR)$"), yrs = all_yrs[ts_yrs])
  plot_tseries(post_summ(post, sub_index("^p_Ra[year,2,pop]$", pop = j, year = ts_yrs)), get_obs_ests_multinomial(jags_data$x_Ra[observable,,j], 2), main = TeX("$Age\\,4\\,(NOR)$"), yrs = all_yrs[ts_yrs])
  plot_tseries(post_summ(post, sub_index("^p_Ra[year,3,pop]$", pop = j, year = ts_yrs)), get_obs_ests_multinomial(jags_data$x_Ra[observable,,j], 3), main = TeX("$Age\\,5\\,(NOR)$"), yrs = all_yrs[ts_yrs])
  plot_tseries(post_summ(post, sub_index("^p_Ra[year,4,pop]$", pop = j, year = ts_yrs)), get_obs_ests_multinomial(jags_data$x_Ra[observable,,j], 4), main = TeX("$Age\\,3\\,(HOR)$"), yrs = all_yrs[ts_yrs])
  plot_tseries(post_summ(post, sub_index("^p_Ra[year,5,pop]$", pop = j, year = ts_yrs)), get_obs_ests_multinomial(jags_data$x_Ra[observable,,j], 5), main = TeX("$Age\\,4\\,(HOR)$"), yrs = all_yrs[ts_yrs])
  plot_tseries(post_summ(post, sub_index("^p_Ra[year,6,pop]$", pop = j, year = ts_yrs)), get_obs_ests_multinomial(jags_data$x_Ra[observable,,j], 6), main = TeX("$Age\\,5\\,(HOR)$"), yrs = all_yrs[ts_yrs])
  
  mtext(side = 1, outer = T, line = 0.25, "Return Year")
  mtext(side = 2, outer = T, line = 0.25, "Proportion of Return")
}

# for fits to each age, aggregated across origins
weir_comp_fit_plot_age = function(j) {
  par(mfcol = c(1,3), oma = c(1.5,1.5,0,0))
  plot_tseries(post_summ(post, sub_index("^p_Ra_age[year,1,pop]$", pop = j, year = ts_yrs)), get_obs_ests_multinomial(x_Ra_new_obs$x_Ra_age_obs[observable,,j], 1), main = TeX("$Age\\,3$"), ylim = c(0,1), yrs = all_yrs[ts_yrs])
  plot_tseries(post_summ(post, sub_index("^p_Ra_age[year,2,pop]$", pop = j, year = ts_yrs)), get_obs_ests_multinomial(x_Ra_new_obs$x_Ra_age_obs[observable,,j], 2), main = TeX("$Age\\,4$"), ylim = c(0,1), yrs = all_yrs[ts_yrs])
  plot_tseries(post_summ(post, sub_index("^p_Ra_age[year,3,pop]$", pop = j, year = ts_yrs)), get_obs_ests_multinomial(x_Ra_new_obs$x_Ra_age_obs[observable,,j], 3), main = TeX("$Age\\,5$"), ylim = c(0,1), yrs = all_yrs[ts_yrs])
  mtext(side = 1, outer = T, line = 0.25, "Return Year")
  mtext(side = 2, outer = T, line = 0.25, "Proportion of Return")
}

# for fits to each origin, aggregated across ages
weir_comp_fit_plot_origin = function(j) {
  par(mfcol = c(1,2), oma = c(1.5,1.5,0,0))
  
  plot_tseries(post_summ(post, sub_index("^p_Ra_origin[year,1,pop]$", pop = j, year = ts_yrs)), get_obs_ests_multinomial(x_Ra_new_obs$x_Ra_origin_obs[observable,,j], 1), main = TeX("$NOR$"), ylim = c(0,1), yrs = all_yrs[ts_yrs])
  plot_tseries(post_summ(post, sub_index("^p_Ra_origin[year,2,pop]$", pop = j, year = ts_yrs)), get_obs_ests_multinomial(x_Ra_new_obs$x_Ra_origin_obs[observable,,j], 2), main = TeX("$HOR$"), ylim = c(0,1), yrs = all_yrs[ts_yrs])
  mtext(side = 1, outer = T, line = 0.25, "Return Year")
  mtext(side = 2, outer = T, line = 0.25, "Proportion of Return")
}
```

#### By Age/Origin {.tabset .tabset-pills}

This is the resolution the model fits to: each year slice is treated as a 6-element multinomial vector.

##### CAT

```{r cat-weir-comp-fit, fig.width = 8, fig.height = 5}
weir_comp_fit_plot(j_cat)
```

##### LOS

```{r los-weir-comp-fit, fig.width = 8, fig.height = 5}
weir_comp_fit_plot(j_los)
```

##### MIN

```{r min-weir-comp-fit, fig.width = 8, fig.height = 5}
weir_comp_fit_plot(j_min)
```

##### UGR

```{r ugr-weir-comp-fit, fig.width = 8, fig.height = 5}
weir_comp_fit_plot(j_ugr)
```

#### By Age {.tabset .tabset-pills}

These figures show the agreement of the model with the weir composition data by age, aggregated across origins.

##### CAT

```{r cat-weir-comp-fit-age, fig.width = 8, fig.height = 3.5}
weir_comp_fit_plot_age(j_cat)
```

##### LOS

```{r los-weir-comp-fit-age, fig.width = 8, fig.height = 3.5}
weir_comp_fit_plot_age(j_los)
```

##### MIN

```{r min-weir-comp-fit-age, fig.width = 8, fig.height = 3.5}
weir_comp_fit_plot_age(j_min)
```

##### UGR

```{r ugr-weir-comp-fit-age, fig.width = 8, fig.height = 3.5}
weir_comp_fit_plot_age(j_ugr)
```

#### By Origin {.tabset .tabset-pills}

These figures show the agreement of the model with the weir composition data by origin, aggregated across ages.

##### CAT

```{r cat-weir-comp-fit-origin, fig.width = 8, fig.height = 4}
weir_comp_fit_plot_origin(j_cat)
```

##### LOS

```{r los-weir-comp-fit-origin, fig.width = 8, fig.height = 4}
weir_comp_fit_plot_origin(j_los)
```

##### MIN

```{r min-weir-comp-fit-origin, fig.width = 8, fig.height = 4}
weir_comp_fit_plot_origin(j_min)
```

##### UGR

```{r ugr-weir-comp-fit-origin, fig.width = 8, fig.height = 4}
weir_comp_fit_plot_origin(j_ugr)
```

#### Total Sample Size {.tabset .tabset-pills}

These figures show the number of samples gathered for age/origin composition information during carcass surveys. The model will fit more closely to years with more samples.

##### CAT

```{r cat-weir-ss, fig.width = 6, fig.height = 4}
weir_sample_size(j_cat)
```

##### LOS

```{r los-weir-ss, fig.width = 6, fig.height = 4}
weir_sample_size(j_los)
```

##### MIN

```{r min-weir-ss, fig.width = 6, fig.height = 4}
weir_sample_size(j_min)
```

##### UGR

```{r ugr-weir-ss, fig.width = 6, fig.height = 4}
weir_sample_size(j_ugr)
```

### Carcass Sampling {.tabset .tabset-pills}

```{r carc-comp-fit-funcs}

# for multinomial sample size
carc_sample_size = function(j) {
  par(mar = c(3,3,1.5,0.5), tcl = -0.15, mgp = c(2,0.35,0))
  mp = barplot(jags_data$nx_Sa_prime[observable,j], xaxt = "n", col = alpha("skyblue2", 0.5), border = "blue",
               ylim = c(0, max(jags_data$nx_Sa_prime[observable,j], na.rm = TRUE)),
               xlab = "Return Year", ylab = "Carcasses Sampled for Composition")
  usr = par("usr")
  at_x = seq(1, length(observable), 4)
  axis(side = 1, at = mp[at_x], labels = substr(names(jags_data$nx_Sa_prime[observable,j]), 3, 4)[at_x])
  segments(usr[1], usr[3], usr[2], usr[3], xpd = TRUE)
}

# for completely disaggregated fits
carc_comp_fit_plot = function(j) {
  
  par(mfrow = c(2,3), oma = c(1.5,1.5,0,0))#, mar = c(1.5,1.5,1.5,0.5))
  plot_tseries(post_summ(post, sub_index("^p_Sa_prime[year,1,pop]$", pop = j, year = ts_yrs)), get_obs_ests_multinomial(jags_data$x_Sa_prime[observable,,j], 1), main = TeX("$Age\\,3\\,(NOR)$"), yrs = all_yrs[ts_yrs])
  plot_tseries(post_summ(post, sub_index("^p_Sa_prime[year,2,pop]$", pop = j, year = ts_yrs)), get_obs_ests_multinomial(jags_data$x_Sa_prime[observable,,j], 2), main = TeX("$Age\\,4\\,(NOR)$"), yrs = all_yrs[ts_yrs])
  plot_tseries(post_summ(post, sub_index("^p_Sa_prime[year,3,pop]$", pop = j, year = ts_yrs)), get_obs_ests_multinomial(jags_data$x_Sa_prime[observable,,j], 3), main = TeX("$Age\\,5\\,(NOR)$"), yrs = all_yrs[ts_yrs])
  plot_tseries(post_summ(post, sub_index("^p_Sa_prime[year,4,pop]$", pop = j, year = ts_yrs)), get_obs_ests_multinomial(jags_data$x_Sa_prime[observable,,j], 4), main = TeX("$Age\\,3\\,(HOR)$"), yrs = all_yrs[ts_yrs])
  plot_tseries(post_summ(post, sub_index("^p_Sa_prime[year,5,pop]$", pop = j, year = ts_yrs)), get_obs_ests_multinomial(jags_data$x_Sa_prime[observable,,j], 5), main = TeX("$Age\\,4\\,(HOR)$"), yrs = all_yrs[ts_yrs])
  plot_tseries(post_summ(post, sub_index("^p_Sa_prime[year,6,pop]$", pop = j, year = ts_yrs)), get_obs_ests_multinomial(jags_data$x_Sa_prime[observable,,j], 6), main = TeX("$Age\\,5\\,(HOR)$"), yrs = all_yrs[ts_yrs])
  mtext(side = 1, outer = T, line = 0.25, "Return Year")
  mtext(side = 2, outer = T, line = 0.25, "Proportion of Carcasses")
}

# for fits to each age, aggregated across origins
carc_comp_fit_plot_age = function(j) {
  par(mfcol = c(1,3), oma = c(1.5,1.5,0,0))
  plot_tseries(post_summ(post, sub_index("^p_Sa_prime_age[year,1,pop]$", pop = j, year = ts_yrs)), get_obs_ests_multinomial(x_Sa_prime_new_obs$x_Sa_prime_age_obs[observable,,j], 1), main = TeX("$Age\\,3$"), yrs = all_yrs[ts_yrs])
  plot_tseries(post_summ(post, sub_index("^p_Sa_prime_age[year,2,pop]$", pop = j, year = ts_yrs)), get_obs_ests_multinomial(x_Sa_prime_new_obs$x_Sa_prime_age_obs[observable,,j], 2), main = TeX("$Age\\,4$"), yrs = all_yrs[ts_yrs])
  plot_tseries(post_summ(post, sub_index("^p_Sa_prime_age[year,3,pop]$", pop = j, year = ts_yrs)), get_obs_ests_multinomial(x_Sa_prime_new_obs$x_Sa_prime_age_obs[observable,,j], 3), main = TeX("$Age\\,5$"), yrs = all_yrs[ts_yrs])
  mtext(side = 1, outer = T, line = 0.25, "Return Year")
  mtext(side = 2, outer = T, line = 0.25, "Proportion of Return")
}

# for fits to each origin, aggregated across ages
carc_comp_fit_plot_origin = function(j) {
  par(mfcol = c(1,2), oma = c(1.5,1.5,0,0))
  plot_tseries(post_summ(post, sub_index("^p_Sa_prime_origin[year,1,pop]$", pop = j, year = ts_yrs)), get_obs_ests_multinomial(x_Sa_prime_new_obs$x_Sa_prime_origin_obs[observable,,j], 1), main = TeX("$NOR$"), yrs = all_yrs[ts_yrs])
  plot_tseries(post_summ(post, sub_index("^p_Sa_prime_origin[year,2,pop]$", pop = j, year = ts_yrs)), get_obs_ests_multinomial(x_Sa_prime_new_obs$x_Sa_prime_origin_obs[observable,,j], 2), main = TeX("$HOR$"), yrs = all_yrs[ts_yrs])
  mtext(side = 1, outer = T, line = 0.25, "Return Year")
  mtext(side = 2, outer = T, line = 0.25, "Proportion of Return")
}

```

#### By Age/Origin {.tabset .tabset-pills}

This is the resolution the model fits to: each year slice is treated as a 12-element multinomial vector.

##### CAT

```{r cat-carc-comp-fit, fig.width = 8, fig.height = 5}
carc_comp_fit_plot(j_cat)
```

##### LOS

```{r los-carc-comp-fit, fig.width = 8, fig.height = 5}
carc_comp_fit_plot(j_los)
```

##### MIN

```{r min-carc-comp-fit, fig.width = 8, fig.height = 5}
carc_comp_fit_plot(j_min)
```

##### UGR

```{r ugr-carc-comp-fit, fig.width = 8, fig.height = 5}
carc_comp_fit_plot(j_ugr)
```

#### By Age {.tabset .tabset-pills}

These figures show the agreement of the model with the carcass composition data by age, aggregated across origins.

##### CAT

```{r cat-carc-comp-fit-age, fig.width = 8, fig.height = 3.5}
carc_comp_fit_plot_age(j_cat)
```

##### LOS

```{r los-carc-comp-fit-age, fig.width = 8, fig.height = 3.5}
carc_comp_fit_plot_age(j_los)
```

##### MIN

```{r min-carc-comp-fit-age, fig.width = 8, fig.height = 3.5}
carc_comp_fit_plot_age(j_min)
```

##### UGR

```{r ugr-carc-comp-fit-age, fig.width = 8, fig.height = 3.5}
carc_comp_fit_plot_age(j_ugr)
```

#### By Origin {.tabset .tabset-pills}

These figures show the agreement of the model with the carcass composition data by origin, aggregated across ages.

##### CAT

```{r cat-carc-comp-fit-origin, fig.width = 8, fig.height = 4}
carc_comp_fit_plot_origin(j_cat)
```

##### LOS

```{r los-carc-comp-fit-origin, fig.width = 8, fig.height = 4}
carc_comp_fit_plot_origin(j_los)
```

##### MIN

```{r min-carc-comp-fit-origin, fig.width = 8, fig.height = 4}
carc_comp_fit_plot_origin(j_min)
```

##### UGR

```{r ugr-carc-comp-fit-origin, fig.width = 8, fig.height = 4}
carc_comp_fit_plot_origin(j_ugr)
```

#### Total Sample Size {.tabset .tabset-pills}

These figures show the number of samples gathered for age/origin composition information during carcass surveys. The model will fit more closely to years with more samples.

##### CAT

```{r cat-carc-ss, fig.width = 6, fig.height = 4}
carc_sample_size(j_cat)
```

##### LOS

```{r los-carc-ss, fig.width = 6, fig.height = 4}
carc_sample_size(j_los)
```

##### MIN

```{r min-carc-ss, fig.width = 6, fig.height = 4}
carc_sample_size(j_min)
```

##### UGR

```{r ugr-carc-ss, fig.width = 6, fig.height = 4}
carc_sample_size(j_ugr)
```

## Spawn Status Data

```{r spawn-status-fits, fig.width = 8, fig.height = 5}
par(oma = c(2,2,0,0))
layout(matrix(1:(jags_data$nj * 2), 2, jags_data$nj), heights = c(1, 0.65))

plot_f = function(j) {
  par(yaxs = "r")
  plot_tseries(post_summ(post, sub_index("^phi_Sb_Sa[year,pop]", pop = j, year = ts_yrs)),
               get_obs_ests_multinomial(cbind(jags_data$x_carcass_spawned[,j], jags_data$x_carcass_total[,j] - jags_data$x_carcass_spawned[,j])[observable,], 1),
               main = pops[j], ylim = c(0,1), yrs = all_yrs[ts_yrs])
  par(mar = c(1.5,1.5,2,0.5), yaxs = "i")
  
  if (j == 1) mtext(side = 2, "Survival Probability", line = 2)
  mp = barplot(jags_data$x_carcass_total[observable,j], xaxt = "n", ylim = c(0, max(jags_data$x_carcass_total, na.rm = T)) + c(0, 5))
  at_x = seq(1, length(observable), 4)
  axis(side = 1, at = mp[at_x], labels = substr(names(jags_data$carcs_sampled[observable,j]), 3, 4)[at_x])
  box()
  
  if (j == 1) mtext(side = 2, "Carcasses Sampled", line = 2)
}

junk = sapply(1:jags_data$nj, plot_f)
```

## Length Data {.tabset .tabset-pills}

### Mean Length at Summer Tagging

```{r summer-length-fit, fig.width = 6, fig.height = 5}
plot_f = function(j) {
  plot_tseries(post_summ(post, sub_index("^L_Pb[year,pop]$", year = ts_yrs, pop = j)),
               get_obs_ests_log_normal(log(jags_data$L_Pb_obs[observable,j]), jags_data$sig_L_Pb_obs[observable,j]),
               yrs = all_yrs[ts_yrs],
               main = pops[j])
}

par(mfrow = c(2,2), oma = c(1.5,1.5,0,0))
junk = sapply(1:jags_data$nj, plot_f)
mtext(side = 1, outer = T, line = 0.25, "Brood Year")
mtext(side = 2, outer = T, line = 0.25, "Mean Length at Summer Tagging (mm)")
```

### Mean Length at Spring Tagging

```{r spring-length-fit, fig.width = 6, fig.height = 5}
plot_f = function(j) {
  plot_tseries(post_summ(post, sub_index("^L_Mb[year,pop]$", year = ts_yrs, pop = j)),
               get_obs_ests_log_normal(log(jags_data$L_Mb_obs[observable,j]), jags_data$sig_L_Mb_obs[observable,j]),
               yrs = all_yrs[ts_yrs],
               main = pops[j])
}

par(mfrow = c(2,2), oma = c(1.5,1.5,0,0))
junk = sapply(1:jags_data$nj, plot_f)
mtext(side = 1, outer = T, line = 0.25, "Brood Year")
mtext(side = 2, outer = T, line = 0.25, "Mean Length at Spring Tagging (mm)")
```

# Spawner-to-Parr Relationship {.tabset .tabset-pills}

## Beverton-Holt

All red components are posterior summaries (medians and 95% credible intervals). The black curve is from an `nls()` fit on reconstructed parr and roughly approximated total egg production -- the grey region is the confidence interval around this fit.

```{r eggs-to-parr, fig.width = 6, fig.height = 5}
plot_f = function(j) {
  # extract posterior samples of the BH productivity and capacity parameters
  bh_params = post_subset(post, sub_index(c("alpha[pop]", "^beta[pop]$"), pop = j), matrix = TRUE)
  
  # extract posterior summaries of total spawners by brood year
  Sa_tot = post_summ(post, sub_index("^Sa_tot[year,pop]", pop = j, year = ts_yrs))
  
  # extract posterior summaries of total egg production by brood year
  E = post_summ(post, sub_index("^E[year,pop]", pop = j, year = ts_yrs))
  
  # extract posterior summaries of total parr recruits by brood year
  Pb = post_summ(post, sub_index("^Pb[year,pop]", pop = j, year = ts_yrs))
  
  # predict parr recruits along a sequence of spawner abundances
  Sa_pred = seq(0, max(Sa_tot[5,]), length = 30)
  E_pred = seq(0, max(E[5,]), length = 30)
  
  Pb_pred = t(sapply(1:post_dim(post, "saved"), function(i) BH(E_pred, bh_params[i,1], bh_params[i,2])))
  colnames(Pb_pred) = paste0("Pb_pred[", 1:length(Sa_pred), "]")
  Pb_pred = post_convert(cbind(postpack:::id_mat(post), Pb_pred))
  Pb_pred = post_summ(Pb_pred, "Pb_pred")
  
  # graphical parameters
  par(mar = c(1.5,1.5,1.5,0.5), tcl = -0.15, mgp = c(2,0.35,0))
  
  # empty plot
  plot(1, 1, type = "n", xlim = range(0, E[5,]), ylim = range(0, Pb[5,], Pb_pred[5,]),
       xlab = "", ylab = "", xaxt = "n", yaxt = "n", main = pops[j])
  
  x_ticks = axisTicks(par("usr")[1:2], log = FALSE)
  y_ticks = axisTicks(par("usr")[3:4], log = FALSE)
  axis(side = 1, at = x_ticks, labels = x_ticks/1e6)
  axis(side = 2, at = y_ticks, labels = y_ticks/1e3)
  
  # draw fitted relationship: Bayesian
  polygon(c(E_pred, rev(E_pred)), c(Pb_pred[4,], rev(Pb_pred[5,])), col = alpha("salmon", 0.5), border = NA)
  lines(Pb_pred[4,] ~ E_pred, col = "red", lty = 2)
  lines(Pb_pred[5,] ~ E_pred, col = "red", lty = 2)
  lines(Pb_pred[3,] ~ E_pred, col = "red", lwd = 2)
  
  # draw state pairs + uncertainty
  segments(E[4,], Pb[3,], E[5,], Pb[3,], col = alpha("red", 0.5))
  segments(E[3,], Pb[4,], E[3,], Pb[5,], col = alpha("red", 0.5))
  points(Pb[3,] ~ E[3,], pch = 21, col = "red", bg = alpha("salmon", 0.5), cex = 1.2)
}

par(mfrow = c(2,2), oma = c(1.5,1.5,0,0))
junk = sapply(1:jags_data$nj, plot_f)
mtext(side = 1, outer = T, line = 0.25, "Total Egg Production (Millions)")
mtext(side = 2, outer = T, line = 0.25, "Parr Recruits (Thousands)")
```

## Total Eggs vs. Total Spawners

This figure illustrates that total spawners is a reasonable index of total egg production, according to the assumptions of our model. The three lines illustrate the relationship if each spawner (regardless of age or sex) had a fixed number of eggs.

```{r eggs-vs-spawners, fig.width = 6, fig.height = 5}
plot_f = function(j) {
  # extract posterior summaries of total spawners by brood year
  Sa_tot = post_summ(post, sub_index("^Sa_tot[year,pop]", pop = j, year = ts_yrs))
  
  # extract posterior summaries of total egg production by brood year
  E = post_summ(post, sub_index("^E[year,pop]", pop = j, year = ts_yrs))

  # graphical parameters
  par(mar = c(1.5,1.5,1.5,0.5), tcl = -0.15, mgp = c(2,0.35,0))
  
  # empty plot
  plot(E["mean",] ~ Sa_tot["mean",],
       ylim = c(0, max(E["97.5%",])),
       xlim = c(0, max(Sa_tot["97.5%",])), type = "n",
       ylab = "", xlab = "", las = 1, yaxt = "n")
  
  # yaxis ticks
  y_ticks = axisTicks(par("usr")[3:4], log = F)
  axis(side = 2, at = y_ticks, labels = y_ticks/1e6, las = 2)
  
  segments(Sa_tot["2.5%",], E["mean",], Sa_tot["97.5%",], E["mean",], col = alpha("red", 0.5))
  segments(Sa_tot["mean",], E["2.5%",], Sa_tot["mean",], E["97.5%",], col = alpha("red", 0.5))
  points(E["mean",] ~ Sa_tot["mean",], pch = 21, col = "red", bg = alpha("salmon", 0.5), cex = 1.2)
  abline(c(0, 1000), lty = 1)
  abline(c(0, 1800), lty = 2)
  abline(c(0, 3600), lty = 3)

  if (j == 1) {
    legend("bottomright", title = "If Each Spawner Had:",
           legend = c("1000 Eggs", "1800 Eggs", "3600 Eggs"),
           lty = c(1,2,3), bty = "n", cex = 0.75)
  }
}

par(mfrow = c(2,2), oma = c(1.5,1.5,0,0))
junk = sapply(1:jags_data$nj, plot_f)
mtext(side = 1, outer = T, line = 0.25, "Total Spawners")
mtext(side = 2, outer = T, line = 0.25, "Total Egg Production (Millions)")
```

## Parr per Egg

This figure shows the density dependence built in to the Beverton-Holt recruitment function: with increasing egg density, survival per egg decreases. The horizontal line/region shows the theoretical maximum ($\alpha_j$) in the absence of density dependence.

```{r parr-per-egg-v-eggs, fig.width = 6, fig.height = 5}
plot_f = function(j) {
  # extract posterior summaries of total egg production by brood year
  E = post_summ(post, sub_index("^E[year,pop]", pop = j, year = ts_yrs))
  
  # conversion rates
  Pb_per_E = post_summ(post, sub_index("^Pb_per_E[year,pop]", pop = j, year = ts_yrs))
  
  # max survival
  alpha = post_summ(post, sub_index("^alpha[pop]", pop = j))
  
  # graphical parameters
  par(mar = c(1.5,1.5,1.5,0.5), tcl = -0.15, mgp = c(2,0.35,0))
  
  # empty plot
  plot(Pb_per_E["mean",] ~ E["mean",],
       ylim = c(0, 1),
       xlim = c(0, max(E["97.5%",])), type = "n",
       ylab = "", xlab = "", las = 1, xaxt = "n", main = pops[j])
  
  # x-axis
  x_ticks = axisTicks(par("usr")[1:2], log = F)
  axis(side = 1, at = x_ticks, labels = x_ticks/1e6)
  
  segments(E["2.5%",], Pb_per_E["mean",], E["97.5%",], Pb_per_E["mean",], col = alpha("red", 0.5))
  segments(E["mean",], Pb_per_E["2.5%",], E["mean",], Pb_per_E["97.5%",], col = alpha("red", 0.5))
  points(Pb_per_E["mean",] ~ E["mean",], pch = 21, col = "red", bg = alpha("salmon", 0.5), cex = 1.2)
  
  rect(par("usr")[1], alpha["2.5%",], par("usr")[2], alpha["97.5%",], border = alpha("red", 0.5), col = alpha("salmon", 0.5))
  abline(h = alpha["mean",], lwd = 2, col = "red")
  box()
}
  
par(mfrow = c(2,2), oma = c(1.5,1.5,0,0))
junk = sapply(1:jags_data$nj, plot_f)
mtext(side = 1, outer = T, line = 0.25, "Total Egg Production (Millions)")
mtext(side = 2, outer = T, line = 0.25, "Parr per Egg")
```

## Parr per Spawner

This figure is identical to above, but shows parr production per spawner instead of per egg.

```{r parr-per-spawner-v-spawners, fig.width = 6, fig.height = 5}
plot_f = function(j) {
  # extract posterior summaries of total spawners by brood year
  Sa_tot = post_summ(post, sub_index("^Sa_tot[year,pop]", pop = j, year = ts_yrs))
  
  # conversion rates
  Pb_per_Sa_tot = post_summ(post, sub_index("^Pb_per_Sa_tot[year,pop]", pop = j, year = ts_yrs))
  
  # graphical parameters
  par(mar = c(1.5,1.5,1.5,0.5), tcl = -0.15, mgp = c(2,0.35,0))
  
  # empty plot
  plot(Pb_per_Sa_tot["mean",] ~ Sa_tot["mean",],
       ylim = c(0, max(Pb_per_Sa_tot["97.5%",])),
       xlim = c(0, max(Sa_tot["97.5%",])), type = "n",
       ylab = "", xlab = "", las = 1)
  
  segments(Sa_tot["2.5%",], Pb_per_Sa_tot["mean",], Sa_tot["97.5%",], Pb_per_Sa_tot["mean",], col = alpha("red", 0.5))
  segments(Sa_tot["mean",], Pb_per_Sa_tot["2.5%",], Sa_tot["mean",], Pb_per_Sa_tot["97.5%",], col = alpha("red", 0.5))
  points(Pb_per_Sa_tot["mean",] ~ Sa_tot["mean",], pch = 21, col = "red", bg = alpha("salmon", 0.5), cex = 1.2)
}

par(mfrow = c(2,2), oma = c(1.5,1.5,0,0))
junk = sapply(1:jags_data$nj, plot_f)
mtext(side = 1, outer = T, line = 0.25, "Total Spawners")
mtext(side = 2, outer = T, line = 0.25, "Parr per Spawner")
```

# Parr Capacity vs. Habitat Relationship {.tabset .tabset-pills}

## Scatterplot

Error bars represent the central 80% of the posterior. The many grey lines are individual posterior draws.

```{r beta-v-habitat-relationship, fig.width = 5, fig.height = 5}
# extract posterior summaries of the capacity parameters
beta_ests = post_summ(post, "^beta[", probs = c(0.1, 0.5, 0.9))

# extract posterior samples of the slope parameter
beta_per = post_subset(post, "lambda", TRUE)

# create a sequence of WUL values to predict capacity at
wul_seq = seq(0, max(jags_data$wul) * 1.1, length = 30)

# obtain the regression line for each posterior sample
pred_beta = t(sapply(beta_per, function(slope) wul_seq * slope))

# select a subset of posterior samples at random to draw
i = sample(1:post_dim(post, "saved"), 100, replace = FALSE)

# empty plot with correct labeling/dimensions
par(mar = c(3,3,1,1), mgp = c(2,0.35,0), tcl = -0.15)
plot(1,1, type = "n", xlim = range(wul_seq),
     ylim = c(0, max(beta_ests["90%",], beta_ests["90%",], pred_beta[i,])),
     xlab = "Weighted Usable Length (km)",
     ylab = "Parr Capacity (000s)", yaxt = "n")
at_y = axisTicks(par("usr")[3:4], log = FALSE)
axis(side = 2, at = at_y, labels = at_y/1000)

# draw the random regression lines
junk = sapply(i, function(k) lines(pred_beta[k,] ~ wul_seq, col = alpha("grey25", 0.15)))

# draw the posterior mean regression line
lines(apply(pred_beta, 2, mean) ~ wul_seq, lwd = 3, lty = 2)

# draw the population-specific capacity estimates w/error bars and labels
points(beta_ests["mean",] ~ jags_data$wul, cex = 1.5, pch = 16)
segments(jags_data$wul, beta_ests["10%",], jags_data$wul, beta_ests["90%",])
text(x = jags_data$wul, y = beta_ests["mean",], labels = c("CAT", "LOS", "MIN", "UGR"), pos = c(2,4,4,4), font = 2)
```

## Slope Parameter

```{r beta-v-habitat-slope}
# extract posterior summary of slope
est = post_summ(post, "^lambda$")
colnames(est) = "slope"

# print a table 
kable(t(est), digits = 0, format.args = list(big.mark = ",")) %>%
  kable_styling(full_width = FALSE, bootstrap_options = c("condensed", "striped"))
```

# Migratory Strategy Apportionment

```{r pi-plots, fig.width = 6, fig.height = 5}
plot_f = function(j) {
  plot_tseries(post_summ(post, sub_index("^pi[year,LH_type,pop]$", year = ts_yrs, LH_type = i_fall, pop = j)),
               yrs = all_yrs[ts_yrs],
               main = pops[j])
}

par(mfrow = c(2,2), oma = c(1.5,1.5,0,0))
junk = sapply(1:jags_data$nj, plot_f)
mtext(side = 1, outer = T, line = 0.25, "Brood Year")
mtext(side = 2, outer = T, line = 0.25, "Proportion of Parr with Fall Migration Strategy")
```

# Length Relationships {.tabset .tabset-pills}

## Summer Tagging

```{r}
plot_f = function(j) {

  # obtain posterior samples of total egg abundance scaled to WUL
  E = post_subset(post, sub_index("^E[year,pop]", pop = j, year = ts_yrs), matrix = TRUE)
  E_scaled = (E/10000)/jags_data$wul[j]
  colnames(E_scaled) = gsub("E", "E_scaled", x = colnames(E_scaled))
  post_E = post_convert(cbind(postpack:::id_mat(post), E_scaled))
  
  # summarize scaled egg abundance
  E_scaled_mean = post_summ(post_E, "")["mean",]
  E_scaled_lwr = post_summ(post_E, "")["2.5%",]
  E_scaled_upr = post_summ(post_E, "")["97.5%",]
  
  # create a vector of scaled egg abundances to calculate at
  E_scaled_seq = seq(min(E_scaled_lwr), max(E_scaled_upr), length = 30)

  # extract posteriors of coefficients
  omega0 = post_subset(post, sub_index("omega0[pop]", pop = j), matrix = TRUE)
  omega1 = post_subset(post, sub_index("omega1[pop]", pop = j), matrix = TRUE)
  
  # extract posterior summaries of summer length outcomes
  L_Pb_mean = post_summ(post, sub_index("^L_Pb[year,pop]", year = ts_yrs, pop = j))["mean",]
  L_Pb_lwr = post_summ(post, sub_index("^L_Pb[year,pop]", year = ts_yrs, pop = j))["2.5%",]
  L_Pb_upr = post_summ(post, sub_index("^L_Pb[year,pop]", year = ts_yrs, pop = j))["97.5%",]
  
  # function to create predicted survival curves for one posterior sample
  pred_fn = function(i) {
    pred_L_Pb = exp(omega0[i] + omega1[i] * E_scaled_seq)
    names(pred_L_Pb) = paste0("pred_L_Pb[", 1:30, "1]")
    pred_L_Pb
  }
  
  # calculate predicted survivals and add to posterior samples
  pred_L_Pb = t(sapply(1:post_dim(post, "saved"), pred_fn))
  post_pred_L_Pb = post_convert(cbind(postpack:::id_mat(post), pred_L_Pb))
  
  # extract summarize predicted length
  pred_L_Pb_mean = post_summ(post_pred_L_Pb, "")["mean",]
  pred_L_Pb_lwr = post_summ(post_pred_L_Pb, "")["2.5%",]
  pred_L_Pb_upr = post_summ(post_pred_L_Pb, "")["97.5%",]
  
  # make a blank plot with the correct dimensions
  par(mgp = c(2,0.35, 0), tcl = -0.15, mar = c(1,1,2,1))
  
  plot(1,1, type = "n", 
       ylim = range(pred_L_Pb_lwr, pred_L_Pb_upr, L_Pb_lwr, L_Pb_upr, na.rm = T),
       xlim = range(0, E_scaled_seq), 
       main = pops[j]
  )
    
  # expected relationship
  polygon(c(E_scaled_seq, rev(E_scaled_seq)), c(pred_L_Pb_lwr, rev(pred_L_Pb_upr)), border = NA, col = alpha("salmon", 0.5))
  lines(pred_L_Pb_lwr ~ E_scaled_seq, col = "red", lty = 2)
  lines(pred_L_Pb_upr ~ E_scaled_seq, col = "red", lty = 2)
  lines(pred_L_Pb_mean ~ E_scaled_seq, col = "red", lwd = 2)
  
  # realized pairs
  segments(E_scaled_lwr, L_Pb_mean, E_scaled_upr, L_Pb_mean, col = alpha("red", 0.5))
  segments(E_scaled_mean, L_Pb_lwr, E_scaled_mean, L_Pb_upr, col = alpha("red", 0.5))
  points(L_Pb_mean ~ E_scaled_mean, pch = 21, col = "red", bg = alpha("salmon", 0.5), cex = 1.2)
  
}

par(mfrow = c(2,2), oma = c(1.5,1.5,0,0))
junk = sapply(1:jags_data$nj, plot_f)
mtext(side = 1, outer = T, line = 0.25, "Eggs/WUL")
mtext(side = 2, outer = T, line = 0.25, TeX("$Mean\\,Length\\,at\\,Summer\\,Tagging\\,(mm)$"))
```

## Spring Length {.tabset .tabset-pills}

### Spring vs. Summer Length

```{r}
plot_f = function(j) {

  # extract posterior summaries of summer length outcomes
  L_Pb_mean = post_summ(post, sub_index("^L_Pb[year,pop]", year = ts_yrs, pop = j))["mean",]
  L_Pb_lwr = post_summ(post, sub_index("^L_Pb[year,pop]", year = ts_yrs, pop = j))["2.5%",]
  L_Pb_upr = post_summ(post, sub_index("^L_Pb[year,pop]", year = ts_yrs, pop = j))["97.5%",]
  
  # extract posterior summaries of spring length outcomes
  L_Mb_mean = post_summ(post, sub_index("^L_Mb[year,pop]", year = ts_yrs, pop = j))["mean",]
  L_Mb_lwr = post_summ(post, sub_index("^L_Mb[year,pop]", year = ts_yrs, pop = j))["2.5%",]
  L_Mb_upr = post_summ(post, sub_index("^L_Mb[year,pop]", year = ts_yrs, pop = j))["97.5%",]
  
  # create a vector of scaled egg abundances to calculate at
  L_Pb_seq = seq(min(L_Pb_lwr), max(L_Pb_upr), length = 30)

  # extract posteriors of coefficients
  mu_growth = post_subset(post, sub_index("mu_growth[pop]", pop = j), matrix = TRUE)

  # function to create predicted survival curves for one posterior sample
  pred_fn = function(i) {
    pred_L_Mb = L_Pb_seq * mu_growth[i]
    names(pred_L_Mb) = paste0("pred_L_Mb[", 1:30, "1]")
    pred_L_Mb
  }
  
  # calculate predicted survivals and add to posterior samples
  pred_L_Mb = t(sapply(1:post_dim(post, "saved"), pred_fn))
  post_pred_L_Mb = post_convert(cbind(postpack:::id_mat(post), pred_L_Mb))
  
  # extract summarize predicted length
  pred_L_Mb_mean = post_summ(post_pred_L_Mb, "")["mean",]
  pred_L_Mb_lwr = post_summ(post_pred_L_Mb, "")["2.5%",]
  pred_L_Mb_upr = post_summ(post_pred_L_Mb, "")["97.5%",]
  
  # make a blank plot with the correct dimensions
  par(mgp = c(2,0.35, 0), tcl = -0.15, mar = c(1,1,2,1))
  plot(1,1, type = "n", 
       ylim = range(pred_L_Mb_lwr, pred_L_Mb_upr, L_Mb_lwr, L_Mb_upr, na.rm = T),
       xlim = range(L_Pb_seq), 
       main = pops[j]
  )
    
  # expected relationship
  polygon(c(L_Pb_seq, rev(L_Pb_seq)), c(pred_L_Mb_lwr, rev(pred_L_Mb_upr)), border = NA, col = alpha("salmon", 0.5))
  lines(pred_L_Mb_lwr ~ L_Pb_seq, col = "red", lty = 2)
  lines(pred_L_Mb_upr ~ L_Pb_seq, col = "red", lty = 2)
  lines(pred_L_Mb_mean ~ L_Pb_seq, col = "red", lwd = 2)
  
  # realized pairs
  segments(L_Pb_lwr, L_Mb_mean, L_Pb_upr, L_Mb_mean, col = alpha("red", 0.5))
  segments(L_Pb_mean, L_Mb_lwr, L_Pb_mean, L_Mb_upr, col = alpha("red", 0.5))
  points(L_Mb_mean ~ L_Pb_mean, pch = 21, col = "red", bg = alpha("salmon", 0.5), cex = 1.2)
  
}

par(mfrow = c(2,2), oma = c(1.5,1.5,0,0))
junk = sapply(1:jags_data$nj, plot_f)
mtext(side = 1, outer = T, line = 0.25, TeX("$Mean\\,Length\\,at\\,Summer\\,Tagging\\,(mm)$"))
mtext(side = 2, outer = T, line = 0.25, TeX("$Mean\\,Length\\,at\\,Spring\\,Tagging\\,(mm)$"))
```

### Growth Rate

```{r}
plot_f = function(j) {
  
  growth_obs = cbind(mean = jags_data$L_Mb_obs[observable,j]/jags_data$L_Pb_obs[observable,j],
                     lwr95 = NA, upr95 = NA)
  
  plot_tseries(post_summ(post, sub_index("^growth[year,pop]$", year = ts_yrs, pop = j)),
               growth_obs,
               main = pops[j],
               yrs = all_yrs[ts_yrs])
}

par(mfrow = c(2,2), oma = c(1.5,1.5,0,0))
junk = sapply(1:jags_data$nj, plot_f)
mtext(side = 1, outer = T, line = 0.25, "Brood Year")
mtext(side = 2, outer = T, line = 0.25, TeX("$Summer\\,Parr \\rightarrow Spring\\,Smolt\\Growth$"))
```

# Length-Based Survival Relationships {.tabset .tabset-pills}

## Overwinter Survival

```{r overwinter-survival-plots, fig.width = 8, fig.height = 5}
plot_fn = function(j, i) {
  
  # extract posterior summaries of spring length outcomes
  L_Pb_mean = post_summ(post, sub_index("^L_Pb[year,pop]", year = ts_yrs, pop = j))["mean",]
  L_Pb_lwr = post_summ(post, sub_index("^L_Pb[year,pop]", year = ts_yrs, pop = j))["2.5%",]
  L_Pb_upr = post_summ(post, sub_index("^L_Pb[year,pop]", year = ts_yrs, pop = j))["97.5%",]
  
  # summarize posterior of overwinter survival outcomes
  phi_Pa_Mb_mean = array_format(post_summ(post, sub_index("^phi_Pa_Mb[year,LH_type,pop]", pop = j, year = ts_yrs, LH_type = i))["mean",])[-1,i,j]
  phi_Pa_Mb_lwr = array_format(post_summ(post, sub_index("^phi_Pa_Mb[year,LH_type,pop]", pop = j, year = ts_yrs, LH_type = i))["2.5%",])[-1,i,j]
  phi_Pa_Mb_upr = array_format(post_summ(post, sub_index("^phi_Pa_Mb[year,LH_type,pop]", pop = j, year = ts_yrs, LH_type = i))["97.5%",])[-1,i,j]

  # create vectors to predict survival at: for credible regions and mean curve
  L_Pb_seq = seq(min(L_Pb_lwr), max(L_Pb_upr), length = 30)
  
  # extract posteriors of coefficients
  gamma0 = post_subset(post, sub_index("gamma0[LH_type,pop]", pop = j, LH_type = i), matrix = TRUE)
  gamma1 = post_subset(post, sub_index("gamma1[LH_type,pop]", pop = j, LH_type = i), matrix = TRUE)
  
  # function to create predicted survival curve for one posterior sample
  pred_fn = function(i) {
    pred_phi_Pa_Mb = plogis(gamma0[i] + gamma1[i] * L_Pb_seq)
    names(pred_phi_Pa_Mb) = paste0("pred_phi_Pa_Mb[", 1:30, "]")
    pred_phi_Pa_Mb
  }
  
  # calculate predicted survivals and add to posterior samples
  pred_phi_Pa_Mb = t(sapply(1:post_dim(post, "saved"), pred_fn))
  post_pred_phi_Pa_Mb = post_convert(cbind(postpack:::id_mat(post), pred_phi_Pa_Mb))
  
  # extract summarize predicted length
  pred_phi_Pa_Mb_mean = post_summ(post_pred_phi_Pa_Mb, "")["mean",]
  pred_phi_Pa_Mb_lwr = post_summ(post_pred_phi_Pa_Mb, "")["2.5%",]
  pred_phi_Pa_Mb_upr = post_summ(post_pred_phi_Pa_Mb, "")["97.5%",]
  
  # make a blank plot with the correct dimensions
  par(mgp = c(2,0.35, 0), tcl = -0.15, mar = c(1,1,2,1))
  plot(1,1, type = "n", 
       ylim = range(pred_phi_Pa_Mb_lwr, pred_phi_Pa_Mb_upr, phi_Pa_Mb_lwr, phi_Pa_Mb_upr, na.rm = T),
       xlim = range(L_Pb_seq), 
       main = ifelse(i == 1, pops[j], "")
  )
    
  # expected relationship
  polygon(c(L_Pb_seq, rev(L_Pb_seq)), c(pred_phi_Pa_Mb_lwr, rev(pred_phi_Pa_Mb_upr)), border = NA, col = alpha("salmon", 0.5))
  lines(pred_phi_Pa_Mb_lwr ~ L_Pb_seq, col = "red", lty = 2)
  lines(pred_phi_Pa_Mb_upr ~ L_Pb_seq, col = "red", lty = 2)
  lines(pred_phi_Pa_Mb_mean ~ L_Pb_seq, col = "red", lwd = 2)
  
  # realized pairs
  segments(L_Pb_lwr, phi_Pa_Mb_mean, L_Pb_upr, phi_Pa_Mb_mean, col = alpha("red", 0.5))
  segments(L_Pb_mean, phi_Pa_Mb_lwr, L_Pb_mean, phi_Pa_Mb_upr, col = alpha("red", 0.5))
  points(phi_Pa_Mb_mean ~ L_Pb_mean, pch = 21, col = "red", bg = alpha("salmon", 0.5), cex = 1.2)
}

plot_fn2 = function(j) {
    # create the plots for both migratory strategies
  par(mgp = c(2, 0.35, 0), tcl = -0.15, mar = c(1,1,2,1))
  plot_fn(j = j, i = 1); if (j == 1) mtext(side = 2, line = 1.5, "Fall Migrants")
  plot_fn(j = j, i = 2); if (j == 1) mtext(side = 2, line = 1.5, "Spring Migrants")
}

par(mfcol = c(jags_data$ni,jags_data$nj), oma = c(2.5,3.5,0,0))
junk = sapply(1:jags_data$nj, plot_fn2)
mtext(side = 1, line = 1.5, outer = T, "Mean Length at Summer Tagging (mm)", cex = 1.2)
mtext(side = 2, line = 2, outer = T, "Overwinter Survival", cex = 1.2)
```

## Migration to LGR

```{r toLGR-survival-plots, fig.width = 6, fig.height = 5}
plot_fn = function(j, i) {
  
  # extract posterior summaries of spring length outcomes
  L_Mb_mean = post_summ(post, sub_index("^L_Mb[year,pop]", year = ts_yrs, pop = j))["mean",]
  L_Mb_lwr = post_summ(post, sub_index("^L_Mb[year,pop]", year = ts_yrs, pop = j))["2.5%",]
  L_Mb_upr = post_summ(post, sub_index("^L_Mb[year,pop]", year = ts_yrs, pop = j))["97.5%",]
  
  # summarize posterior of migration survival outcomes
  phi_Mb_Ma_mean = array_format(post_summ(post, sub_index("^phi_Mb_Ma[year,LH_type,origin,pop]", pop = j, year = ts_yrs, LH_type = i_spring, origin = o_nor))["mean",])[-1,i_spring,o_nor,j]
  phi_Mb_Ma_lwr = array_format(post_summ(post, sub_index("^phi_Mb_Ma[year,LH_type,origin,pop]", pop = j, year = ts_yrs, LH_type = i_spring, origin = o_nor))["2.5%",])[-1,i_spring,o_nor,j]
  phi_Mb_Ma_upr = array_format(post_summ(post, sub_index("^phi_Mb_Ma[year,LH_type,origin,pop]", pop = j, year = ts_yrs, LH_type = i_spring, origin = o_nor))["97.5%",])[-1,i_spring,o_nor,j]

  # create vectors to predict survival at: for credible regions and mean curve
  L_Mb_seq = seq(min(L_Mb_lwr), max(L_Mb_upr), length = 30)
  
  # extract posteriors of coefficients
  tau0 = post_subset(post, sub_index("tau0[pop]", pop = j), matrix = TRUE)
  tau1 = post_subset(post, sub_index("tau1[pop]", pop = j), matrix = TRUE)

  # function to create predicted survival curve for one posterior sample
  pred_fn = function(i) {
    pred_phi_Mb_Ma = plogis(tau0[i] + tau1[i] * L_Mb_seq)
    names(pred_phi_Mb_Ma) = paste0("pred_phi_Mb_Ma[", 1:30, "]")
    pred_phi_Mb_Ma
  }
  
  # calculate predicted survivals and add to posterior samples
  pred_phi_Mb_Ma = t(sapply(1:post_dim(post, "saved"), pred_fn))
  post_pred_phi_Mb_Ma = post_convert(cbind(postpack:::id_mat(post), pred_phi_Mb_Ma))
  
  # extract summarize predicted length
  pred_phi_Mb_Ma_mean = post_summ(post_pred_phi_Mb_Ma, "")["mean",]
  pred_phi_Mb_Ma_lwr = post_summ(post_pred_phi_Mb_Ma, "")["2.5%",]
  pred_phi_Mb_Ma_upr = post_summ(post_pred_phi_Mb_Ma, "")["97.5%",]
  
  # make a blank plot with the correct dimensions
  par(mgp = c(2,0.35, 0), tcl = -0.15, mar = c(1,1,2,1))
  plot(1,1, type = "n", 
       ylim = range(pred_phi_Mb_Ma_lwr, pred_phi_Mb_Ma_upr, phi_Mb_Ma_lwr, phi_Mb_Ma_upr, na.rm = T),
       xlim = range(L_Mb_seq), 
       main = pops[j]
  )
    
  # expected relationship
  polygon(c(L_Mb_seq, rev(L_Mb_seq)), c(pred_phi_Mb_Ma_lwr, rev(pred_phi_Mb_Ma_upr)), border = NA, col = alpha("salmon", 0.5))
  lines(pred_phi_Mb_Ma_lwr ~ L_Mb_seq, col = "red", lty = 2)
  lines(pred_phi_Mb_Ma_upr ~ L_Mb_seq, col = "red", lty = 2)
  lines(pred_phi_Mb_Ma_mean ~ L_Mb_seq, col = "red", lwd = 2)
  
  # realized pairs
  segments(L_Mb_lwr, phi_Mb_Ma_mean, L_Mb_upr, phi_Mb_Ma_mean, col = alpha("red", 0.5))
  segments(L_Mb_mean, phi_Mb_Ma_lwr, L_Mb_mean, phi_Mb_Ma_upr, col = alpha("red", 0.5))
  points(phi_Mb_Ma_mean ~ L_Mb_mean, pch = 21, col = "red", bg = alpha("salmon", 0.5), cex = 1.2)
}

par(mfrow = c(2,2), oma = c(1.5,1.5,0,0))
junk = sapply(1:jags_data$nj, plot_fn)
mtext(side = 1, outer = T, line = 0.25, "Length at Spring Tagging (mm)")
mtext(side = 2, outer = T, line = 0.25, "Migration to LGR Survival")
```

# Equivilency Rates {.tabset .tabset-pills}

## Smolt-to-Adult Rates {.tabset .tabset-pills}

### LGR to Tributary

This is survival from $Ma$ (smolts at the top of LGD) to $Ra$ (adults returning to tributary, vulnerable to being counted at weir).

The adult part is calculated across return years, by summing the number of adults of each age that return in the appropriate years. For example, the SAR for brood year 1991 uses smolt that were spawned in 1991, out-migrated in spring 1993, divided by the sum of age 3 adults in 1994, age 4 adults in 1995, and age 5 adults in 1996. The calculation is done for hatchery and natural origin fish separately. Only SARs through brood year 2014 are calculated, since this is the last year of complete adult returns.

```{r adults-per-smolt, fig.width = 6, fig.height = 5}
plot_fn = function(j) {
  # which years had zero hatchery smolt released
  zero_hor_smolt = post_summ(post, sub_index("Mb[year,LH_type,origin,pop]", year = sar_yrs, LH_type = i_spring, origin = o_hor, pop = j))["mean",] == 0

  # summarize rates
  Ra_per_Ma_nor = post_summ(post, sub_index("Ra_per_Ma[year,origin,pop]", year = sar_yrs, origin = o_nor, pop = j)) * 100
  Ra_per_Ma_hor = post_summ(post, sub_index("Ra_per_Ma[year,origin,pop]", year = sar_yrs, origin = o_hor, pop = j)) * 100

  # make hatchery values NA in year with no smolt
  Ra_per_Ma_hor[,zero_hor_smolt] = NA

  # plot natural origin time series
  plot_tseries(est = Ra_per_Ma_nor, yrs = all_yrs[sar_yrs], main = pops[j], ylim = c(0, 10))
  
  # add hatchery origin time series
  polygon(x = c(all_yrs[sar_yrs], rev(all_yrs[sar_yrs])), y = c(Ra_per_Ma_hor["2.5%",], rev(Ra_per_Ma_hor["97.5%",])), col = alpha("skyblue2", 0.5), border = NA)
  lines(Ra_per_Ma_hor["2.5%",] ~ all_yrs[sar_yrs], col = "blue", lty = 2)
  lines(Ra_per_Ma_hor["97.5%",] ~ all_yrs[sar_yrs], col = "blue", lty = 2)
  lines(Ra_per_Ma_hor["mean",] ~ all_yrs[sar_yrs], col = "blue", lwd = 2)

  if (j == 1) {
    legend("topright", legend = origins, title = "Origin",
         pch = 22, col = c("red", "blue"), pt.cex = 2, pt.bg = alpha(c("salmon", "skyblue2"), 0.5), bty = "n")
  }
}
par(mfrow = c(2,2), oma = c(1.5,1.5,0,0))
junk = sapply(1:jags_data$nj, plot_fn)
mtext(side = 1, outer = T, line = 0.25, "Brood Year")
mtext(side = 2, outer = T, line = 0.25, "Adults per 100 Smolt")
```

### BON to BON

```{r bon-to-bon, fig.width = 6, fig.height = 5}
plot_fn = function(j) {
  # which years had zero hatchery smolt released
  zero_hor_smolt = post_summ(post, sub_index("Mb[year,LH_type,origin,pop]", year = sar_yrs, LH_type = i_spring, origin = o_hor, pop = j))["mean",] == 0
  
  # summarize rates
  phi_nor = post_summ(post, sub_index("phi_O0_Rb_BON[year,origin,pop]", year = sar_yrs, origin = o_nor, pop = j))
  phi_hor = post_summ(post, sub_index("phi_O0_Rb_BON[year,origin,pop]", year = sar_yrs, origin = o_hor, pop = j))
  
  # get a max value for ylim
  ymax = max(post_summ(post, sub_index("phi_O0_Rb_BON[year,origin,pop]", year = sar_yrs, origin = o_nor, pop = "."))["97.5%",])

  # make hatchery values NA in year with no smolt
  phi_hor[,zero_hor_smolt] = NA

  # plot natural origin time series
  plot_tseries(est = phi_nor, yrs = all_yrs[sar_yrs], main = pops[j], ylim = c(0, ymax))
  
  # add hatchery origin time series
  polygon(x = c(all_yrs[sar_yrs], rev(all_yrs[sar_yrs])), y = c(phi_hor["2.5%",], rev(phi_hor["97.5%",])), col = alpha("skyblue2", 0.5), border = NA)
  lines(phi_hor["2.5%",] ~ all_yrs[sar_yrs], col = "blue", lty = 2)
  lines(phi_hor["97.5%",] ~ all_yrs[sar_yrs], col = "blue", lty = 2)
  lines(phi_hor["mean",] ~ all_yrs[sar_yrs], col = "blue", lwd = 2)

  if (j == 1) {
    legend("topright", legend = origins, title = "Origin",
         pch = 22, col = c("red", "blue"), pt.cex = 2, pt.bg = alpha(c("salmon", "skyblue2"), 0.5), bty = "n")
  }
}
par(mfrow = c(2,2), oma = c(1.5,1.5,0,0))
junk = sapply(1:jags_data$nj, plot_fn)
mtext(side = 1, outer = T, line = 0.25, "Brood Year")
mtext(side = 2, outer = T, line = 0.25, "BON -> BON Survival")
```

## Parr per Spawner

"Spawner" means total spawners that survive pre-spawn mortality.

```{r parr-per-spawner, fig.width = 6, fig.height = 5}
plot_fn = function(j) {
  plot_tseries(est = post_summ(post, sub_index("Pb_per_Sa_tot[year,pop]", pop = j, year = ts_yrs)), yrs = all_yrs[ts_yrs], main = pops[j])
}

par(mfrow = c(2,2), oma = c(1.5,1.5,0,0))
junk = sapply(1:jags_data$nj, plot_fn)
mtext(side = 1, outer = T, line = 0.25, "Brood Year")
mtext(side = 2, outer = T, line = 0.25, "Parr per Spawner")
```

## Smolt per Spawner

"Smolt" means total NOR smolt that survive their second winter, immediately prior to migration out of basin.

```{r smolt-per-spawner, fig.width = 6, fig.height = 5}
plot_fn = function(j) {
  plot_tseries(est = post_summ(post, sub_index("Mb_per_Sa_tot[year,pop]", pop = j, year = ts_yrs)), yrs = all_yrs[ts_yrs], main = pops[j])
}

par(mfrow = c(2,2), oma = c(1.5,1.5,0,0))
junk = sapply(1:jags_data$nj, plot_fn)
mtext(side = 1, outer = T, line = 0.25, "Brood Year")
mtext(side = 2, outer = T, line = 0.25, "Smolt per Spawner")
```

## Spawners per Spawner

This is the sum of all spawners that were produced by the spawners in a given brood year (i.e., accounts for adult recruits returning across multiple ages/years). "Brood year" refers to the year the returning production was spawned. 

```{r spawners-per-spawner, fig.width = 6, fig.height = 5}
plot_fn = function(j) {
  plot_tseries(est = post_summ(post, sub_index("Sa_tot_per_Sa_tot[year,pop]", pop = j, year = sar_yrs)), yrs = all_yrs[sar_yrs], main = pops[j])
 abline(h = 1, lty = 2)
}
par(mfrow = c(2,2), oma = c(1.5,1.5,0,0))
junk = sapply(1:jags_data$nj, plot_fn)
mtext(side = 1, outer = T, line = 0.25, "Brood Year")
mtext(side = 2, outer = T, line = 0.25, "Spawner per Spawner")
```

# Straying Dynamics {.tabset .tabset-pills}

## Number of Strays

```{r n-stray, fig.width = 6, fig.height = 5}
plot_fn = function(j) {
  plot_tseries(est = post_summ(post, sub_index("^G[year,origin,pop]", pop = j, year = ts_yrs, origin = o_hor)), yrs = all_yrs[ts_yrs], main = pops[j])
}

par(mfrow = c(2,2), oma = c(1.5,1.5,0,0))
junk = sapply(1:jags_data$nj, plot_fn)
mtext(side = 1, outer = T, line = 0.25, "Return Year")
mtext(side = 2, outer = T, line = 0.25, "Number of Strays Entering Population")
```

## Stray Composition

```{r stray-comp, fig.width = 6, fig.height = 5}
plot_fn = function(j) {
  x = post_summ(post, sub_index("p_G[age,origin,pop]", age = ".", origin = o_hor, pop = j))
  
  par(mar = c(5,2,1,1), tcl = -0.15, mgp = c(2, 0.35, 0))
  mp = barplot(x["mean",], ylim = c(0, 1), xaxt = "n", main = pops[j], col = alpha("salmon", 0.5), border = alpha("red", 0.5))
  segments(mp, x["2.5%",], mp, x["97.5%",], col = alpha("red", 0.5))
  axis(side = 1, at = mp, labels = paste0("Age", jags_data$kmin:jags_data$kmax), las = 2)
  segments(par("usr")[1], par("usr")[3], par("usr")[2], par("usr")[3], xpd = TRUE)
}

par(mfrow = c(2,2), oma = c(0,1.5,0,0))
junk = sapply(1:jags_data$nj, plot_fn)
mtext(side = 2, outer = T, line = 0.25, "Proportion of Strays by Age")
```

# Ocean Survival {.tabset .tabset-pills}

```{r ocean-surv-plots, fig.width = 6, fig.height = 5}
ocean_surv_plot = function(j) {
  par(mfrow = c(3,2), oma = c(1.5,1.5,0,0))
  plot_tseries(post_summ(post, sub_index("^phi_O0_O1[year,origin,pop]", year = ts_yrs, origin = o_nor, pop = j)),
               main = TeX("$O_0 \\rightarrow O_1\\,(NOR)$"), yrs = all_yrs[ts_yrs], ylim = c(0,1))
  plot_tseries(post_summ(post, sub_index("^phi_O0_O1[year,origin,pop]", year = ts_yrs, origin = o_hor, pop = j)),
               main = TeX("$O_0 \\rightarrow O_1\\,(HOR)$"), yrs = all_yrs[ts_yrs], ylim = c(0,1))
  plot_tseries(post_summ(post, sub_index("^phi_O1_O2[year,origin,pop]", year = ts_yrs, origin = o_nor, pop = j)),
               main = TeX("$O_1 \\rightarrow O_2\\,(NOR)$"), yrs = all_yrs[ts_yrs], ylim = c(0,1))
  plot_tseries(post_summ(post, sub_index("^phi_O1_O2[year,origin,pop]", year = ts_yrs, origin = o_hor, pop = j)),
               main = TeX("$O_1 \\rightarrow O_2\\,(HOR)$"), yrs = all_yrs[ts_yrs], ylim = c(0,1))
  plot_tseries(post_summ(post, sub_index("^phi_O2_O3[year,origin,pop]", year = ts_yrs, origin = o_nor, pop = j)),
               main = TeX("$O_2 \\rightarrow O_3\\,(NOR)$"), yrs = all_yrs[ts_yrs], ylim = c(0,1))
  plot_tseries(post_summ(post, sub_index("^phi_O2_O3[year,origin,pop]", year = ts_yrs, origin = o_hor, pop = j)),
               main = TeX("$O_2 \\rightarrow O_3\\,(HOR)$"), yrs = all_yrs[ts_yrs], ylim = c(0,1))
  mtext(side = 1, outer = T, line = 0.5, "Brood Year")
  mtext(side = 2, outer = T, line = 0, "Survival")
}
```

## CAT

```{r}
ocean_surv_plot(j_cat)
```

## LOS

```{r}
ocean_surv_plot(j_los)
```

## MIN

```{r}
ocean_surv_plot(j_min)
```

## UGR

```{r}
ocean_surv_plot(j_ugr)
```

# Maturity {.tabset .tabset-pills}

```{r maturity-plot-fn}
maturity_plot = function(j) {
  par(mfrow = c(2,2), oma = c(1.5,1.5,0,0))
  plot_tseries(post_summ(post, sub_index("^psi_O1[year,origin,pop]$", year = ts_yrs, origin = o_nor, pop = j)), main = "Age 3 (NOR)", yrs = all_yrs[ts_yrs], ylim = c(0,1))
  plot_tseries(post_summ(post, sub_index("^psi_O1[year,origin,pop]$", year = ts_yrs, origin = o_hor, pop = j)), main = "Age 3 (HOR)", yrs = all_yrs[ts_yrs], ylim = c(0,1))
  plot_tseries(post_summ(post, sub_index("^psi_O2[year,origin,pop]$", year = ts_yrs, origin = o_nor, pop = j)), main = "Age 4 (NOR)", yrs = all_yrs[ts_yrs], ylim = c(0,1))
  plot_tseries(post_summ(post, sub_index("^psi_O2[year,origin,pop]$", year = ts_yrs, origin = o_hor, pop = j)), main = "Age 4 (HOR)", yrs = all_yrs[ts_yrs], ylim = c(0,1))

  mtext(side = 1, outer = T, line = 0.25, "Brood Year")
  mtext(side = 2, outer = T, line = 0.25, "Pr(Mature-at-Age|Alive in Ocean)")
}
```

## CAT

```{r maturity-cat, fig.width = 6, fig.height = 5}
maturity_plot(j_cat)
```

## LOS

```{r maturity-los, fig.width = 6, fig.height = 5}
maturity_plot(j_los)
```

## MIN

```{r maturity-min, fig.width = 6, fig.height = 5}
maturity_plot(j_min)
```

## UGR

```{r maturity-ugr, fig.width = 6, fig.height = 5}
maturity_plot(j_ugr)
```

# Parameter Summaries {.tabset .tabset-dropdown}

```{r my-boxplot-function}
my_boxplot = function(params, ylab = NULL, ticklabs = pops, ylim = NULL, boxfill = alpha("salmon", 0.5), border = alpha("red", 0.5), ...) {
  # extract posterior samples and rename them
  post_sub = post_subset(post, params, matrix = TRUE)
  
  if (ncol(post_sub) >= 2) {
    colnames(post_sub) = ticklabs
  }

  # initialize a boxplot object
  bp = boxplot(post_sub, plot = FALSE)
  
  # replace the summary stats with my preferred quantiles
  par(mar = c(5,3,1,1), mgp = c(2,0.35,0), tcl = -0.15)
  bp$stats = apply(post_sub, 2, function(x) quantile(x, c(0.025, 0.25, 0.5, 0.75, 0.975)))
  bxp(bp, ylab = ylab, xlab = "", outline = FALSE, ylim = ylim, ...,
      staplelty = 0, whisklty = 1, boxfill = boxfill, boxcol = border, medcol = border, whiskcol = border)
} 
```

## Parr Recruitment

```{r recruit-bxp, fig.width = 8, fig.height = 3.5}
par(mfrow = c(1,4))
my_boxplot("^alpha[.]$", "Productivity")
my_boxplot("^beta[.]$", "Capacity")
my_boxplot("^sig_Lphi_E_Pb[.]$", "Process SD")
my_boxplot("^rho_Lphi_E_Pb", "Among-pop Correlation", ticklabs = vcov_labels, las = 3)
```

## Summer Parr Size

```{r summer-size-bxp, fig.width = 8, fig.height = 3.5}
par(mfrow = c(1,4))
my_boxplot("^omega0[.]$", "Intercept")
my_boxplot("^omega1[.]$", "Slope")
my_boxplot("^sig_lL_Pb[.]$", "Process SD")
my_boxplot("^rho_lL_Pb", "Among-pop Correlation", ticklabs = vcov_labels, las = 3)
```

## Life History Apportionment

```{r LH-type-bxp, fig.width = 8, fig.height = 3.5}
par(mfrow = c(1,3))
my_boxplot("^mu_pi[1,.]$", "Mean Proportion Fall Migrants")
my_boxplot("^sig_Lpi[.]$", "Process SD")
my_boxplot("^rho_Lpi", "Among-pop Correlation", ticklabs = vcov_labels, las = 3)
```

## Overwinter Survival {.tabset .tabset-pills}

### Logistic Function Parameters

```{r overwinter-survival-bxp1, fig.width = 8, fig.height = 3.5}
par(mfrow = c(1,3))
my_boxplot(sub_index("gamma0[LH_type,pop]", LH_type = i_fall, pop = "."), "Intercept (Fall)")
my_boxplot(sub_index("gamma0[LH_type,pop]", LH_type = i_spring, pop = "."), "Intercept (Spring)")
my_boxplot(sub_index("gamma1[LH_type,pop]", LH_type = i_spring, pop = "."), "Slope")
```

### Process SD

```{r overwinter-survival-bxp2, fig.width = 8, fig.height = 3.5}
par(mfrow = c(1,2))
my_boxplot(sub_index("sig_Lphi_Pa_Mb[pop,LH_type]", LH_type = i_fall, pop = "."), "Process SD (Fall)")
my_boxplot(sub_index("sig_Lphi_Pa_Mb[pop,LH_type]", LH_type = i_spring, pop = "."), "Process SD (Spring)")
```

### Among-pop Correlation

```{r overwinter-survival-bxp3, fig.width = 8, fig.height = 3.5}
par(mfrow = c(1,2))
my_boxplot(sub_index("rho_Lphi_Pa_Mb[.,.,LH_type]", LH_type = i_fall), "Among-pop Correlation (Fall)", ticklabs = vcov_labels, las = 3)
my_boxplot(sub_index("rho_Lphi_Pa_Mb[.,.,LH_type]", LH_type = i_spring), "Among-pop Correlation (Spring)", ticklabs = vcov_labels, las = 3)
```

## Movement Survival to LGR {.tabset .tabset-pills}

### Mean/Logistic Model Parameters

```{r trib-to-lgr-bxp1, fig.width = 8, fig.height = 3.5}
par(mfrow = c(1,3))
my_boxplot(sub_index("tau0[pop]", pop = "."), "Intercept", main = "NOR", ylim = c(0,1))
my_boxplot(sub_index("tau1[pop]", pop = "."), "Slope", main = "NOR", ylim = c(0,1))
my_boxplot(sub_index("mu_phi_Mb_Ma[LH_type,origin,pop]", LH_type = i_spring, origin = o_hor, pop = "."), "Average Migration Survival", main = "HOR", ylim = c(0,1))
```

### Process SD

```{r trib-to-lgr-bxp2, fig.width = 8, fig.height = 3.5}
par(mfrow = c(1,2))
my_boxplot(sub_index("sig_Lphi_Mb_Ma[pop,origin]", origin = o_nor, pop = "."), "Process SD", main = "NOR")
my_boxplot(sub_index("sig_Lphi_Mb_Ma[pop,origin]", origin = o_hor, pop = "."), "Process SD", main = "HOR")
```

### Among-pop Correlation

```{r trib-to-lgr-bxp3, fig.width = 8, fig.height = 3.5}
par(mfrow = c(1,2))
my_boxplot(sub_index("rho_Lphi_Mb_Ma[.,.,origin]", origin = o_nor), "Among-pop Correlation (NOR)", ticklabs = vcov_labels, las = 3)
my_boxplot(sub_index("rho_Lphi_Mb_Ma[.,.,origin]", origin = o_hor), "Among-pop Correlation (HOR)", ticklabs = vcov_labels, las = 3)
```

## Movement Survival to Ocean

```{r lgr-to-ocean-bxp}
par(mfrow = c(1,3))
my_boxplot(sub_index("mu_phi_Ma_O0[origin]", origin = "."), "Average Migration Survival", ylim = c(0,1), ticklab = origins)
my_boxplot(sub_index("sig_Lphi_Ma_O0[origin]", origin = "."), "Process SD", ylim = c(0,1), ticklab = origins)
my_boxplot(sub_index("rho_Lphi_Ma_O0[2,1]"), "Among-origin Correlation", ylim = c(-1,1), ticklab = c(""))
```

## Probability of Maturing at Age-3 {.tabset .tabset-pills}

### Means

```{r age3-mean-bxp, fig.width = 8, fig.height = 3.5}
par(mfrow = c(1,2))
my_boxplot(sub_index("mu_psi_O1[origin,pop]", origin = o_nor, pop = "."), "", main = "NOR", ylim = c(0,1))
my_boxplot(sub_index("mu_psi_O1[origin,pop]", origin = o_hor, pop = "."), "", main = "HOR", ylim = c(0,1))
```

### Process SD

```{r age3-sd-bxp, fig.width = 8, fig.height = 3.5}
par(mfrow = c(1,2))
my_boxplot(sub_index("sig_Lpsi_O1[pop,origin]", origin = o_nor, pop = "."), "", main = "NOR")
my_boxplot(sub_index("sig_Lpsi_O1[pop,origin]", origin = o_hor, pop = "."), "", main = "HOR")
```

### Among-pop Correlation

```{r age3-rho-bxp, fig.width = 8, fig.height = 3.5}
par(mfrow = c(1,2))
my_boxplot(sub_index("rho_Lpsi_O1[.,.,origin]", origin = o_nor), "Among-pop Correlation (NOR)", ticklabs = vcov_labels, las = 3)
my_boxplot(sub_index("rho_Lpsi_O1[.,.,origin]", origin = o_hor), "Among-pop Correlation (HOR)", ticklabs = vcov_labels, las = 3)
```

## Probability of Maturing at Age-4 {.tabset .tabset-pills}

### Means

```{r age4-mean-bxp, fig.width = 8, fig.height = 3.5}
par(mfrow = c(1,2))
my_boxplot(sub_index("mu_psi_O2[origin,pop]", origin = o_nor, pop = "."), "", main = "NOR", ylim = c(0,1))
my_boxplot(sub_index("mu_psi_O2[origin,pop]", origin = o_hor, pop = "."), "", main = "HOR", ylim = c(0,1))
```

### Process SD

```{r age4-sd-bxp, fig.width = 8, fig.height = 3.5}
par(mfrow = c(1,2))
my_boxplot(sub_index("sig_Lpsi_O2[pop,origin]", origin = o_nor, pop = "."), "", main = "NOR")
my_boxplot(sub_index("sig_Lpsi_O2[pop,origin]", origin = o_hor, pop = "."), "", main = "HOR")
```

### Among-pop Correlation

```{r age4-rho-bxp, fig.width = 8, fig.height = 3.5}
par(mfrow = c(1,2))
my_boxplot(sub_index("rho_Lpsi_O2[.,.,origin]", origin = o_nor), "Among-pop Correlation (NOR)", ticklabs = vcov_labels, las = 3)
my_boxplot(sub_index("rho_Lpsi_O2[.,.,origin]", origin = o_hor), "Among-pop Correlation (HOR)", ticklabs = vcov_labels, las = 3)
```

## Ocean Survival {.tabset .tabset-pills}

### Year 1 {.tabset .tabset-pills}

#### Mean

```{r yr1-ocean-bxp, fig.width = 8, fig.height = 3.5}
par(mfrow = c(1,2))
my_boxplot(sub_index("mu_phi_O0_O1[origin,pop]", origin = o_nor, pop = "."), main = "NOR", ylim = c(0,1), ylab = "Average Survival")
my_boxplot(sub_index("mu_phi_O0_O1[origin,pop]", origin = o_hor, pop = "."), main = "HOR", ylim = c(0,1), ylab = "Average Survival")
```

#### Process SD and Correlation

```{r yr1-ocean-bxp2, fig.width = 8, fig.height = 3.5}
par(mfrow = c(1,3))
my_boxplot(sub_index("sig_Lphi_O0_O1[pop]", pop = "."), ylab = "Process SD")
my_boxplot(sub_index("kappa_phi_O0_O1[pop]", pop = "."), ylab = "Autocorrelation")
my_boxplot("rho_Lphi_O0_O1[", ticklabs = vcov_labels, ylab = "Among-pop Correlation", ylim = c(-1,1), las = 2)
```

### Year 2 {.tabset .tabset-pills}

```{r yr2-ocean-bxp, fig.width = 8, fig.height = 3.5}
par(mfrow = c(1,2))
my_boxplot(sub_index("mu_phi_O1_O2[origin,pop]", origin = o_nor, pop = "."), main = "NOR", ylim = c(0,1), ylab = "Average Survival")
my_boxplot(sub_index("mu_phi_O1_O2[origin,pop]", origin = o_hor, pop = "."), main = "HOR", ylim = c(0,1), ylab = "Average Survival")
```

### Year 3 {.tabset .tabset-pills}

```{r yr3-ocean-bxp, fig.width = 8, fig.height = 3.5}
par(mfrow = c(1,2))
my_boxplot(sub_index("mu_phi_O2_O3[origin,pop]", origin = o_nor, pop = "."), main = "NOR", ylim = c(0,1), ylab = "Average Survival")
my_boxplot(sub_index("mu_phi_O2_O3[origin,pop]", origin = o_hor, pop = "."), main = "HOR", ylim = c(0,1), ylab = "Average Survival")
```

### NOR:HOR Log Odds Ratios

```{r ocean-surv-scaler, fig.width = 8, fig.height = 3.5}
par(mfrow = c(1,3))
my_boxplot(sub_index("delta_O0_O1[pop]", pop = "."), ylab = "Log Odds Ratio", main = "Year 1")
my_boxplot(sub_index("delta_O1_O2[pop]", pop = "."), ylab = "Log Odds Ratio", main = "Year 2")
my_boxplot(sub_index("delta_O2_O3[pop]", pop = "."), ylab = "Log Odds Ratio", main = "Year 3")
```

## Movement Survival BON to LGR

```{r bon-to-lgr-bxp}
par(mfrow = c(1,3))
my_boxplot(sub_index("mu_phi_Rb_Ra[origin]", origin = "."), "Average Migration Survival", ylim = c(0,1), ticklab = origins)
my_boxplot(sub_index("sig_Lphi_Rb_Ra[origin]", origin = "."), "Process SD", ticklab = origins)
my_boxplot(sub_index("rho_Lphi_Rb_Ra[2,1]"), "Among-origin Correlation", ylim = c(-1,1), ticklab = c(""))
```

## Pre-spawn Survival

```{r prespawn-surv-bxp}
par(mfrow = c(1,3))
my_boxplot(sub_index("mu_phi_Sb_Sa[pop]", pop = "."), "Average Survival", ylim = c(0,1))
my_boxplot(sub_index("sig_Lphi_Sb_Sa[pop]", pop = "."), "Process SD")
my_boxplot("rho_Lphi_Sb_Sa", "Among-pop Correlation", ylim = c(-1,1), ticklab = vcov_labels)
```

# Correlation Parameters

```{r rho_plot, fig.width = 6, fig.height = 7}
# get the names of all rho parameters
# these are elements of a correlation matrix
# but because the rho term is the same for all population pairs, it is sufficient 
# to summarize just one element from each matrix
rho_params = c(
  match_params(post, "rho_.+[2,1]"),
  match_params(post, "rho_.+[2,1,1]"),
  match_params(post, "rho_.+[2,1,2]")
)

# calculate/format posterior summaries
rho_summs = t(post_summ(post, rho_params, probs = c(0.025, 0.25, 0.5, 0.75, 0.975)))
rho_summs = as.data.frame(rho_summs)
rho_summs = cbind(param = rownames(rho_summs), rho_summs)
rownames(rho_summs) = NULL

# make prettier names for each term
rho_names = c(
  "rho_Lphi_E_Pb[2,1]" = "Egg-to-Parr Survival",
  "rho_lL_Pb[2,1]" = "Summer Mean Length",
  "rho_lgrowth[2,1]" = "Summer to Spring Growth",
  "rho_Lpi[2,1]" = "Mig. Strategy Apportionment",
  "rho_Lphi_Ma_O0[2,1]" = "LGR to Ocean Survival",
  "rho_Lphi_O0_O1[2,1]" = "Yr1 Ocean Survival",
  "rho_Lphi_Rb_Ra[2,1]" = "BON to LGR Survival",
  "rho_Lphi_Sb_Sa[2,1]" = "Pre-spawn Survival",
  "rho_Lphi_Pa_Mb[2,1,1]" = "Overwinter Survival (Fall)",
  "rho_Lphi_Pa_Mb[2,1,2]" = "Overwinter Survival (Spring)",
  "rho_Lphi_Mb_Ma[2,1,1]" = "Trib to LGR Survival (NOR)",
  "rho_Lphi_Mb_Ma[2,1,2]" = "Trib to LGR Survival (HOR)",
  "rho_Lpsi_O1[2,1,1]" = "Age-3 Maturation (NOR)",
  "rho_Lpsi_O1[2,1,2]" = "Age-3 Maturation (HOR)",
  "rho_Lpsi_O2[2,1,1]" = "Age-4 Maturation (NOR)",
  "rho_Lpsi_O2[2,1,2]" = "Age-4 Maturation (HOR)"
  )
rho_summs$name = rho_names[rho_summs$param]

# reorder by decreasing mean correlation
rho_summs = rho_summs[order(rho_summs$mean, decreasing = TRUE),]
at_y = nrow(rho_summs):1

# use different colors for correlations that are between origins vs. between populations
col = ifelse(rho_summs$param %in% c("rho_Lphi_Ma_O0[2,1]", "rho_Lphi_Rb_Ra[2,1]"), "red", "black")

# make the plot
par(lend = "square", mar = c(3,10,1,1), tcl = -0.15, mgp = c(1.5,0.35,0))
plot(1,1, type = "n", xlim = c(-1,1), ylim = c(1,nrow(rho_summs)), xlab = "Correlation", ylab = "", yaxt = "n")
abline(v = 0, lty = 2)
segments(rho_summs$`2.5%`, at_y, rho_summs$`97.5%`, col = col)
segments(rho_summs$`25%`, at_y, rho_summs$`75%`, lwd = 4, col = col)
points(y = at_y, x = rho_summs$mean, cex = 1, pch = 3, lwd = 2, col = col)
axis(side = 2, at = at_y, labels = rho_summs$name, las = 2, cex.axis = 0.8)
abline(h = at_y - 0.5, col = "grey")
legend("topleft", legend = c("Across Populations", "Across Origins"), text.col = c("black", "red"), bty = "n", cex = 0.8)
box()
```

# Residual Diagnostics {.tabset .tabset-pills}

```{r misc-resid-fns}
get_yr_index = function(params) {
  yr_index = stringr::str_extract(params, "\\[[0-9]+,")
  yr_index = stringr::str_remove(yr_index, "\\[")
  yr_index = stringr::str_remove(yr_index, ",")
  as.numeric(yr_index)
}

make_legend_text = function(mn_post, sd_post, first_last_mn_diff_post) {
  f = function(x) {
    xs = c(mean(x), quantile(x, c(0.025, 0.975)))
    xs = round(xs, 2)
    paste0(xs[1], " (", xs[2], " - ", xs[3], ")")
  }
  c(paste0("Mean: ", f(mn_post)), paste0("SD: ", f(sd_post)), paste0("Diff: ", f(first_last_mn_diff_post)))
}

oma_labels = function(xlab = "", ylab = "", xline = 0.75, yline = 0.75, ...) {
  mtext(side = 1, outer = TRUE, line = xline, text = xlab, ...)
  mtext(side = 2, outer = TRUE, line = yline, text = ylab, ...)
}

no_data_plot = function(main = NULL) {
  plot(1,1, xlim = c(-1,1), ylim = c(-1,1), type = "n", xlab = "", ylab = "", xaxt = "n", yaxt = "n", main = main)
  text(0,0, "No Data", font = 3)
}

my_par = function() {
  par(mfrow = c(2,2), mar = c(1,1,2,2), oma = c(2,2,0,0), tcl = -0.15, mgp = c(2,0.35,0))
}
```

#### Why Does this Matter?

This section is devoted to evaluating how consistent the estimated noise terms are with the assumptions of the random processes they are assumed to be generated by.
Specifically, the noise (or "residual") terms should be:

* **Mean-Zero**: each year has an expected value for the realized outcome, and across years errors should cancel out such that the expected residual in any given year is zero.
* **IID**: all residuals are generated by the same random process, i.e., with mean zero and SD equal to one; with the exception of cases with an auto-regressive process included residuals among years are assumed independent.
* **Lack of time series patterns** is implied by these two assumptions, i.e., there should be no time trends or cyclical "regime shifts".

The presence of egregious violations in these assumptions is an indication that the model may give predictions that are inconsistent with the historical data and assumed hypotheses/mechanisms.

#### What was Calculated?

To examine whether these assumptions were consistently met or violated, residuals from the process model and observation model were calculated and standardized.

Standardized residuals were calculated differently depending on the type of random process:

* **Log-normal** (e.g., for abundance data likelihoods): `(log(realized) - log(expected))/SD`, i.e., noise in log space
* **Logit-normal** (e.g., for survival data likelihoods, survival process noise): `(logit(realized) - logit(expected))/SD`, i.e., noise in logit space
* **Binomial and multinomial** (e.g., for carcass count likelihoods): `sqrt(realized) - sqrt(expected)`; for multinomial counts, these were calculated for each category separately, i.e., the Freeman-Tukey statistic, which is similar to the $\chi^2$ statistic but better handles cases where some bin probabilities are small.

For observation model residuals, `SD` represents the assumed observation error variability supplied to the model as known. For process model residuals, `SD` represents the model-estimated `sig` parameter associated with that random process.

This standardization enables comparison across model components that are on different scales (e.g., abundance vs. probability terms) and have different variances, either process or observation.
The specific standardization used implies that the mean of the residuals from a given model component should be zero across all years, should have a standard deviation of 1, and 95% of the residuals should fall between approximately -2 and 2.

#### What is Shown?

For each random process in the model, the time series of standardized noise terms is plotted below (mean and 95% CRI in red, first and last half mean values in blue). To summarize these time series quantitatively, three across-year summary statistics are reported:

* **Across-year mean** -- intended to verify that noise is centered on the expected value overall (ideally equal to 0)
* **Across-year SD** -- intended to verify that noise is as variable as expected overall (ideally equal to 1)
* **mean(last half) - mean(first half)** -- intended to verify that noise is not time-trending (ideally equal to 0)

These values were calculated for each posterior sample and were summarized as the posterior mean and 95% CRI.
They are shown at the top left of each time series plot and summarized across processes in the "Summary Tables" sections.
`r if (params$include_sim_years) "**Although the time series plots show simulated years beyond the observed period, the across-year summary statistics were calculated only using years that have been monitored for at least one population.**"`

## Process Model Noise Terms {.tabset .tabset-pills}

```{r plot-proc-resid-fn}

# function to plot a residual time series for one pop/origin/LH_type/age combo
# returns a data frame with identifiers and across-year summary statistics
plot_proc_resid = function(resid_param, sig_param, year = ts_yrs, pop = NULL, origin = NULL, LH_type = NULL, age = NULL, main = NULL) {
  
  # extract posterior samples of residual time series
  resid_post = post_subset(post, sub_index(resid_param, year = year, pop = pop, origin = origin, LH_type = LH_type, age = age), matrix = TRUE)
  
  # extract posterior samples of st. dev. parameter
  sig_post = post_subset(post, sub_index(sig_param, year = year, pop = pop, origin = origin, LH_type = LH_type, age = age), matrix = TRUE)
  
  # divide each residual by its estimated SD parameterize: to standardize
  resid_post = apply(resid_post, 2, function(x) x/sig_post)
  
  # extract the year indices available
  y_ind = get_yr_index(colnames(resid_post))
  y_ind_obs = y_ind %in% observable
  
  # calculate posterior across-year mean and sd for each posterior sample
  # only for years that are observable; don't want to include any simulated years in these stats
  mn_post = apply(resid_post[,y_ind_obs], 1, mean)
  sd_post = apply(resid_post[,y_ind_obs], 1, sd)
  
  # calculate posterior mean(last half of years) - mean(first half of years)
  y_first = 1:round(length(y_ind[y_ind_obs])/2)
  y_last = (max(y_first) + 1):length(y_ind[y_ind_obs])
  mn_post_first = apply(resid_post[,y_first], 1, mean)
  mn_post_last = apply(resid_post[,y_last], 1, mean)
  first_last_mn_diff_post = mn_post_last - mn_post_first
  
  # calculate posterior summaries of standardized residual time series
  resid = apply(resid_post, 2, function(x) c(mean = mean(x), sd = sd(x), quantile(x, c(0.5, 0.025, 0.975))))
  
  # set the y-axis limits: want zero in center and leave room at top for legend
  ylim = max(abs(c(resid["2.5%",], resid["97.5%",])), na.rm = TRUE) * c(-1.4,1.4)
  
  # blank plot with correct dimensions
  par(lend = "square")
  plot(resid["mean",] ~ all_yrs[y_ind], main = main, type = "n",
       ylim = ylim, xlim = range(all_yrs[y_ind]), xaxt = "n", xlab = "", ylab = "")
  
  # draw x-axis: years
  at_x = seq(min(all_yrs[y_ind]), max(all_yrs[y_ind]), 4)
  axis(side = 1, at = at_x, labels = paste0("'", substr(at_x, 3, 4)))
  
  # draw the noise time series: mean and 95% CRI
  polygon(x = c(all_yrs[y_ind], rev(all_yrs[y_ind])),
          y = c(resid["2.5%",], rev(resid["97.5%",])),
          border = NA, col = alpha("salmon", 0.5))
  lines(resid["mean",] ~ all_yrs[y_ind], lwd = 2, col = "red")
  lines(resid["2.5%",] ~ all_yrs[y_ind], lty = 2, col = "red")
  lines(resid["97.5%",] ~ all_yrs[y_ind], lty = 2, col = "red")
  
  # draw reference line at zero noise
  abline(h = 0, lty = 2, col = "black", lwd = 2)
  
  # draw posterior mean for first and half of time series
  lines(x = all_yrs[y_ind[y_first]], y = rep(mean(mn_post_first), length(y_first)), col = "blue", lty = 3, lwd = 2)
  lines(x = all_yrs[y_ind[y_last]], y = rep(mean(mn_post_last), length(y_last)), col = "blue", lty = 3, lwd = 2)
  
  # draw legend that shows estimate summaries
  usr = par("usr"); xdiff = diff(usr[1:2]); ydiff = diff(usr[3:4])
  legend(x = usr[1] - xdiff * 0.05, y = usr[4] + ydiff * 0.01, legend = make_legend_text(mn_post, sd_post, first_last_mn_diff_post), bty = "n", cex = 0.8)
  
  # create output for building summary tables
  data.frame(param = resid_param,
             pop = ifelse(!is.null(pop), pop, NA),
             origin = ifelse(!is.null(origin), origin, NA),
             LH_type = ifelse(!is.null(LH_type), LH_type, NA),
             age = ifelse(!is.null(age), age, NA),
             n_yrs = ncol(resid_post[,y_ind %in% observable]),
             year_mean_mean = mean(mn_post),
             year_mean_lwr = unname(quantile(mn_post, 0.025)),
             year_mean_upr = unname(quantile(mn_post, 0.975)),
             year_sd_mean = mean(sd_post),
             year_sd_lwr = unname(quantile(sd_post, 0.025)),
             year_sd_upr = unname(quantile(sd_post, 0.975)),
             diff_mean = mean(first_last_mn_diff_post), 
             diff_lwr = unname(quantile(first_last_mn_diff_post, 0.025)), 
             diff_upr = unname(quantile(first_last_mn_diff_post, 0.975))
             )
  
}

# container for across-year summary statistics
# is rbinded many times for each random process and pop/origin/LH_type/age combo
proc_error_ests = NULL
```

### FW Juvenile {.tabset .tabset-pills}

#### Egg-to-Parr Survival

```{r egg-to-parr-noise, fig.width = 6, fig.height = 5}
my_par()
tmp = lapply(1:jags_data$nj, function(j) plot_proc_resid("Lphi_E_Pb_resid[year,pop]", "sig_Lphi_E_Pb[pop]", pop = j, main = pops[j]))
oma_labels("Brood Year", "logit(Egg-to-Parr Survival) Residual")
proc_error_ests = rbind(proc_error_ests, do.call(rbind, tmp))
```

#### Summer Parr Mean Length

```{r summer-length-noise, fig.width = 6, fig.height = 5}
my_par()
tmp = lapply(1:jags_data$nj, function(j) plot_proc_resid("lL_Pb_resid[year,pop]", "sig_lL_Pb[pop]", pop = j, main = pops[j]))
oma_labels("Brood Year", "log(Summer Parr Mean Length) Residual")
proc_error_ests = rbind(proc_error_ests, do.call(rbind, tmp))
```

#### Migratory Strategy Apportionment

```{r pi-noise, fig.width = 6, fig.height = 5}
my_par()
tmp = lapply(1:jags_data$nj, function(j) plot_proc_resid("Lpi_resid[year,pop]", "sig_Lpi[pop]", pop = j, main = pops[j]))
oma_labels("Brood Year", "logit(Proportion Fall Migrants) Residual")
proc_error_ests = rbind(proc_error_ests, do.call(rbind, tmp))
```

#### Over-winter Survival {.tabset .tabset-pills}

##### Fall Migrants

```{r overwinter-surv-noise-fall, fig.width = 6, fig.height = 5}
my_par()
tmp = lapply(1:jags_data$nj, function(j) plot_proc_resid("Lphi_Pa_Mb_resid[year,LH_type,pop]", "sig_Lphi_Pa_Mb[pop,LH_type]", pop = j, LH_type = 1, main = pops[j]))
oma_labels("Brood Year", "logit(Over-winter Survival [Fall Migrants]) Residual")
proc_error_ests = rbind(proc_error_ests, do.call(rbind, tmp))
```

##### Spring Migrants

```{r overwinter-surv-noise-spring, fig.width = 6, fig.height = 5}
my_par()
tmp = lapply(1:jags_data$nj, function(j) plot_proc_resid("Lphi_Pa_Mb_resid[year,LH_type,pop]", "sig_Lphi_Pa_Mb[pop,LH_type]", pop = j, LH_type = 2, main = pops[j]))
oma_labels("Brood Year", "logit(Over-winter Survival [Spring Migrants]) Residual")
proc_error_ests = rbind(proc_error_ests, do.call(rbind, tmp))
```

#### Summer Parr to Spring Smolt Growth

```{r growth-noise, fig.width = 6, fig.height = 5}
my_par()
tmp = lapply(1:jags_data$nj, function(j) plot_proc_resid("lgrowth_resid[year,pop]", "sig_lgrowth[pop]", pop = j, main = pops[j]))
oma_labels("Brood Year", "log(Summer to Spring Growth) Residual")
proc_error_ests = rbind(proc_error_ests, do.call(rbind, tmp))
```

#### Trib to LGR {.tabset .tabset-pills}

##### NOR

```{r trib-to-LGR-surv-nor, fig.width = 6, fig.height = 5}
my_par()
tmp = lapply(1:jags_data$nj, function(j) plot_proc_resid("Lphi_Mb_Ma_resid[year,origin,pop]", "sig_Lphi_Mb_Ma[pop,origin]", pop = j, origin = 1, main = pops[j]))
oma_labels("Brood Year", "logit(Trib to LGR Survival [NOR]) Residual")
proc_error_ests = rbind(proc_error_ests, do.call(rbind, tmp))
```

##### HOR

```{r trib-to-LGR-surv-hor, fig.width = 6, fig.height = 5}
my_par()
tmp = lapply(1:jags_data$nj, function(j) plot_proc_resid("Lphi_Mb_Ma_resid[year,origin,pop]", "sig_Lphi_Mb_Ma[pop,origin]", pop = j, origin = 2, main = pops[j]))
oma_labels("Brood Year", "logit(Trib to LGR Survival [HOR]) Residual")
proc_error_ests = rbind(proc_error_ests, do.call(rbind, tmp))
```

#### LGR to BON Survival

```{r LGR-to-BON-surv-noise, fig.width = 7, fig.height = 4}
my_par(); par(mfrow = c(1,2))
tmp = lapply(1:jags_data$no, function(o) plot_proc_resid("Lphi_Ma_O0_resid[year,origin]", "sig_Lphi_Ma_O0[origin]", origin = o, main = origins[o]))
oma_labels("Brood Year", "logit(LGR to Ocean Survival) Residual")
proc_error_ests = rbind(proc_error_ests, do.call(rbind, tmp))
```

### SW Juvenile {.tabset .tabset-pills}

#### Yr1 Ocean Survival

```{r yr1-ocean-surv-noise, fig.width = 6, fig.height = 5}
my_par()
tmp = lapply(1:jags_data$nj, function(j) plot_proc_resid("Lphi_O0_O1_resid[year,origin,pop]", "sig_Lphi_O0_O1[pop]", origin = 1, year = c(1, ts_yrs), pop = j, main = pops[j]))
oma_labels("Brood Year", "logit(First Year Ocean Survival) Residual")
proc_error_ests = rbind(proc_error_ests, do.call(rbind, tmp))
```

#### Pr(Mature at age-3) {.tabset .tabset-pills}

##### NOR

```{r pr-mat-3-nor-noise, fig.width = 6, fig.height = 5}
my_par()
tmp = lapply(1:jags_data$nj, function(j) plot_proc_resid("Lpsi_O1_resid[year,origin,pop]", "sig_Lpsi_O1[pop,origin]", origin = 1, pop = j, main = pops[j]))
oma_labels("Brood Year", "logit(Mature at Age-3 [NOR]) Residual")
proc_error_ests = rbind(proc_error_ests, do.call(rbind, tmp))
```

##### HOR

```{r pr-mat-3-hor-noise, fig.width = 6, fig.height = 5}
my_par()
tmp = lapply(1:jags_data$nj, function(j) plot_proc_resid("Lpsi_O1_resid[year,origin,pop]", "sig_Lpsi_O1[pop,origin]", origin = 2, pop = j, main = pops[j]))
oma_labels("Brood Year", "logit(Mature at Age-3 [HOR]) Residual")
proc_error_ests = rbind(proc_error_ests, do.call(rbind, tmp))
```

#### Pr(Mature at age-4) {.tabset .tabset-pills}

##### NOR

```{r pr-mat-4-nor-noise, fig.width = 6, fig.height = 5}
my_par()
tmp = lapply(1:jags_data$nj, function(j) plot_proc_resid("Lpsi_O2_resid[year,origin,pop]", "sig_Lpsi_O2[pop,origin]", origin = 1, pop = j, main = pops[j]))
oma_labels("Brood Year", "logit(Mature at Age-4 [NOR]) Residual")
proc_error_ests = rbind(proc_error_ests, do.call(rbind, tmp))
```

##### HOR

```{r pr-mat-4-hor-noise, fig.width = 6, fig.height = 5}
my_par()
tmp = lapply(1:jags_data$nj, function(j) plot_proc_resid("Lpsi_O2_resid[year,origin,pop]", "sig_Lpsi_O2[pop,origin]", origin = 2, pop = j, main = pops[j]))
oma_labels("Brood Year", "logit(Mature at Age-4 [HOR]) Residual")
proc_error_ests = rbind(proc_error_ests, do.call(rbind, tmp))
```

### FW Adult {.tabset .tabset-pills}

#### BON to LGR Survival

```{r BON-to-LGR-surv-noise, fig.width = 7, fig.height = 4}
my_par(); par(mfrow = c(1,2))
tmp = lapply(1:jags_data$no, function(o) plot_proc_resid("Lphi_Rb_Ra_resid[year,origin]", "sig_Lphi_Rb_Ra[origin]", origin = o, main = origins[o]))
oma_labels("Return Year", "logit(BON to LGR Survival) Residual")
proc_error_ests = rbind(proc_error_ests, do.call(rbind, tmp))
```

#### Pre-spawn Survival

```{r prespawn-surv-noise, fig.width = 6, fig.height = 5}
my_par()
tmp = lapply(1:jags_data$nj, function(j) plot_proc_resid("Lphi_Sb_Sa_resid[year,pop]", "sig_Lphi_Sb_Sa[pop]", pop = j, main = pops[j]))
oma_labels("Return Year", "logit(Pre-spawn Survival) Residual")
proc_error_ests = rbind(proc_error_ests, do.call(rbind, tmp))
```

### **SUMMARY TABLES** {.tabset .tabset-pills}

These tables show posterior summary statistics of the time series of noise terms across years (i.e., the values shown on each figure panel).
Bold values denote that the target value for verifying model assumptions was not within the 95% CRI of the across-year summary statistic and indicates a potential problem.

```{r proc-error-table-prep}
# rename parameters to human-readable format
proc_error_ests$param = stringr::str_replace(proc_error_ests$param, "Lphi_E_Pb_resid\\[year,pop\\]", "Egg to Parr Survival")
proc_error_ests$param = stringr::str_replace(proc_error_ests$param, "lL_Pb_resid\\[year,pop\\]", "Summer Parr Length")
proc_error_ests$param = stringr::str_replace(proc_error_ests$param, "Lpi_resid\\[year,pop\\]", "Migratory Strategy Apportionment")
proc_error_ests$param = stringr::str_replace(proc_error_ests$param, "Lphi_Pa_Mb_resid\\[year,LH_type,pop\\]", "Overwinter Survival")
proc_error_ests$param = stringr::str_replace(proc_error_ests$param, "lgrowth_resid\\[year,pop\\]", "Summer to Spring Growth")
proc_error_ests$param = stringr::str_replace(proc_error_ests$param, "Lphi_Mb_Ma_resid\\[year,origin,pop\\]", "Trib to LGR Survival")
proc_error_ests$param = stringr::str_replace(proc_error_ests$param, "Lphi_Ma_O0_resid\\[year,origin\\]", "LGR to BON Survival")
proc_error_ests$param = stringr::str_replace(proc_error_ests$param, "Lphi_O0_O1_resid\\[year,origin,pop\\]", "Yr1 Ocean Survival")
proc_error_ests$param = stringr::str_replace(proc_error_ests$param, "Lpsi_O1_resid\\[year,origin,pop\\]", "Pr(Mature Age-3)")
proc_error_ests$param = stringr::str_replace(proc_error_ests$param, "Lpsi_O2_resid\\[year,origin,pop\\]", "Pr(Mature Age-4)")
proc_error_ests$param = stringr::str_replace(proc_error_ests$param, "Lphi_Rb_Ra_resid\\[year,origin\\]", "BON to LGR Survival")
proc_error_ests$param = stringr::str_replace(proc_error_ests$param, "Lphi_Sb_Sa_resid\\[year,pop\\]", "Pre-spawn Survival")

# correct origin indices
proc_error_ests$origin[proc_error_ests$param == "Pre-spawn Survival"] = 3
proc_error_ests$origin[is.na(proc_error_ests$origin)] = 1

# correct LH_type indices
proc_error_ests$LH_type[is.na(proc_error_ests$LH_type)] = 3

# correct pop indices
proc_error_ests$pop[is.na(proc_error_ests$pop)] = 5

# remove the age column
proc_error_ests = proc_error_ests[,-which(colnames(proc_error_ests) == "age")]

# replace indices with names
proc_error_ests$pop = c("CAT", "LOS", "MIN", "UGR", "Combined")[proc_error_ests$pop]
proc_error_ests$origin = c("NOR", "HOR", "Combined")[proc_error_ests$origin]
proc_error_ests$LH_type = c("Fall Mig.", "Spring Mig.", "Combined")[proc_error_ests$LH_type]

# which processes are in each life phase?
fw_juv = c("Egg to Parr Survival", "Summer Parr Length", "Migratory Strategy Apportionment", "Overwinter Survival", "Summer to Spring Growth", "Trib to LGR Survival", "LGR to BON Survival")
sw_juv = c("Yr1 Ocean Survival", "Pr(Mature Age-3)", "Pr(Mature Age-4)")
fw_adult = c("BON to LGR Survival", "Pre-spawn Survival")

# add a life phase column
proc_error_ests$phase = NA
proc_error_ests$phase = ifelse(proc_error_ests$param %in% fw_juv, 1, proc_error_ests$phase)
proc_error_ests$phase = ifelse(proc_error_ests$param %in% sw_juv, 2, proc_error_ests$phase)
proc_error_ests$phase = ifelse(proc_error_ests$param %in% fw_adult, 3, proc_error_ests$phase)
proc_error_ests$phase = c("FW Juvenile", "SW Juvenile", "FW Adult")[proc_error_ests$phase]

# add levels to each variable
proc_error_ests$phase = factor(proc_error_ests$phase, levels = c("FW Juvenile", "SW Juvenile", "FW Adult"))
proc_error_ests$param = factor(proc_error_ests$param, levels = c(fw_juv, sw_juv, fw_adult))
proc_error_ests$origin = factor(proc_error_ests$origin, levels = c("NOR", "HOR", "Combined"))
proc_error_ests$LH_type = factor(proc_error_ests$LH_type, levels = c("Fall Mig.", "Spring Mig.", "Combined"))
proc_error_ests$pop = factor(proc_error_ests$pop, levels = c("CAT", "LOS", "MIN", "UGR", "Combined"))

# determine whether posterior of across-year quantities overlaps the target value
proc_error_ests$yr_mean_incl_zero = ifelse(proc_error_ests$year_mean_lwr <= 0 & proc_error_ests$year_mean_upr >= 0, TRUE, FALSE)
proc_error_ests$yr_sd_incl_one = ifelse(proc_error_ests$year_sd_lwr <= 1 & proc_error_ests$year_sd_upr >= 1, TRUE, FALSE)
proc_error_ests$diff_incl_zero = ifelse(proc_error_ests$diff_lwr <= 0 & proc_error_ests$diff_upr >= 0, TRUE, FALSE)

# format the mean values to present in table
# round and make bold if target value not in interval
proc_error_ests$year_mean_mean = round(proc_error_ests$year_mean_mean, 2)
proc_error_ests$year_mean_mean = ifelse(!proc_error_ests$yr_mean_incl_zero, paste0("<b>", proc_error_ests$year_mean_mean, "</b>"), proc_error_ests$year_mean_mean)
proc_error_ests$year_sd_mean = round(proc_error_ests$year_sd_mean, 2)
proc_error_ests$year_sd_mean = ifelse(!proc_error_ests$yr_sd_incl_one, paste0("<b>", proc_error_ests$year_sd_mean, "</b>"), proc_error_ests$year_sd_mean)
proc_error_ests$diff_mean = round(proc_error_ests$diff_mean, 2)
proc_error_ests$diff_mean = ifelse(!proc_error_ests$diff_incl_zero, paste0("<b>", proc_error_ests$diff_mean, "</b>"), proc_error_ests$diff_mean)

# drop unneeded columns
proc_error_ests = proc_error_ests[,c("phase", "param", "pop", "origin", "LH_type","year_mean_mean", "year_sd_mean", "diff_mean")]
```

```{r proc-error-table-fn}
proc_error_table = function(var) {
  out = reshape2::dcast(proc_error_ests, phase + param + origin + LH_type ~ pop, value.var = var)
  out[is.na(out)] = ""

  knitr::kable(out, "html", col.names = c("Life Phase", "Process", "Origin", "Migratory Type", "CAT", "LOS", "MIN", "UGR", "Combined"), escape = FALSE, align = "llllccccc") %>%
    kableExtra::kable_styling(full_width = FALSE, bootstrap_options = c("condensed")) %>%
    collapse_rows(columns = 1:4)
}
```

#### Across-Year Mean

The posterior mean of the mean noise value across all years; bold indicates the 95% CRI did not encompass 0.

Values:

* Close to 0 indicate that the time series of noise terms was not biased relative to the expected value (i.e., assumption met)
* Below 0 indicate that the time series of noise terms was biased low relative to the expected value
* Above 0 indicate that the time series of noise terms was biased high relative the expected value

```{r proc-error-mean-table}
proc_error_table("year_mean_mean")
```

#### Across-Year SD

The posterior mean of the SD of noise value across all years; bold indicates the 95% CRI did not encompass 1 (all noise terms were standardized). 

Values:

* Close to 1 indicate that the time series of noise terms was as variable as expected (i.e., assumption met)
* Below 1 indicate that the time series of noise terms was less variable than expected
* Above 1 indicate that the time series of noise terms was more variable than expected

```{r proc-error-sd-table}
proc_error_table("year_sd_mean")
```

#### Last Half Mean - First Half Mean

The posterior mean of `mean(noise term in last half of years) - mean(noise term in first half of years)`; bold indicates the 95% CRI did not encompass 0. 

Values:

* Close to 0 indicate a lack of an overall time trend (i.e., assumption met)
* Below 0 indicate an overall declining time trend in noise terms
* Above 0 indicate an overall increasing time trend in noise terms

```{r proc-error-diff-table}
proc_error_table("diff_mean")
```

## Observation Model Noise Terms {.tabset .tabset-pills}

```{r plot-obs-resid-fn}

obs_resid_yrs = all_yrs[c(1,observable)]

# function to plot a residual time series for one pop/origin/LH_type/age combo
# returns a data frame with identifiers and across-year summary statistics
plot_obs_resid = function(resid_param, year = ".+", pop = NULL, origin = NULL, LH_type = NULL, age = NULL, main = NULL) {
  
  # extract posterior samples of residual time series
  resid_post = post_subset(post, sub_index(resid_param, year = year, pop = pop, origin = origin, LH_type = LH_type, age = age), matrix = TRUE)
  
  # extract the year indices available
  y_ind = get_yr_index(colnames(resid_post))
  
  # calculate posterior across-year mean and sd for each posterior sample
  mn_post = apply(resid_post, 1, mean)
  sd_post = apply(resid_post, 1, sd)
  
  # calculate posterior summaries of residual time series
  resid = apply(resid_post, 2, function(x) c(mean = mean(x), sd = sd(x), quantile(x, c(0.5, 0.025, 0.975))))
  
  # place residuals at correct place in a time series
  # ie., insert missing values
  empty = matrix(NA, nrow = 5, ncol = length(obs_resid_yrs))
  empty[,y_ind] = resid
  resid = empty[,observable]
  rownames(resid) = c("mean", "sd", "50%", "2.5%", "97.5%")
  empty_names = rep(NA, length(obs_resid_yrs))
  empty_names[y_ind] = colnames(resid_post)
  
  # calculate posterior mean(last half of years) - mean(first half of years)
  y_first = 1:round(length(observable)/2)
  y_last = (max(y_first) + 1):length(observable)
  i_first = as.character(na.omit(empty_names[y_first]))
  i_last = as.character(na.omit(empty_names[y_last]))
  mn_post_first = apply(resid_post[,i_first], 1, mean)
  mn_post_last = apply(resid_post[,i_last], 1, mean)
  first_last_mn_diff_post = mn_post_last - mn_post_first

  # set the y-axis limits: want zero in center and leave room at top for legend
  ylim = max(abs(c(resid["2.5%",], resid["97.5%",])), na.rm = TRUE) * c(-1.4,1.4)
  
  # blank plot with correct dimensions
  par(lend = "square")
  plot(resid["mean",] ~ all_yrs[observable], main = main,  type = "n", ylim = ylim, xlim = range(all_yrs[observable]), xaxt = "n", xlab = "", ylab = "")
  
  # draw x-axis: years
  at_x = seq(min(all_yrs[observable]), max(all_yrs[observable]), 4)
  axis(side = 1, at = at_x, labels = paste0("'", substr(at_x, 3, 4)))

  # draw the noise time series: mean and 95% CRI
  segments(all_yrs[observable], resid["2.5%",], all_yrs[observable], resid["97.5%",], col = "red")
  points(resid["mean",] ~ all_yrs[observable], pch = 21, col = "red", bg = alpha("salmon", 0.5), cex = 1.2)
  
  # draw reference line at zero noise
  abline(h = 0, lty = 2, col = "black", lwd = 2)
  
  # draw posterior mean for first and half of time series
  lines(x = all_yrs[observable[y_first]], y = rep(mean(mn_post_first), length(y_first)), col = "blue", lty = 3, lwd = 2)
  lines(x = all_yrs[observable[y_last]], y = rep(mean(mn_post_last), length(y_last)), col = "blue", lty = 3, lwd = 2)
  
  # draw legend that shows estimate summaries
  usr = par("usr"); xdiff = diff(usr[1:2]); ydiff = diff(usr[3:4])
  legend(x = usr[1] - xdiff * 0.05, y = usr[4] + ydiff * 0.01, legend = make_legend_text(mn_post, sd_post, first_last_mn_diff_post), bty = "n", cex = 0.8)
  
  # create output for building summary tables
  data.frame(param = resid_param,
             pop = ifelse(!is.null(pop), pop, NA),
             origin = ifelse(!is.null(origin), origin, NA),
             LH_type = ifelse(!is.null(LH_type), LH_type, NA),
             age = ifelse(!is.null(age), age, NA),
             n_yrs = ncol(resid_post[,y_ind %in% observable]),
             year_mean_mean = mean(mn_post),
             year_mean_lwr = unname(quantile(mn_post, 0.025)),
             year_mean_upr = unname(quantile(mn_post, 0.975)),
             year_sd_mean = mean(sd_post),
             year_sd_lwr = unname(quantile(sd_post, 0.025)),
             year_sd_upr = unname(quantile(sd_post, 0.975)),
             diff_mean = mean(first_last_mn_diff_post), 
             diff_lwr = unname(quantile(first_last_mn_diff_post, 0.025)), 
             diff_upr = unname(quantile(first_last_mn_diff_post, 0.975))
  )
}

# container for across-year summary statistics
# is rbinded many times for each random process and pop/origin/LH_type/age combo
obs_error_ests = NULL
```

### Abundance Data {.tabset .tabset-pills}

#### Fall Parr Abundance

```{r fall-trap-resid, fig.width = 6, fig.height = 5}
my_par()
tmp = lapply(1:jags_data$nj, function(j) plot_obs_resid("lPa_obs_resid[year,LH_type,pop]", LH_type = 1, pop = j, main = pops[j]))
oma_labels("Brood Year", "log(Fall Parr Abundance) Residual")
obs_error_ests = rbind(obs_error_ests, do.call(rbind, tmp))
```

#### Spring Smolt Abundance

```{r spring-trap-resid, fig.width = 6, fig.height = 5}
my_par()
tmp = lapply(1:jags_data$nj, function(j) plot_obs_resid("lMb_obs_resid[year,LH_type,origin,pop]", LH_type = 2, origin = 1, pop = j, main = pops[j]))
oma_labels("Brood Year", "log(Spring Trap Count) Residual")
obs_error_ests = rbind(obs_error_ests, do.call(rbind, tmp))
```

#### Adult Return Abundance

```{r adult-resid, fig.width = 6, fig.height = 5}
my_par()
tmp = lapply(1:jags_data$nj, function(j) plot_obs_resid("lRa_obs_resid[year,pop]", pop = j, main = pops[j]))
oma_labels("Return Year", "log(Total Adult Count) Residual")
obs_error_ests = rbind(obs_error_ests, do.call(rbind, tmp))
```

### Survival Data {.tabset .tabset-pills}

#### Summer Parr $\rightarrow$ LGR

```{r summer-surv-resid, fig.width = 6, fig.height = 5}
my_par()
tmp = lapply(1:jags_data$nj, function(j) plot_obs_resid("Lphi_obs_Pb_Ma_resid[year,pop]", pop = j, main = pops[j]))
oma_labels("Brood Year", "logit(Summer Tagging to LGR Survival) Residual")
obs_error_ests = rbind(obs_error_ests, do.call(rbind, tmp))
```

#### Fall Parr $\rightarrow$ LGR

```{r fall-surv-resid, fig.width = 6, fig.height = 5}
my_par()
tmp = lapply(1:jags_data$nj, function(j) plot_obs_resid("Lphi_obs_Pa_Ma_resid[year,LH_type,pop]", LH_type = 1, pop = j, main = pops[j]))
oma_labels("Brood Year", "logit(Fall Tagging to LGR Survival) Residual")
obs_error_ests = rbind(obs_error_ests, do.call(rbind, tmp))
```

#### Winter Parr $\rightarrow$ LGR

```{r winter-surv-resid, fig.width = 6, fig.height = 5}
my_par()
tmp = lapply(1:jags_data$nj, function(j) {
  if (j == 3) {
    no_data_plot(main = pops[j])
  } else {
    plot_obs_resid("Lphi_obs_Pa_Ma_resid[year,LH_type,pop]", LH_type = 2, pop = j, main = pops[j])
  }
})
oma_labels("Brood Year", "logit(Winter Tagging to LGR Survival) Residual")
obs_error_ests = rbind(obs_error_ests, do.call(rbind, tmp))
```

#### Spring Smolt $\rightarrow$ LGR (NOR)

```{r spring-surv-resid-nor, fig.width = 6, fig.height = 5}
my_par()
tmp = lapply(1:jags_data$nj, function(j) plot_obs_resid("Lphi_obs_Mb_Ma_resid[year,LH_type,origin,pop]", LH_type = 2, pop = j, origin = 1, main = pops[j]))
oma_labels("Brood Year", "logit(NOR Smolt to LGR Survival) Residual")
obs_error_ests = rbind(obs_error_ests, do.call(rbind, tmp))
```

#### Spring Smolt $\rightarrow$ LGR (HOR)

```{r spring-surv-resid-hor, fig.width = 6, fig.height = 5}
my_par()
tmp = lapply(1:jags_data$nj, function(j) {
  if (j == 3) {
    no_data_plot(main = pops[j])
  } else {
    plot_obs_resid("Lphi_obs_Mb_Ma_resid[year,LH_type,origin,pop]", LH_type = 2, pop = j, origin = 2, main = pops[j])
  }
})
oma_labels("Brood Year", "logit(HOR Smolt to LGR Survival) Residual")
obs_error_ests = rbind(obs_error_ests, do.call(rbind, tmp))
```

#### LGR Smolt $\rightarrow$ Ocean

```{r hydro-surv-resid, fig.width = 7, fig.height = 4}
my_par(); par(mfrow = c(1,2))
tmp = lapply(1:jags_data$no, function(o) plot_obs_resid("Lphi_obs_Ma_O0_resid[year,origin]", origin = o, main = origins[o]))
oma_labels("Brood Year", "logit(LGR to Ocean Survival) Residual")
obs_error_ests = rbind(obs_error_ests, do.call(rbind, tmp))
```

#### BON Adults $\rightarrow$ LGR

```{r bon-adult-surv-resid, fig.width = 7, fig.height = 4}
my_par(); par(mfrow = c(1,2))
tmp = lapply(1:jags_data$no, function(o) plot_obs_resid("x_LGR_obs_resid[year,origin]", origin = o, main = origins[o]))
oma_labels("Return Year", "Count of PIT Tagged Adults at LGR Residual")
obs_error_ests = rbind(obs_error_ests, do.call(rbind, tmp))
```

#### Pre-spawn

```{r pre-spawn-surv-resid, fig.width = 6, fig.height = 5}
my_par()
tmp = lapply(1:jags_data$nj, function(j) plot_obs_resid("x_carcass_spawned_obs_resid[year,pop]", pop = j, main = pops[j]))
oma_labels("Return Year", "Count of Female Spawned-out Carcasses Residual")
obs_error_ests = rbind(obs_error_ests, do.call(rbind, tmp))
```

### Length Data {.tabset .tabset-pills}

#### Summer Length

```{r summer-length-resid, fig.width = 6, fig.height = 5}
my_par()
tmp = lapply(1:jags_data$nj, function(j) plot_obs_resid("lL_Pb_obs_resid[year,pop]", pop = j, main = pops[j]))
oma_labels("Brood Year", "log(Mean Summer Length) Residual")
obs_error_ests = rbind(obs_error_ests, do.call(rbind, tmp))
```

#### Spring Length

```{r spring-length-resid, fig.width = 6, fig.height = 5}
my_par()
tmp = lapply(1:jags_data$nj, function(j) plot_obs_resid("lL_Mb_obs_resid[year,pop]", pop = j, main = pops[j]))
oma_labels("Brood Year", "log(Mean Spring Length) Residual")
obs_error_ests = rbind(obs_error_ests, do.call(rbind, tmp))
```

### Composition Data {.tabset .tabset-pills}

#### Weir Sampling {.tabset .tabset-pills}

```{r weir-comp-resid-plots-fn}
ko_names = c("Age-3 (NOR)", "Age-4 (NOR)", "Age-5 (NOR)",
             "Age-3 (HOR)", "Age-4 (HOR)", "Age-5 (HOR)")

weir_comp_resid_plots = function(j) {
  my_par(); par(mfrow = c(2,3))
  tmp = lapply(1:jags_data$nko, function(ko) plot_obs_resid("x_Ra_obs_resid[year,age,pop]", year = unname(which(jags_data$nx_Ra[,j] > 0)), age = ko, main = ko_names[ko], pop = j))
  oma_labels("Return Year", "Weir Age/Origin Composition Residual")
  do.call(rbind, tmp)
}
```

##### CAT

```{r cat-weir-comp-resids, fig.width = 8, fig.height = 5}
tmp = weir_comp_resid_plots(j_cat)
obs_error_ests = rbind(obs_error_ests, tmp)
```

##### LOS

```{r los-weir-comp-resids, fig.width = 8, fig.height = 5}
tmp = weir_comp_resid_plots(j_los)
obs_error_ests = rbind(obs_error_ests, tmp)
```

##### MIN

_No weir data for MIN_

##### UGR

```{r ugr-weir-comp-resids, fig.width = 8, fig.height = 5}
tmp = weir_comp_resid_plots(j_ugr)
obs_error_ests = rbind(obs_error_ests, tmp)
```

#### Carcass Sampling {.tabset .tabset-pills}

```{r carcass-comp-resid-plots-fn}
carcass_comp_resid_plots = function(j) {
  my_par(); par(mfrow = c(2,3))
  tmp = lapply(1:jags_data$nko, function(ko) plot_obs_resid("x_Sa_prime_obs_resid[year,age,pop]", year = unname(which(jags_data$nx_Sa_prime[,j] > 0)), age = ko, main = ko_names[ko], pop = j))
  oma_labels("Return Year", "Carcass Age/Origin Composition Residual")
  do.call(rbind, tmp)
}
```

##### CAT

```{r cat-carcass-comp-resids, fig.width = 8, fig.height = 5}
tmp = carcass_comp_resid_plots(j_cat)
obs_error_ests = rbind(obs_error_ests, tmp)
```

##### LOS

```{r los-carcas-comp-resids, fig.width = 8, fig.height = 5}
tmp = carcass_comp_resid_plots(j_los)
obs_error_ests = rbind(obs_error_ests, tmp)
```

##### MIN

```{r min-carcas-comp-resids, fig.width = 8, fig.height = 5}
tmp = carcass_comp_resid_plots(j_min)
obs_error_ests = rbind(obs_error_ests, tmp)
```

##### UGR

```{r ugr-carcass-comp-resids, fig.width = 8, fig.height = 5}
tmp = carcass_comp_resid_plots(j_ugr)
obs_error_ests = rbind(obs_error_ests, tmp)
```

### **SUMMARY TABLES** {.tabset .tabset-pills}

These tables show posterior summary statistics of the time series of noise terms across years (i.e., the values shown on each figure panel).
Bold values denote that the target value for verifying model assumptions was not within the 95% CRI of the across-year summary statistic and indicates a potential problem.

```{r obs-error-table-prep}
# rename parameters to human-readable format
obs_error_ests$param = stringr::str_replace(obs_error_ests$param, "lPa_obs_resid\\[year,LH_type,pop\\]", "Fall Screw Trap")
obs_error_ests$param = stringr::str_replace(obs_error_ests$param, "lMb_obs_resid\\[year,LH_type,origin,pop\\]", "Spring Screw Trap")
obs_error_ests$param = stringr::str_replace(obs_error_ests$param, "lRa_obs_resid\\[year,pop\\]", "Adult Return")
obs_error_ests$param = stringr::str_replace(obs_error_ests$param, "Lphi_obs_Pb_Ma_resid\\[year,pop\\]", "Summer Tagging -> LGR")
obs_error_ests$param = stringr::str_replace(obs_error_ests$param, "Lphi_obs_Pa_Ma_resid\\[year,LH_type,pop\\]", "Fall Tagging -> LGR")
obs_error_ests$param = stringr::str_replace(obs_error_ests$param, "Lphi_obs_Mb_Ma_resid\\[year,LH_type,origin,pop\\]", "Spring Tagging -> LGR")
obs_error_ests$param = stringr::str_replace(obs_error_ests$param, "Lphi_obs_Ma_O0_resid\\[year,origin\\]", "LGR Smolt -> Ocean")
obs_error_ests$param = stringr::str_replace(obs_error_ests$param, "x_LGR_obs_resid\\[year,origin\\]", "BON Adults -> LGR")
obs_error_ests$param = stringr::str_replace(obs_error_ests$param, "x_carcass_spawned_obs_resid\\[year,pop\\]", "Pre-spawn")
obs_error_ests$param = stringr::str_replace(obs_error_ests$param, "lL_Pb_obs_resid\\[year,pop\\]", "Summer Parr")
obs_error_ests$param = stringr::str_replace(obs_error_ests$param, "lL_Mb_obs_resid\\[year,pop\\]", "Spring Smolt")
obs_error_ests$param = stringr::str_replace(obs_error_ests$param, "x_Ra_obs_resid\\[year,age,pop\\]", "Weir")
obs_error_ests$param = stringr::str_replace(obs_error_ests$param, "x_Sa_prime_obs_resid\\[year,age,pop\\]", "Carcass")

# correct parameter names
obs_error_ests$param[obs_error_ests$param == "Fall Tagging -> LGR" & obs_error_ests$LH_type == 2] = "Winter Tagging -> LGR"
obs_error_ests$param[obs_error_ests$param == "Spring Tagging -> LGR" & obs_error_ests$origin == 2] = "Smolt Release -> LGR"
obs_error_ests$origin[obs_error_ests$param == "Fall Screw Trap"] = 1
obs_error_ests$origin[obs_error_ests$param == "Adult Return"] = 3

# correct origin indices
obs_error_ests$origin[stringr::str_detect(obs_error_ests$param, "Tagging")] = 1
obs_error_ests$origin[obs_error_ests$param == "Pre-spawn"] = 3
obs_error_ests$origin[obs_error_ests$param %in% c("Summer Parr", "Spring Smolt")] = 1

# correct LH_type indices
obs_error_ests$LH_type[is.na(obs_error_ests$LH_type)] = 3

# correct pop indices
obs_error_ests$pop[is.na(obs_error_ests$pop)] = 5

# correct origin indices based on age indices
obs_error_ests$origin[obs_error_ests$age %in% c(1,2,3)] = 1
obs_error_ests$origin[obs_error_ests$age %in% c(4,5,6)] = 2

# replace indices with names
obs_error_ests$pop = c("CAT", "LOS", "MIN", "UGR", "Combined")[obs_error_ests$pop]
obs_error_ests$origin = c("NOR", "HOR", "Combined")[obs_error_ests$origin]
obs_error_ests$LH_type = c("Fall Mig.", "Spring Mig.", "Combined")[obs_error_ests$LH_type]
obs_error_ests$age = c("Age-3", "Age-4", "Age-5", "Age-3", "Age-4", "Age-5")[obs_error_ests$age]
obs_error_ests$age[is.na(obs_error_ests$age)] = "Combined"

# add a type column
obs_error_ests$type = NA
obs_error_ests$type = ifelse(obs_error_ests$param %in% c("Fall Screw Trap", "Spring Screw Trap", "Adult Return"), 1, obs_error_ests$type)
obs_error_ests$type = ifelse(stringr::str_detect(obs_error_ests$param, "->"), 2, obs_error_ests$type)
obs_error_ests$type = ifelse(stringr::str_detect(obs_error_ests$param, "Pre-spawn"), 2, obs_error_ests$type)
obs_error_ests$type = ifelse(obs_error_ests$param %in% c("Weir", "Carcass"), 3, obs_error_ests$type)
obs_error_ests$type = ifelse(obs_error_ests$param %in% c("Summer Parr", "Spring Smolt"), 4, obs_error_ests$type)
obs_error_ests$type = c("Abundance", "Survival", "Composition", "Mean Length")[obs_error_ests$type]

# add levels to each variable
obs_error_ests$type = factor(obs_error_ests$type, levels = c("Abundance", "Survival", "Mean Length", "Composition"))
obs_error_ests$param = factor(obs_error_ests$param, levels = c("Fall Screw Trap", "Spring Screw Trap", "Adult Return", "Summer Tagging -> LGR", "Fall Tagging -> LGR", "Winter Tagging -> LGR", "Spring Tagging -> LGR", "Smolt Release -> LGR", "LGR Smolt -> Ocean", "BON Adults -> LGR", "Pre-spawn", "Summer Parr", "Spring Smolt", "Weir", "Carcass"))
obs_error_ests$origin = factor(obs_error_ests$origin, levels = c("NOR", "HOR", "Combined"))
obs_error_ests$LH_type = factor(obs_error_ests$LH_type, levels = c("Fall Mig.", "Spring Mig.", "Combined"))
obs_error_ests$age = factor(obs_error_ests$age, levels = c("Age-3", "Age-4", "Age-5", "Combined"))
obs_error_ests$pop = factor(obs_error_ests$pop, levels = c("CAT", "LOS", "MIN", "UGR", "Combined"))

# determine whether posterior of across-year quantities overlaps the target value
obs_error_ests$yr_mean_incl_zero = ifelse(obs_error_ests$year_mean_lwr <= 0 & obs_error_ests$year_mean_upr >= 0, TRUE, FALSE)
obs_error_ests$yr_sd_incl_one = ifelse(obs_error_ests$year_sd_lwr <= 1 & obs_error_ests$year_sd_upr >= 1, TRUE, FALSE)
obs_error_ests$diff_incl_zero = ifelse(obs_error_ests$diff_lwr <= 0 & obs_error_ests$diff_upr >= 0, TRUE, FALSE)

# format the mean values to present in table
# round and make bold if target value not in interval
obs_error_ests$year_mean_mean = round(obs_error_ests$year_mean_mean, 2)
obs_error_ests$year_mean_mean = ifelse(!obs_error_ests$yr_mean_incl_zero, paste0("<b>", obs_error_ests$year_mean_mean, "</b>"), obs_error_ests$year_mean_mean)
obs_error_ests$year_sd_mean = round(obs_error_ests$year_sd_mean, 2)
obs_error_ests$year_sd_mean = ifelse(!obs_error_ests$yr_sd_incl_one, paste0("<b>", obs_error_ests$year_sd_mean, "</b>"), obs_error_ests$year_sd_mean)
obs_error_ests$diff_mean = round(obs_error_ests$diff_mean, 2)
obs_error_ests$diff_mean = ifelse(!obs_error_ests$diff_incl_zero, paste0("<b>", obs_error_ests$diff_mean, "</b>"), obs_error_ests$diff_mean)

# drop unneeded columns
obs_error_ests = obs_error_ests[,c("type", "param", "pop", "origin", "LH_type", "age", "year_mean_mean", "year_sd_mean", "diff_mean")]
```

```{r obs-error-table-fn}
obs_error_table = function(var) {
  out = reshape2::dcast(obs_error_ests, type + param + origin + LH_type + age ~ pop, value.var = var)
  out[is.na(out)] = ""
  out$param = stringr::str_replace(out$param, "->", "$\\\\rightarrow$")

  knitr::kable(out, "html", col.names = c("Class", "Type", "Origin", "Migratory Type", "Age-of-Maturity", "CAT", "LOS", "MIN", "UGR", "Combined"), escape = FALSE, align = "lllllccccc") %>%
    kableExtra::kable_styling(full_width = FALSE, bootstrap_options = c("condensed")) %>%
    collapse_rows(columns = 1:5)
}
```

#### Across-Year Mean

The posterior mean of the mean noise value across all years; bold indicates the 95% CRI did not encompass 0.

Values:

* Close to 0 indicate that the time series of noise terms was not biased relative to the expected value (i.e., assumption met)
* Below 0 indicate that the time series of noise terms was biased low relative to the expected value
* Above 0 indicate that the time series of noise terms was biased high relative the expected value

```{r obs-error-mean-table}
obs_error_table("year_mean_mean")
```

#### Across-Year SD

The posterior mean of the SD of noise value across all years; bold indicates the 95% CRI did not encompass 1 (all noise terms were standardized). 

Values:

* Close to 1 indicate that the time series of noise terms was as variable as expected (i.e., assumption met)
* Below 1 indicate that the time series of noise terms was less variable than expected
* Above 1 indicate that the time series of noise terms was more variable than expected

```{r obs-error-sd-table}
obs_error_table("year_sd_mean")
```

#### Last Half Mean - First Half Mean

The posterior mean of `mean(noise term in last half of years) - mean(noise term in first half of years)`; bold indicates the 95% CRI did not encompass 0. 

Values:

* Close to 0 indicate a lack of an overall time trend (i.e., assumption met)
* Below 0 indicate an overall declining time trend in noise terms
* Above 0 indicate an overall increasing time trend in noise terms

```{r obs-error-diff-table}
obs_error_table("diff_mean")
```

# JAGS Model and Data {.tabset .tabset-pills}

## JAGS Model Code

```{r jags-model, comment = NA}
# print the JAGS model code
cat(model_info$jags_model_code, sep = "\n")
```

## JAGS Model Data

```{r jags-data, comment = NA}
# print the JAGS model data
model_info$jags_data
```
