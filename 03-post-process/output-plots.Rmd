---
title: "Output Summary"
subtitle: "Multi-Population Model"
output: 
  html_document:
    toc: true
    toc_float: true
params:
  scenario:
    label: "Scenario"
    value: "base"
    input: text
editor_options: 
  chunk_output_type: console
---

```{r directories, include = F}
# set root directory to the project directory: one level up from this location
knitr::opts_knit$set(root.dir = "../")
```

```{r setup, include = FALSE}
# set global knitting options
knitr::opts_chunk$set(echo = FALSE, fig.align = "center")

# load packages
source("00-packages.R")

# load all necessary functions
invisible(sapply(list.files(path = "01-functions", pattern = "\\.R$", full.names = T), source))

# set the input directory
in_dir = "02-model/model-output"

# read information from this model
model_info = readRDS(file.path(in_dir, paste0(params$pop, "output-", params$scenario, ".rds")))

# extract the two key structures from this object
post = model_info$post
jags_data = model_info$jags_data

# the years included by the model
all_yrs = as.numeric(dimnames(jags_data$Pa_obs)[[1]])

# which years are "observable" for at least some quantities?
observable = (jags_data$kmax+1):jags_data$ny
```

```{r dimension-ids}
# population names
pops = colnames(jags_data$Ra_obs)

# dimension IDs
i_fall   = 1  # fall migrants are i = 1
i_spring = 2  # spring migrants are i = 2,
o_nor    = 1  # natural origin are o = 1,
o_hor    = 2  # hatchery origin are o = 2,
s_female = 1  # females are s = 1,
s_male   = 2  # males are s = 2
j_cat    = 1  # Catherine Creek is j = 1
j_los    = 2  # Lostine River is j = 2
j_min    = 3  # Minam River is j = 3
j_ugr    = 4  # Upper Grande Ronde River is j = 4
k_3      = 1  # age 3 is k = 1
k_4      = 2  # age 4 is k = 2
k_5      = 3  # age 5 is k = 3
```

The code used to render this output relies heavily on Staton's 'postpack' package (now available on CRAN). Take a look at [this vignette](https://bstaton1.github.io/postpack/articles/feature-overview.html) for a primer on how to use it.

# MCMC Information {.tabset .tabset-pills}

## Time Information

```{r}
# Calculate hours per 10,000 iterations
hrs_per_ten_thousand_iters = with(model_info$jags_dims, {
  # calculation of total iters differs if parallel or not
  if (parallel) {
    total_iters = n_adapt + n_post + n_burn
  } else {
    total_iters = (n_adapt + n_post + n_burn) * n_chains
  }
  ten_thousands_of_total_iters = total_iters/10000
  
  # calculate hours elapsed
  time_diff = as.POSIXct.default(model_info$jags_time["stoptime"]) - as.POSIXct.default(model_info$jags_time["starttime"])
  time_number = as.numeric(time_diff)
  time_units = attributes(time_diff)$units
  hour_convert = switch(time_units,
                        "secs" = 3600,
                        "mins" = 60,
                        "hours" = 1,
                        "days" = 1/24)
  hours_diff = time_number/hour_convert
  
  # calculate/round rate
  round(hours_diff/ten_thousands_of_total_iters, 2)
})

# combine relevant info into a data frame
df = data.frame(Value = c(model_info$jags_time, ifelse(model_info$jags_dims$parallel, "Yes", "No"), hrs_per_ten_thousand_iters))
rownames(df) = c("Time Started", "Time Ended", "Time Elapsed", "Chains Ran in Parallel?", "Hours Per 10,000 Iterations")

# make a kable for printing in output
kable(df) %>%
  kable_styling(full_width = F, bootstrap_options = "condensed") %>%
  column_spec(1, bold = TRUE)
```

## Attributes

This table shows some dimensions of the MCMC run.

```{r mcmc-dims}
# query the dimensions of the posterior samples
dims = post_dim(post)

# build a data frame for printing
df = data.frame(Quantity = c("Burn-in + Adapt Iters", "Post Burn-in Iters", "Thinning Interval", "Chains", "Saved Iters", "Monitored Quantities"), Value = unname(dims))

# render the table
kable(df, format.args = list(big.mark = ",")) %>%
  kable_styling(full_width = F, bootstrap_options = c("striped", "condensed")) %>%
  column_spec(1, bold = TRUE)
```

## Diagnostic Summaries

```{r mcmc-diag-function}
# a function to get MCMC diagnoses for a group of parameters
# params: a string to match with postpack::match_params()
# L1: a "Level-1" group label; such as component of the model (e.g., LH apportionment)
# L2: a "Level-2" group label; such as type of parameter (e.g., mean, sd, or year-specific value)
# L3: a "Level-3" group label; such as NOR or females or age-3 females


diag_fn = function(params, L1 = NA, L2 = NA, L3 = NA) {
  
  # extract the posteriors of interest and format for 'posterior' package
  post_sub = as_draws_df(post_subset(post, params))

  # summarize the posteriors
  diags = summarize_draws(post_sub, mean, ~quantile(.x, c(0.025, 0.975)), rhat, ess_mean, ~ess_quantile(.x, probs = c(0.025, 0.975)), mcse_mean, ~mcse_quantile(.x, probs = c(0.025, 0.975)))
  
  # discard any parameters that were the same value every MCMC iteration
  # (will have an NA for rhat)
  diags = diags[!is.na(diags$rhat),]
  
  # add "Monte Carlo CV"
  diags$mccv_mean = diags$mcse_mean/diags$mean
  diags$mccv_q2.5 = diags$mcse_q2.5/diags$`2.5%`
  diags$mccv_q97.5 = diags$mcse_q97.5/diags$`97.5%`
  
  # summarize the summaries
  out = data.frame(
    L1 = L1,
    L2 = L2,
    L3 = L3,
    match = params,
    n_params = nrow(diags),
    Rhat_1.05 = sum(diags$rhat >= 1.05),
    Rhat_1.1 = sum(diags$rhat >= 1.1),
    Rhat_1.2 = sum(diags$rhat >= 1.2),
    ess_mean_400 = sum(diags$ess_mean < 400),
    ess_q2.5_400 = sum(diags$ess_q2.5 < 400),
    ess_q97.5_400 = sum(diags$ess_q97.5 < 400),
    mccv_mean_0.05 = sum(diags$mccv_mean > 0.05),
    mccv_q2.5_0.05 = sum(diags$mccv_q2.5 > 0.05),
    mccv_q97.5_0.05 = sum(diags$mccv_q97.5 > 0.05)
  )
  
  # return the summarized summaries
  return(out)
}

```

```{r calculate-mcmc-diagnostics}
# parr recruitment
L1 = "Parr Recruitment"
L2 = c("BH Productivity", "BH Capacity", "Process SD", "Parr States")
match = c("alpha", "^beta[", "sigma_Pb", "^Pb[")
parr_recruit_diags = unlist_dfs(lapply(1:length(match), function(i) diag_fn(match[i], L1 = L1, L2 = L2[i])))

# LH apportionment
L1 = "Life History Apportionment"
L2 = c("Mean", "Process SD", "Realized")
match = c("mu_pi[1,.]", "sig_Lpi", "^pi[.+,1,.]")
pi_diags = unlist_dfs(lapply(1:length(match), function(i) diag_fn(match[i], L1 = L1, L2 = L2[i])))

# Overwinter survival
L1 = "Overwinter Survival"
L2 = c("Intercept", "Slope", "Process SD", "Realized")
base = list("gamma0[LH_type,pop]", "gamma1[LH_type,pop]", "sig_Lphi_Pa_Mb[LH_type,pop]", "^phi_Pa_Mb[year,LH_type,pop]")
match = sub_index(base, year = ".+", LH_type = i_fall, pop = ".")
tmp1 = unlist_dfs(lapply(1:length(match), function(i) diag_fn(match[i], L1 = L1, L2 = L2[i], L3 = "Fall Migrants")))
match = sub_index(base, year = ".+", LH_type = i_spring, pop = ".")
tmp2 = unlist_dfs(lapply(1:length(match), function(i) diag_fn(match[i], L1 = L1, L2 = L2[i], L3 = "Spring Migrants")))
phi_Pa_Mb_diags = rbind(tmp1, tmp2)

# Migration survival: trib to LGR
L1 = "Migration Survival (Trib to LGR)"
L2 = c("Mean", "Process SD", "Realized")
base = list("mu_phi_Mb_Ma[LH_type,origin,pop]", "sig_Lphi_Mb_Ma[LH_type,origin,pop]", "phi_Mb_Ma[year,LH_type,origin,pop]")
match = sub_index(base, year = ".+", LH_type = i_spring, origin = o_nor, pop = ".")
tmp1 = unlist_dfs(lapply(1:length(match), function(i) diag_fn(match[i], L1 = L1, L2 = L2[i], L3 = "NOR")))
match = sub_index(base, year = ".+", LH_type = i_spring, origin = o_hor, pop = ".")
tmp2 = unlist_dfs(lapply(1:length(match), function(i) diag_fn(match[i], L1 = L1, L2 = L2[i], L3 = "HOR")))
phi_Mb_Ma_diags = rbind(tmp1, tmp2)

# Migration survival: LGR to BON
L1 = "Migration Survival (LGR to Ocean)"
L2 = c("Mean", "Process SD", "Realized")
base = c("mu_phi_Ma_O0[origin]", "sig_Lphi_Ma_O0[origin]", "phi_Ma_O0[year,origin]")
match = sub_index(base, year = ".+", origin = o_nor)
tmp1 = unlist_dfs(lapply(1:length(match), function(i) diag_fn(match[i], L1 = L1, L2 = L2[i], L3 = "NOR")))
match = sub_index(base, year = ".+", origin = o_hor)
tmp2 = unlist_dfs(lapply(1:length(match), function(i) diag_fn(match[i], L1 = L1, L2 = L2[i], L3 = "HOR")))
phi_Ma_O0_diags = rbind(tmp1, tmp2)

# Sex Apportionment
L1 = "Sex Apportionment"
L2 = c("Mean", "Process SD", "Realized")
base = list("mu_omega[sex,origin,pop]", "sig_Lomega[origin,pop]", "omega[year,sex,origin,pop]")
match = sub_index(base, year = ".+", sex = s_female, origin = o_nor, pop = ".")
tmp1 = unlist_dfs(lapply(1:length(match), function(i) diag_fn(match[i], L1 = L1, L2 = L2[i], L3 = "NOR")))
match = sub_index(base, year = ".+", sex = s_female, origin = o_hor, pop = ".")
tmp2 = unlist_dfs(lapply(1:length(match), function(i) diag_fn(match[i], L1 = L1, L2 = L2[i], L3 = "HOR")))
omega_diags = rbind(tmp1, tmp2)

# Probability of Maturing at Age-3
L1 = "Pr(Mature at Age-3)"
L2 = c("Mean", "Process SD", "Realized")
base = c("mu_psi_O1_Rb[sex,origin,pop]", "sig_Lpsi_O1_Rb[sex,origin,pop]", "psi_O1_Rb[.+,sex,origin,pop]")
match = sub_index(base, year = ".+", sex = s_female, origin = o_nor, pop = ".")
tmp1 = unlist_dfs(lapply(1:length(match), function(i) diag_fn(match[i], L1 = L1, L2 = L2[i], L3 = "Female (NOR)")))
match = sub_index(base, year = ".+", sex = s_female, origin = o_hor, pop = ".")
tmp2 = unlist_dfs(lapply(1:length(match), function(i) diag_fn(match[i], L1 = L1, L2 = L2[i], L3 = "Female (HOR)")))
match = sub_index(base, year = ".+", sex = s_male, origin = o_nor, pop = ".")
tmp3 = unlist_dfs(lapply(1:length(match), function(i) diag_fn(match[i], L1 = L1, L2 = L2[i], L3 = "Male (NOR)")))
match = sub_index(base, year = ".+", sex = s_male, origin = o_hor, pop = ".")
tmp4 = unlist_dfs(lapply(1:length(match), function(i) diag_fn(match[i], L1 = L1, L2 = L2[i], L3 = "Male (HOR)")))
psi_O1_Rb_diags = rbind(tmp1, tmp2, tmp3, tmp4)

# Probability of Maturing at Age-4
L1 = "Pr(Mature at Age-4)"
L2 = c("Mean", "Process SD", "Realized")
base = c("mu_psi_O2_Rb[sex,origin,pop]", "sig_Lpsi_O2_Rb[sex,origin,pop]", "psi_O2_Rb[.+,sex,origin,pop]")
match = sub_index(base, year = ".+", sex = s_female, origin = o_nor, pop = ".")
tmp1 = unlist_dfs(lapply(1:length(match), function(i) diag_fn(match[i], L1 = L1, L2 = L2[i], L3 = "Female (NOR)")))
match = sub_index(base, year = ".+", sex = s_female, origin = o_hor, pop = ".")
tmp2 = unlist_dfs(lapply(1:length(match), function(i) diag_fn(match[i], L1 = L1, L2 = L2[i], L3 = "Female (HOR)")))
match = sub_index(base, year = ".+", sex = s_male, origin = o_nor, pop = ".")
tmp3 = unlist_dfs(lapply(1:length(match), function(i) diag_fn(match[i], L1 = L1, L2 = L2[i], L3 = "Male (NOR)")))
match = sub_index(base, year = ".+", sex = s_male, origin = o_hor, pop = ".")
tmp4 = unlist_dfs(lapply(1:length(match), function(i) diag_fn(match[i], L1 = L1, L2 = L2[i], L3 = "Male (HOR)")))
psi_O2_Rb_diags = rbind(tmp1, tmp2, tmp3, tmp4)

# Year 1 ocean survival
L1 = "Year 1 Ocean Survival"
L2 = c("Mean", "Process SD", "Realized")
base = c("mu_phi_O0_O1[origin]", "sig_Lphi_O0_O1", "phi_O0_O1[year,origin]")
match = sub_index(base, year = ".+", origin = o_nor)
phi_O0_O1_diags = unlist_dfs(lapply(1:length(match), function(i) diag_fn(match[i], L1 = L1, L2 = L2[i])))

# Year 2 ocean survival
L1 = "Year 2 Ocean Survival"
L2 = c("Mean", "Process SD", "Realized")
base = c("mu_phi_O1_O2[origin]", "sig_Lphi_O1_O2", "phi_O1_O2[year,origin]")
match = sub_index(base, year = ".+", origin = o_nor)
phi_O1_O2_diags = unlist_dfs(lapply(1:length(match), function(i) diag_fn(match[i], L1 = L1, L2 = L2[i])))

# Misc ocean survival
L1 = "Misc Ocean Survival"
L2 = c("NOR:HOR Scaler", "Year 0 Residual", "AR(1) Coefficient")
match = c("O_phi_scaler_nat_hat", "Lphi_O0_O1_resid[5]", "kappa_phi_O0_O1")
misc_ocean_surv_diags = unlist_dfs(lapply(1:length(match), function(i) diag_fn(match[i], L1 = L1, L2 = L2[i])))

# Pre-spawn Survival
L1 = "Pre-spawn Survival"
L2 = c("Mean", "Process SD", "Realized")
match = c("mu_phi_Sb_Sa[.]", "sig_Lphi_Sb_Sa[.]", "phi_Sb_Sa[.+,.]")
phi_Sb_Sa_diags = unlist_dfs(lapply(1:length(match), function(i) diag_fn(match[i], L1 = L1, L2 = L2[i])))

# Carcass Correction
L1 = "Carcass Correction Factor"
z_diags = diag_fn("z", L1 = L1)

# Initial adult recruitment
L1 = "Initial Adult Recruitment"
L2 = c("Mean", "Process SD", "Realized")
match = c("mu_init_recruits[.]", "sig_init_lrecruits[.]", "^init_recruits[.+,.]")
init_diags = unlist_dfs(lapply(1:length(match), function(i) diag_fn(match[i], L1 = L1, L2 = L2[i])))

# Straying
L1 = "Strays"
L2 = c("Realized Number", "Age/Sex Comp")
match = c("n_stray_tot[.+,.]", sub_index("stray_comp[age,sex,origin,pop]", age = ".", sex = ".", origin = o_hor, pop = "."))
stray_diags = unlist_dfs(lapply(1:length(match), function(i) diag_fn(match[i], L1 = L1, L2 = L2[i])))

# combine diagnostic summaries into one massive table
diags_table = rbind(
  parr_recruit_diags,
  pi_diags,
  phi_Pa_Mb_diags,
  phi_Mb_Ma_diags,
  phi_Ma_O0_diags,
  omega_diags,
  psi_O1_Rb_diags,
  psi_O2_Rb_diags,
  phi_O0_O1_diags,
  phi_O1_O2_diags,
  phi_Sb_Sa_diags,
  misc_ocean_surv_diags,
  z_diags,
  init_diags,
  stray_diags
)
```

This table displays summaries of MCMC diagnostics for all unobserved stochastic nodes in the model. Values in cells represent the percentage of parameters of a given type that fail a diagnostic check. E.g., 50% in the "Rhat > 1.05" column means that half of the parameters of that type had Rhat values greater than 1.05. Cells with no color indicate no offense and darker reds indicate greater frequency of an offense.

* **Rhat** measures convergence of multiple chains to a common target distribution. Values close to 1 are ideal, greater than 1.1 are problematic but possibly passable, and greater than 1.2 should not be used for inference (general rules).
* **ESS** measures the number of effective MCMC samples are available to estimate a given summary statistic of the posterior -- here the posterior mean and quantiles of the 95% equal-tailed CRI. Percentages shown represent the fraction of parameters that have fewer than 400 ESS -- which Vehtari et al. [2021](https://projecteuclid.org/journals/bayesian-analysis/advance-publication/Rank-Normalization-Folding-and-Localization--An-Improved-R%cb%86-for/10.1214/20-BA1221.full) suggest as a good rule of thumb.
* **MCCV** is Monte Carlo Standard Error of a summary statistic divided by the estimated posterior summary statistic, intended to represent a measure of precision for estimating posterior summary statistics -- here the posterior mean and quantiles of the 95% equal-tailed CRI. Percentages shown represent the fraction of parameters that have greater than 5% MCCV -- which Staton has (arbitrarily and at this time) chosen as the greatest amount of acceptable imprecision.

The calculations behind this table are implemented using the '[posterior](https://mc-stan.org/posterior/articles/posterior.html)' R package, which contains updated MCMC diagnostics (Vehtari et al. [2021](https://projecteuclid.org/journals/bayesian-analysis/advance-publication/Rank-Normalization-Folding-and-Localization--An-Improved-R%cb%86-for/10.1214/20-BA1221.full)).

```{r mcmc-diag-table}
# duplicate the diagnostic output
kable_table = diags_table

# order the rows
kable_table$L1 = factor(kable_table$L1, levels = unique(kable_table$L1))
kable_table = diags_table[order(kable_table$L1, kable_table$L2, kable_table$L3),]

# keep only relevant columns for kable
kable_table = kable_table[,-which(colnames(diags_table) %in% c("match", "mean_value", "Rhat_mean", "ess_bulk_mean"))]

# convert counts of offending parameters to percentages
kable_table$Rhat_1.05 = paste0(round(kable_table$Rhat_1.05/kable_table$n_params, 2) * 100, "%")
kable_table$Rhat_1.1 = paste0(round(kable_table$Rhat_1.1/kable_table$n_params, 2) * 100, "%")
kable_table$Rhat_1.2 = paste0(round(kable_table$Rhat_1.2/kable_table$n_params, 2) * 100, "%")
kable_table$ess_mean_400 = paste0(round(kable_table$ess_mean_400/kable_table$n_params, 2) * 100, "%")
kable_table$ess_q2.5_400 = paste0(round(kable_table$ess_q2.5_400/kable_table$n_params, 2) * 100, "%")
kable_table$ess_q97.5_400 = paste0(round(kable_table$ess_q97.5_400/kable_table$n_params, 2) * 100, "%")
kable_table$mccv_mean_0.05 = paste0(round(kable_table$mccv_mean_0.05/kable_table$n_params, 2) * 100, "%")
kable_table$mccv_q2.5_0.05 = paste0(round(kable_table$mccv_q2.5_0.05/kable_table$n_params, 2) * 100, "%")
kable_table$mccv_q97.5_0.05 = paste0(round(kable_table$mccv_q97.5_0.05/kable_table$n_params, 2) * 100, "%")

# add basic formatting
colnames(kable_table) = c("Model Component", "Parameter Type", "Group", "N", "> 1.05", "> 1.1", "> 1.2", "Mean", "q2.5", "q97.5", "Mean", "q2.5", "q97.5")
kable_table$Group[is.na(kable_table$Group)] = " "
kable_table$`Parameter Type`[is.na(kable_table$`Parameter Type`)] = " "

assign_color = function(x, colors = c("white","red")) {
  pal = colorRampPalette(colors)
  cols = pal(6)
  bin_names = levels(cut(rbeta(1e6, 1, 1) * 100, breaks = c(0,0.001,20,40,60,80,100), include.lowest = TRUE))
  names(cols) = bin_names
  bins = cut(x, breaks = c(0,0.001,20,40,60,80,100), include.lowest = TRUE)
  cols_use = cols[as.character(bins)]
  alpha(unname(cols_use), 0.5)
}

# produce the kable
kable(kable_table, row.names = FALSE, align = c("lllcccccccccc")) %>%
  kable_styling(full_width = TRUE, fixed_thead = TRUE, bootstrap_options = c("striped", "condensed")) %>%
  add_header_above(c(" " = 4, "Rhat" = 3, "ESS < 400" = 3, "MCCV > 5%" = 3)) %>%
  column_spec(2:3, width = "150px") %>%
  column_spec(c(4,7,10), border_right = TRUE) %>%
  column_spec(5, background = assign_color(as.numeric(stringr::str_remove(kable_table[,5], "%")))) %>%
  column_spec(6, background = assign_color(as.numeric(stringr::str_remove(kable_table[,6], "%")))) %>%
  column_spec(7, background = assign_color(as.numeric(stringr::str_remove(kable_table[,7], "%")))) %>%
  column_spec(8, background = assign_color(as.numeric(stringr::str_remove(kable_table[,8], "%")))) %>%
  column_spec(9, background = assign_color(as.numeric(stringr::str_remove(kable_table[,9], "%")))) %>%
  column_spec(10, background = assign_color(as.numeric(stringr::str_remove(kable_table[,10], "%")))) %>%
  column_spec(11, background = assign_color(as.numeric(stringr::str_remove(kable_table[,11], "%")))) %>%
  column_spec(12, background = assign_color(as.numeric(stringr::str_remove(kable_table[,12], "%")))) %>%
  column_spec(13, background = assign_color(as.numeric(stringr::str_remove(kable_table[,13], "%")))) %>%
  collapse_rows(columns = 1:2)
```






```


```



```

# Fit to Data {.tabset .tabset-pills}

In the figures below, the thick red line is the posterior median value each year, the red region is the equal-tailed 95% credible interval, and blue points are "observed" data (estimated from raw data external to the model).

## Abundance Data

```{r abundance-data-fits, fig.width = 3, fig.height = 5}
par(mfcol = c(3,1), oma = c(1.5,1.5,0,0))
plot_tseries(post_summ(post, "^Pa[.+,1]$"), jags_data$Pa_obs[observable,1], main = TeX("$Fall\\,Parr\\,Abundance\\,(At\\,Trap)$"))
plot_tseries(post_summ(post, "^Mb[.+,2,1]$"), jags_data$Mb_obs[observable,2,1], main = TeX("$Spring\\,Smolt\\,Abundance\\,(At\\,Trap)$"))
plot_tseries(post_summ(post, "^Ra_tot["), jags_data$Ra_obs[observable], main = TeX("$Adult\\,Return\\,Abundance$"))

mtext(side = 1, outer = T, line = 0.25, "Brood Year")
mtext(side = 2, outer = T, line = 0.25, "Abundance")
```

## Survival Data

```{r survival-data-fits, fig.width = 5, fig.height = 6}
par(mfcol = c(3,2), oma = c(1.5,1.5,0,0))
plot_tseries(post_summ(post, "^phi_Pb_Ma["), expit(jags_data$Lphi_obs_Pb_Ma[observable]), main = TeX("$Summer\\,Parr \\rightarrow LGR"))
plot_tseries(post_summ(post, "^phi_Pa_Ma[.+,1]$"), expit(jags_data$Lphi_obs_Pa_Ma[observable,1]), main = TeX("$Fall\\,Parr \\rightarrow LGR"))
plot_tseries(post_summ(post, "^phi_Mb_Ma[.+,2,1]$"), expit(jags_data$Lphi_obs_Mb_Ma[observable,2,1]), main = TeX("$Spring\\,Smolt \\rightarrow LGR\\,(NOR)"))
plot_tseries(post_summ(post, "^phi_Mb_Ma[.+,2,2]$"), expit(jags_data$Lphi_obs_Mb_Ma[observable,2,2]), main = TeX("$Spring\\,Smolt \\rightarrow LGR\\,(HOR)"))
plot_tseries(post_summ(post, "^phi_Ma_O0[.+,1]$"), expit(jags_data$Lphi_obs_Ma_O0[observable,1]), main = TeX("$LGR\\,Smolt \\rightarrow O_0\\,(NOR)"))
plot_tseries(post_summ(post, "^phi_Ma_O0[.+,2]$"), expit(jags_data$Lphi_obs_Ma_O0[observable,2]), main = TeX("$LGR\\,Smolt \\rightarrow O_0\\,(HOR)"))
mtext(side = 1, outer = T, line = 0.25, "Brood Year")
mtext(side = 2, outer = T, line = 0.25, "Survival")
```

## Composition Data {.tabset .tabset-pills .tabset-fade}

Within a single year, the values across all panels sum to one.

### Weir Sampling

```{r weir-comp-data-fits, fig.width = 8, fig.height = 5}
# calculate observed q
q_obs = t(apply(jags_data$weir_x_obs, 1, function(y) y/sum(y)))

par(mfcol = c(3,4), oma = c(1.5,1.5,0,0))#, mar = c(1.5,1.5,1.5,0.5))
plot_tseries(post_summ(post, "^q_Ra[.+,1]$"), q_obs[observable,1], main = TeX("$Female\\,Age\\,3\\,(NOR)$"))
plot_tseries(post_summ(post, "^q_Ra[.+,2]$"), q_obs[observable,2], main = TeX("$Female\\,Age\\,4\\,(NOR)$"))
plot_tseries(post_summ(post, "^q_Ra[.+,3]$"), q_obs[observable,3], main = TeX("$Female\\,Age\\,5\\,(NOR)$"))
plot_tseries(post_summ(post, "^q_Ra[.+,4]$"), q_obs[observable,4], main = TeX("$Male\\,Age\\,3\\,(NOR)$"))
plot_tseries(post_summ(post, "^q_Ra[.+,5]$"), q_obs[observable,5], main = TeX("$Male\\,Age\\,4\\,(NOR)$"))
plot_tseries(post_summ(post, "^q_Ra[.+,6]$"), q_obs[observable,6], main = TeX("$Male\\,Age\\,5\\,(NOR)$"))
plot_tseries(post_summ(post, "^q_Ra[.+,7]$"), q_obs[observable,7], main = TeX("$Female\\,Age\\,3\\,(HOR)$"))
plot_tseries(post_summ(post, "^q_Ra[.+,8]$"), q_obs[observable,8], main = TeX("$Female\\,Age\\,4\\,(HOR)$"))
plot_tseries(post_summ(post, "^q_Ra[.+,9]$"), q_obs[observable,9], main = TeX("$Female\\,Age\\,5\\,(HOR)$"))
plot_tseries(post_summ(post, "^q_Ra[.+,10]$"), q_obs[observable,10], main = TeX("$Male\\,Age\\,3\\,(HOR)$"))
plot_tseries(post_summ(post, "^q_Ra[.+,11]$"), q_obs[observable,11], main = TeX("$Male\\,Age\\,4\\,(HOR)$"))
plot_tseries(post_summ(post, "^q_Ra[.+,12]$"), q_obs[observable,12], main = TeX("$Male\\,Age\\,5\\,(HOR)$"))
mtext(side = 1, outer = T, line = 0.25, "Brood Year")
mtext(side = 2, outer = T, line = 0.25, "Proportion of Return")
```

### Carcass Sampling

```{r carc-comp-data-fits, fig.width = 8, fig.height = 5}
# calculate observed q
q_obs = t(apply(jags_data$carc_x_obs, 1, function(y) y/sum(y)))

par(mfcol = c(3,4), oma = c(1.5,1.5,0,0))
plot_tseries(post_summ(post, "^q_Sa_adj[.+,1]$"), q_obs[observable,1], main = TeX("$Female\\,Age\\,3\\,(NOR)$"))
plot_tseries(post_summ(post, "^q_Sa_adj[.+,2]$"), q_obs[observable,2], main = TeX("$Female\\,Age\\,4\\,(NOR)$"))
plot_tseries(post_summ(post, "^q_Sa_adj[.+,3]$"), q_obs[observable,3], main = TeX("$Female\\,Age\\,5\\,(NOR)$"))
plot_tseries(post_summ(post, "^q_Sa_adj[.+,4]$"), q_obs[observable,4], main = TeX("$Male\\,Age\\,3\\,(NOR)$"))
plot_tseries(post_summ(post, "^q_Sa_adj[.+,5]$"), q_obs[observable,5], main = TeX("$Male\\,Age\\,4\\,(NOR)$"))
plot_tseries(post_summ(post, "^q_Sa_adj[.+,6]$"), q_obs[observable,6], main = TeX("$Male\\,Age\\,5\\,(NOR)$"))
plot_tseries(post_summ(post, "^q_Sa_adj[.+,7]$"), q_obs[observable,7], main = TeX("$Female\\,Age\\,3\\,(HOR)$"))
plot_tseries(post_summ(post, "^q_Sa_adj[.+,8]$"), q_obs[observable,8], main = TeX("$Female\\,Age\\,4\\,(HOR)$"))
plot_tseries(post_summ(post, "^q_Sa_adj[.+,9]$"), q_obs[observable,9], main = TeX("$Female\\,Age\\,5\\,(HOR)$"))
plot_tseries(post_summ(post, "^q_Sa_adj[.+,10]$"), q_obs[observable,10], main = TeX("$Male\\,Age\\,3\\,(HOR)$"))
plot_tseries(post_summ(post, "^q_Sa_adj[.+,11]$"), q_obs[observable,11], main = TeX("$Male\\,Age\\,4\\,(HOR)$"))
plot_tseries(post_summ(post, "^q_Sa_adj[.+,12]$"), q_obs[observable,12], main = TeX("$Male\\,Age\\,5\\,(HOR)$"))
mtext(side = 1, outer = T, line = 0.25, "Brood Year")
mtext(side = 2, outer = T, line = 0.25, "Proportion of Return")
```

## Spawn Status Data

```{r spawn-status-fits, fig.width = 3.5, fig.height = 5}
par(oma = c(1.5,1.5,0,0))
layout(matrix(c(1,2), 2, 1), heights = c(1, 0.65))
plot_tseries(post_summ(post, "^phi_Sb_Sa["), with(jags_data, carcs_spawned/carcs_sampled)[observable], main = "Successful Spawning")
mtext(side = 2, "Survival Probability", line = 1.5)

at_x = seq(1, length(observable), 4)
par(mar = c(2,2,0,1), yaxs = "i")
mp = barplot(jags_data$carcs_sampled[observable], xaxt = "n", ylim = c(0, max(jags_data$carcs_sampled, na.rm = T)) + c(0, 5))
axis(side = 1, at = mp[at_x], labels = substr( names(jags_data$carcs_sampled[observable]), 3, 4)[at_x])
box()
mtext(side = 2, "Carcasses Sampled", line = 1.5)
mtext(side = 1, "Brood Year", line = 1.5)
```

# Spawner-to-Parr Relationship {.tabset .tabset-pills}

## Beverton-Holt

All red components are posterior summaries (medians and 95% credible intervals). The black curve is from an `nls()` fit on reconstructed parr and roughly approximated total egg production -- the grey region is the confidence interval around this fit.

```{r eggs-to-parr, fig.width = 6, fig.height = 4}
# extract posterior samples of the BH productivity and capacity parameters
bh_params = post_subset(post, c("alpha", "^beta$"), matrix = T)

# extract posterior summaries of total spawners by brood year
Sa_tot = post_summ(post, "^Sa_tot[")

# extract posterior summaries of total egg production by brood year
f_tot = post_summ(post, "^f_tot[")

# extract posterior summaries of total parr recruits by brood year
Pb = post_summ(post, "^Pb[")

# predict parr recruits along a sequence of spawner abundances
Sa_pred = seq(0, max(Sa_tot[5,]), length = 30)
f_pred = seq(0, max(f_tot[5,]), length = 30)

Pb_pred = t(sapply(1:post_dim(post, "saved"), function(i) BH(f_pred, bh_params[i,1], bh_params[i,2])))
colnames(Pb_pred) = paste0("Pb_pred[", 1:length(Sa_pred), "]")
Pb_pred = post_convert(cbind(postpack:::id_mat(post), Pb_pred))
Pb_pred = post_summ(Pb_pred, "Pb_pred")

# fit ordinary least squares version
ols_fit = fit_fecund_BH(jags_data)$BH_fit

# draw 1000 random parameters
ols_params = exp(rmvnorm(1000, coef(ols_fit), vcov(ols_fit)))

# calculate predicted curve at each pair/summarize
ols_R_pred = t(sapply(1:1000, function(i) BH(f_pred, ols_params[i,1], ols_params[i,2])))
ols_R_pred = apply(ols_R_pred, 2, function(x) quantile(x, c(0.5, 0.025, 0.975)))

# graphical parameters
par(mar = c(3,3,1,1), mgp = c(2,0.3,0), tcl = -0.2)

# empty plot
plot(1, 1, type = "n", xlim = range(0, f_tot[5,]), ylim = range(0, Pb[5,], Pb_pred[5,]),
     xlab = "Total Egg Production (millions)", ylab = "Parr Recruits", xaxt = "n")

x_ticks = axisTicks(par("usr")[1:2], log = F)
axis(side = 1, at = x_ticks, labels = x_ticks/1e6)

# draw fitted relationship: Bayesian
polygon(c(f_pred, rev(f_pred)), c(Pb_pred[4,], rev(Pb_pred[5,])), col = alpha("salmon", 0.5), border = NA)
lines(Pb_pred[4,] ~ f_pred, col = "red", lty = 2)
lines(Pb_pred[5,] ~ f_pred, col = "red", lty = 2)

# draw fitted relationship: OLS
polygon(c(f_pred, rev(f_pred)), c(ols_R_pred[2,], rev(ols_R_pred[3,])), col = alpha("grey", 0.5), border = NA)
lines(ols_R_pred[1,] ~ f_pred, lwd = 2)
lines(ols_R_pred[2,] ~ f_pred, lty = 2)
lines(ols_R_pred[3,] ~ f_pred, lty = 2)
lines(Pb_pred[3,] ~ f_pred, col = "red", lwd = 2)

# draw state pairs + uncertainty
segments(f_tot[4,], Pb[3,], f_tot[5,], Pb[3,], col = "red")
segments(f_tot[3,], Pb[4,], f_tot[3,], Pb[5,], col = "red")
points(Pb[3,] ~ f_tot[3,], pch = 21, col = "red", bg = alpha("salmon", 0.5))
```

## Total Eggs vs. Total Spawners

This figure illustrates that total spawners is a reasonable index of total egg production. The three lines illustrate the relationship if each spawner (regardless of age/sex) had a fixed number of eggs.

```{r, fig.width = 6, fig.height = 4}
# extract posterior summaries of total egg production by brood year
f_tot = post_summ(post, "^f_tot[")

# extract posterior summaries of total spawners by brood year
Sa_tot = post_summ(post, "^Sa_tot[")

par(mgp = c(2,0.35, 0), tcl = -0.15, mar = c(3,3,1,1))
plot(f_tot["mean",] ~ Sa_tot["mean",],
     ylim = c(0, max(f_tot["97.5%",])),
     xlim = c(0, max(Sa_tot["97.5%",])), type = "n",
     ylab = "Total Egg Production (Millions)", xlab = "Total Spawners", las = 1, yaxt = "n")
y_ticks = axisTicks(par("usr")[3:4], log = F)
axis(side = 2, at = y_ticks, labels = y_ticks/1e6, las = 2)

segments(Sa_tot["2.5%",], f_tot["mean",], Sa_tot["97.5%",], f_tot["mean",], col = alpha("red", 0.5))
segments(Sa_tot["mean",], f_tot["2.5%",], Sa_tot["mean",], f_tot["97.5%",], col = alpha("red", 0.5))
points(f_tot["mean",] ~ Sa_tot["mean",], pch = 21, col = "red", bg = alpha("salmon", 0.5), cex = 1.2)
abline(c(0, 1000), lty = 1)
abline(c(0, 1800), lty = 2)
abline(c(0, 3600), lty = 3)
legend("bottomright", title = "If Each Spawner Had:",
       legend = c("1000 Eggs", "1800 Eggs", "3600 Eggs"),
       lty = c(1,2,3), bty = "n")
```

## Parr per Egg

This figure shows the inherent density dependence built in to the Beverton-Holt recruitment function: with increasing egg density, survival per egg decreases. The horizontal line/region shows the theoretical maximum ($\alpha$) in the absence of density dependence.

```{r, fig.width = 6, fig.height = 4}
# extract posterior summaries of total egg production by brood year
f_tot = post_summ(post, "^f_tot[")

# extract posterior summaries of total parr recruits by brood year
Pb = post_summ(post, "^Pb[")

# conversion rates
Pb_per_f_tot = post_summ(post, "^Pb_per_f_tot[")

# max survival
alpha = post_summ(post, "^alpha")

par(mgp = c(2,0.35, 0), tcl = -0.15, mar = c(3,3,1,1))
plot(Pb_per_f_tot["mean",] ~ f_tot["mean",],
     ylim = c(0, max(Pb_per_f_tot["97.5%",], alpha["97.5%",])),
     xlim = c(0, max(f_tot["97.5%",])), type = "n",
     ylab = "Parr per Egg", xlab = "Total Egg Production (Millions)", las = 1, xaxt = "n")
x_ticks = axisTicks(par("usr")[1:2], log = F)
axis(side = 1, at = x_ticks, labels = x_ticks/1e6)

segments(f_tot["2.5%",], Pb_per_f_tot["mean",], f_tot["97.5%",], Pb_per_f_tot["mean",], col = alpha("red", 0.5))
segments(f_tot["mean",], Pb_per_f_tot["2.5%",], f_tot["mean",], Pb_per_f_tot["97.5%",], col = alpha("red", 0.5))
points(Pb_per_f_tot["mean",] ~ f_tot["mean",], pch = 21, col = "red", bg = alpha("salmon", 0.5), cex = 1.2)

rect(par("usr")[1], alpha["2.5%",], par("usr")[2], alpha["97.5%",], border = alpha("red", 0.5), col = alpha("salmon", 0.5))
abline(h = alpha["mean",], lwd = 2, col = "red")
box()
```

## Parr per Spawner

This figure is identical to above, but shows parr production per spawner instead of per egg.

```{r, fig.width = 6, fig.height = 4}
# extract posterior summaries of total spawners by brood year
Sa_tot = post_summ(post, "^Sa_tot[")

# extract posterior summaries of total parr recruits by brood year
Pb = post_summ(post, "^Pb[")

# conversion rates
Pb_per_Sa_tot = post_summ(post, "^Pb_per_Sa_tot[")

par(mgp = c(2,0.35, 0), tcl = -0.15, mar = c(3,3,1,1))
plot(Pb_per_Sa_tot["mean",] ~ Sa_tot["mean",],
     ylim = c(0, max(Pb_per_Sa_tot["97.5%",])),
     xlim = c(0, max(Sa_tot["97.5%",])), type = "n",
     ylab = "Parr per Spawner", xlab = "Spawners", las = 1)
segments(Sa_tot["2.5%",], Pb_per_Sa_tot["mean",], Sa_tot["97.5%",], Pb_per_Sa_tot["mean",], col = alpha("red", 0.5))
segments(Sa_tot["mean",], Pb_per_Sa_tot["2.5%",], Sa_tot["mean",], Pb_per_Sa_tot["97.5%",], col = alpha("red", 0.5))
points(Pb_per_Sa_tot["mean",] ~ Sa_tot["mean",], pch = 21, col = "red", bg = alpha("salmon", 0.5), cex = 1.2)
```

# Overwinter Survival Relationships

```{r overwinter-survival, fig.width = 4, fig.height = 7}

# extract parr, scale it to PEU, and add to posterior samples
Pa = post_subset(post, "^Pa[", matrix = T)
Pa_scaled = Pa/jags_data$peu
colnames(Pa_scaled) = gsub("Pa", "Pa_scaled", x = colnames(Pa_scaled))
post = post_bind(post, Pa_scaled)

# summarize posterior of scaled parr
Pa_scaled_mean = array_format(post_summ(post, "Pa_scaled")["mean",])
Pa_scaled_lwr = array_format(post_summ(post, "Pa_scaled")["2.5%",])
Pa_scaled_upr = array_format(post_summ(post, "Pa_scaled")["97.5%",])

# create vectors to predict survival at: for credible regions and mean curve
Pa_scaled_seq = matrix(NA, 30, 2)
Pa_scaled_seq[,1] = seq(min(Pa_scaled_lwr[,1], na.rm = T), max(Pa_scaled_upr[,1], na.rm = T), length = 30)
Pa_scaled_seq[,2] = seq(min(Pa_scaled_lwr[,2], na.rm = T), max(Pa_scaled_upr[,2], na.rm = T), length = 30)

# extract posteriors of coefficients
gamma0 = post_subset(post, "gamma0", matrix = T)
gamma1 = post_subset(post, "gamma1", matrix = T)

# extract/format posterior summaries of realized survivals
phi_Pa_Mb_mean = array_format(post_summ(post, "^phi_Pa_Mb[")["mean",])
phi_Pa_Mb_lwr = array_format(post_summ(post, "^phi_Pa_Mb[")["2.5%",])
phi_Pa_Mb_upr = array_format(post_summ(post, "^phi_Pa_Mb[")["97.5%",])

# function to create predicted survival curves for one posterior sample
f = function(i) {
  pred_phi_Pa_Mb1 = plogis(gamma0[i,1] + gamma1[i,1] * Pa_scaled_seq[,1])
  pred_phi_Pa_Mb2 = plogis(gamma0[i,2] + gamma1[i,2] * Pa_scaled_seq[,2])

  names(pred_phi_Pa_Mb1) = paste0("pred_phi_Pa_Mb[", 1:30, ",1]")
  names(pred_phi_Pa_Mb2) = paste0("pred_phi_Pa_Mb[", 1:30, ",2]")

  c(pred_phi_Pa_Mb1, pred_phi_Pa_Mb2)
}

# calculate predicted survivals and add to posterior samples
pred_phi_Pa_Mb = t(sapply(1:post_dim(post, "saved"), f))
post = post_bind(post, pred_phi_Pa_Mb)

# summarize predicted survivals
pred_phi_Pa_Mb_mean = array_format(post_summ(post, "pred_phi_Pa_Mb")["mean",])
pred_phi_Pa_Mb_lwr = array_format(post_summ(post, "pred_phi_Pa_Mb")["2.5%",])
pred_phi_Pa_Mb_upr = array_format(post_summ(post, "pred_phi_Pa_Mb")["97.5%",])

# function to draw plot for one LH-type
plot_fun = function(i) {
  # blank plot of correct dimensions
  plot(1,1, type = "n", 
       ylim = range(pred_phi_Pa_Mb_lwr[,i], pred_phi_Pa_Mb_upr[,i], phi_Pa_Mb_lwr[,i], phi_Pa_Mb_upr[,i], na.rm = T),
       xlim = range(0, Pa_scaled_seq), 
       main = c("Fall Migrants", "Spring Migrants")[i]
  )
  
  # expected relationship
  polygon(c(Pa_scaled_seq[,i], rev(Pa_scaled_seq[,i])), c(pred_phi_Pa_Mb_lwr[,i], rev(pred_phi_Pa_Mb_upr[,i])), border = NA, col = alpha("salmon", 0.5))
  lines(pred_phi_Pa_Mb_lwr[,i] ~ Pa_scaled_seq[,i], col = "red", lty = 2)
  lines(pred_phi_Pa_Mb_upr[,i] ~ Pa_scaled_seq[,i], col = "red", lty = 2)
  lines(pred_phi_Pa_Mb_mean[,i] ~ Pa_scaled_seq[,i], col = "red", lwd = 2)
  
  # realized survivals
  segments(Pa_scaled_lwr[,i], phi_Pa_Mb_mean[,i], Pa_scaled_upr[,i], phi_Pa_Mb_mean[,i], col = alpha("red", 0.5))
  segments(Pa_scaled_mean[,i], phi_Pa_Mb_lwr[,i], Pa_scaled_mean[,i], phi_Pa_Mb_upr[,i], col = alpha("red", 0.5))
  points(phi_Pa_Mb_mean[,i] ~ Pa_scaled_mean[,i], pch = 21, col = "red", bg = alpha("salmon", 0.5))
}

# create the plot
par(mfrow = c(2,1), mgp = c(2,0.35, 0), tcl = -0.15, mar = c(1,1,2,1), oma = c(2,2,0,0))
plot_fun(1)
plot_fun(2)
mtext(side = 1, line = 1, outer = T, "LH-Specific Parr/PEU", cex = 1.2)
mtext(side = 2, line = 1, outer = T, "Overwinter Survival", cex = 1.2)
```

# Equivilency Rates

## Smolt-to-Adult Rates

This is survival from $Ma$ (smolts at the top of LGD) to $Ra$ (adults returning to tributary, vulnerable to being counted at weir).

The adult part is calculated across return years, by summing the number of adults of each age (regardless of sex) that return in the appropriate years. For example, the SAR for brood year 1991 uses smolt that were spawned in 1991, out-migrated in spring 1993, divided by the sum of age 3 adults in 1994, age 4 adults in 1995, and age 5 adults in 1996. The calculation is done for hatchery and natural origin fish separately. Only SARs through brood year 2014 are calculated, since this is the last year of complete adult returns.

```{r sar-plot, fig.width = 6, fig.height = 4}
# function to calculate posterior 
get_SAR_post = function(post, jags_data) {
  # extract posterior abundances
  Ra_post = post_subset(post, "^Ra[", T) # adults returning to Columbia River mouth
  Ma_post = post_subset(post, "^Ma[", T) # smolts at top of LGD
  
  # number of saved samples
  ni = post_dim(post, "saved")
  
  # first and last brood year SAR can be calculated for
  first_SAR_y = jags_data$kmax + 1
  last_SAR_y = jags_data$ny - jags_data$kmax
  
  # containers
  nat_SAR = hat_SAR = NULL
  
  # loop over mcmc iters
  for (i in 1:ni) {
    # extract quantities for this iter
    Ra = array_format(Ra_post[i,])
    Ma = array_format(Ma_post[i,])
    
    # give names
    dimnames(Ra) = dimnames(jags_data$n_remove)
    dimnames(Ma) = dimnames(jags_data$Mb_obs)
    
    # drop sex structure from Ra
    Ra = Ra[,,1,] + Ra[,,2,]
    
    # loop over years
    nat_SAR_i = hat_SAR_i = NULL
    for (y in first_SAR_y:last_SAR_y) {
      # sum up smolts across life history types
      nat_smolt = sum(Ma[y,,"Nat"])
      hat_smolt = sum(Ma[y,,"Hat"])
      
      # sum up returning adults from this brood
      nat_adults = Ra[y+3,1,"Nat"] + Ra[y+4,2,"Nat"] + Ra[y+5,3,"Nat"]
      hat_adults = Ra[y+3,1,"Hat"] + Ra[y+4,2,"Hat"] + Ra[y+5,3,"Hat"]
      
      nat_SAR_i = c(nat_SAR_i, nat_adults/nat_smolt)
      hat_SAR_i = c(hat_SAR_i, hat_adults/hat_smolt)
    }
    
    # combine with other mcmc iters
    nat_SAR = rbind(nat_SAR, nat_SAR_i)
    hat_SAR = rbind(hat_SAR, hat_SAR_i)
  }
  
  colnames(nat_SAR) = paste0("SAR[", first_SAR_y:last_SAR_y, ",1]")
  colnames(hat_SAR) = paste0("SAR[", first_SAR_y:last_SAR_y, ",2]")
  
  # drop out SAR years for hatchery fish where missing
  hat_SAR = hat_SAR[,!is.na(colSums(hat_SAR))]
  
  out = cbind(nat_SAR, hat_SAR)
  return(out)
}

# apply the function
SAR_post = get_SAR_post(post, jags_data)

# combine samples with main posterior object
post = post_bind(post, SAR_post)

# calculate/format posterior summaries
SAR_mean = array_format(post_summ(post, "SAR")["mean",]) * 100
SAR_lwr = array_format(post_summ(post, "SAR")["2.5%",]) * 100
SAR_upr = array_format(post_summ(post, "SAR")["97.5%",]) * 100

SAR_mean[SAR_mean == "Inf"] = NA
SAR_lwr[SAR_lwr == "Inf"] = NA
SAR_upr[SAR_upr == "Inf"] = NA

# subset years
all_yrs = as.numeric(dimnames(jags_data$Pa_obs)[[1]])
SAR_yrs = all_yrs[1:nrow(SAR_mean)]

# graphics device
par(mar = c(3,3,1,1), mgp = c(2,0.35,0), tcl = -0.2)

# blank plot with appropriate dimensions
plot(SAR_mean[,1] ~ SAR_yrs, ylab = "Adults/100 Smolt", xlab = "Brood Year",
     xlim = range(all_yrs), ylim = c(0, max(SAR_upr, na.rm = T)), type = "n", las = 1)

# draw posterior summary for natural origin
polygon(x = c(SAR_yrs, rev(SAR_yrs)), y = c(SAR_lwr[,1], rev(SAR_upr[,1])), col = alpha("skyblue2", 0.5), border = NA)
lines(SAR_lwr[,1] ~ SAR_yrs, col = "blue", lty = 2)
lines(SAR_upr[,1] ~ SAR_yrs, col = "blue", lty = 2)
lines(SAR_mean[,1] ~ SAR_yrs, col = "blue", lwd = 2)

# draw posterior summary for hatchery origin
polygon(x = c(SAR_yrs, rev(SAR_yrs)), y = c(SAR_lwr[,2], rev(SAR_upr[,2])), col = alpha("salmon", 0.5), border = NA)
lines(SAR_lwr[,2] ~ SAR_yrs, col = "red", lty = 2)
lines(SAR_upr[,2] ~ SAR_yrs, col = "red", lty = 2)
lines(SAR_mean[,2] ~ SAR_yrs, col = "red", lwd = 2)

# draw a legend
legend("topright", legend = c("Natural", "Hatchery"), title = "Origin",
       pch = 22, col = c("blue", "red"), pt.cex = 2, pt.bg = alpha(c("skyblue2", "salmon"), 0.5), bty = "n")
```

## Parr per Spawner

"Spawner" means total spawners that survive pre-spawn mortality.

```{r, fig.width = 6, fig.height = 4}
par(oma = c(1,1,0,0))
plot_tseries(est = post_summ(post, "Pb_per_Sa_tot["), yrs = as.numeric(rownames(jags_data$Pa_obs)[observable]))
mtext(side = 1, outer = T, line = -0.5, "Brood Year")
mtext(side = 2, outer = T, line = 0, "Parr/Spawner")
```

## Smolt per Spawner

"Smolt" means total NOR smolt that survive their second winter, immediately prior to migration out of basin.

```{r, fig.width = 6, fig.height = 4}
par(oma = c(1,1,0,0))
plot_tseries(est = post_summ(post, "Mb_per_Sa_tot["), yrs = as.numeric(rownames(jags_data$Pa_obs)[observable]))
mtext(side = 1, outer = T, line = -0.5, "Brood Year")
mtext(side = 2, outer = T, line = 0, "Smolt/Spawner")
```

## Spawners per Spawner

This is the sum of all spawners that were produced by the spawners in a given brood year (i.e., accounts for adult recruits returning across multiple ages/years). "Brood year" refers to the year the returning production was spawned. 

```{r, fig.width = 6, fig.height = 4}
all_yrs = as.numeric(dimnames(jags_data$Pa_obs)[[1]])

par(oma = c(1,1,0,0))
plot_tseries(est = post_summ(post, "Sa_tot_per_Sa_tot["), yrs = all_yrs[(jags_data$kmax+1):(jags_data$ny - jags_data$kmax)])
mtext(side = 1, outer = T, line = -0.5, "Brood Year")
mtext(side = 2, outer = T, line = 0, "Spawners/Spawner")
abline(h = 1, lty = 2)
```

# Number of Strays

```{r stray-tot-plot, fig.width = 6, fig.height = 4}
par(oma = c(1,1,0,0))
plot_tseries(post_summ(post, "n_stray_tot"), yrs = as.numeric(rownames(jags_data$Pa_obs)[observable]))
mtext(side = 1, outer = T, line = -0.5, "Return Year")
mtext(side = 2, outer = T, line = 0, "Number of Strays")
```

# Ocean Survival

```{r ocean-surv-plots, fig.width = 6, fig.height = 5}
par(mfrow = c(3,2), oma = c(1.5,1.5,0,0))
plot_tseries(post_summ(post, "phi_O0_O1[.+,1]$"), main = TeX("$O_0 \\rightarrow O_1\\,(NOR)$"), yrs = as.numeric(rownames(jags_data$Pa_obs)[observable]), ylim = c(0,1))
plot_tseries(post_summ(post, "phi_O0_O1[.+,2]$"), main = TeX("$O_0 \\rightarrow O_1\\,(HOR)$"), yrs = as.numeric(rownames(jags_data$Pa_obs)[observable]), ylim = c(0,1))
plot_tseries(post_summ(post, "phi_O1_O2[.+,1]$"), main = TeX("$O_1 \\rightarrow O_2\\,(NOR)$"), yrs = as.numeric(rownames(jags_data$Pa_obs)[observable]), ylim = c(0,1))
plot_tseries(post_summ(post, "phi_O1_O2[.+,2]$"), main = TeX("$O_1 \\rightarrow O_2\\,(HOR)$"), yrs = as.numeric(rownames(jags_data$Pa_obs)[observable]), ylim = c(0,1))
plot_tseries(post_summ(post, "phi_O2_O3[.+,1]$")[,2:(length(observable)+1)], main = TeX("$O_2 \\rightarrow O_3\\,(NOR)$"), yrs = as.numeric(rownames(jags_data$Pa_obs)[observable]), ylim = c(0,1))
plot_tseries(post_summ(post, "phi_O2_O3[.+,2]$")[,2:(length(observable)+1)], main = TeX("$O_2 \\rightarrow O_3\\,(HOR)$"), yrs = as.numeric(rownames(jags_data$Pa_obs)[observable]), ylim = c(0,1))
mtext(side = 1, outer = T, line = 0.5, "Brood Year")
mtext(side = 2, outer = T, line = 0, "Survival")
```

# Sex Apportionment

```{r sex-plots, fig.width = 7, fig.height = 4}
par(mfrow = c(1,2), oma = c(1,1,0,0))
plot_tseries(post_summ(post, "^omega[.+,1,1]$"), main = "Natural Origin", yrs = as.numeric(rownames
                                                                                           (jags_data$Pa_obs)[observable]), ylim = c(0,1))
plot_tseries(post_summ(post, "^omega[.+,1,2]$"), main = "Hatchery Origin", yrs = as.numeric(rownames(jags_data$Pa_obs)[observable]), ylim = c(0,1))
mtext(side = 1, outer = T, line = -0.5, "Brood Year")
mtext(side = 2, outer = T, line = 0, "Female Proportion of Esutary Smolts")
```

# Maturity

```{r maturity-plots, fig.width = 4, fig.height = 7}
par(mfrow = c(4,2), oma = c(1,1,0,0))
plot_tseries(post_summ(post, "^psi_O1_Rb[.+,1,1]$"), main = "Age 3 Females (Nat)", yrs = as.numeric(rownames(jags_data$Pa_obs)[observable]), ylim = c(0,1))
plot_tseries(post_summ(post, "^psi_O1_Rb[.+,1,2]$"), main = "Age 3 Females (Hat)", yrs = as.numeric(rownames(jags_data$Pa_obs)[observable]), ylim = c(0,1))
plot_tseries(post_summ(post, "^psi_O1_Rb[.+,2,1]$"), main = "Age 3 Males (Nat)", yrs = as.numeric(rownames(jags_data$Pa_obs)[observable]), ylim = c(0,1))
plot_tseries(post_summ(post, "^psi_O1_Rb[.+,2,2]$"), main = "Age 3 Males (Hat)", yrs = as.numeric(rownames(jags_data$Pa_obs)[observable]), ylim = c(0,1))
plot_tseries(post_summ(post, "^psi_O2_Rb[.+,1,1]$"), main = "Age 4 Females (Nat)", yrs = as.numeric(rownames(jags_data$Pa_obs)[observable]), ylim = c(0,1))
plot_tseries(post_summ(post, "^psi_O2_Rb[.+,1,2]$"), main = "Age 4 Females (Hat)", yrs = as.numeric(rownames(jags_data$Pa_obs)[observable]), ylim = c(0,1))
plot_tseries(post_summ(post, "^psi_O2_Rb[.+,2,1]$"), main = "Age 4 Males (Nat)", yrs = as.numeric(rownames(jags_data$Pa_obs)[observable]), ylim = c(0,1))
plot_tseries(post_summ(post, "^psi_O2_Rb[.+,2,2]$"), main = "Age 4 Males (Hat)", yrs = as.numeric(rownames(jags_data$Pa_obs)[observable]), ylim = c(0,1))

mtext(side = 1, outer = T, line = -0.5, "Brood Year")
mtext(side = 2, outer = T, line = 0, "Pr(Mature-at-Age|Alive in Ocean)")

```

# Parameter Estimates {.tabset .tabset-pills}

**Quick refresher on parameter names**
_In alphabetical order, as displayed in figures_

* `mu_omega[1]`: mean probability of being a female at ocean entry
* `mu_phi_Ma_O0`: mean probability of surviving from LGD to ocean entry
* `mu_phi_Mb_Ma`: mean probability of surviving movement from tributary to LGD (same for both LH types, different for origin types)
* `mu_phi_Pa_Mb`: mean probability of surviving overwinter in tributary (`[1]`: fall migrants, `[2]`: spring migrants)
* `mu_pi[1]`: mean probability of becoming a fall migrant LH type at end of summer
* `mu_psi_O1_Rb`: mean probability of maturing at age 3 given survived to that point (`[1]`: females, `[2]`: males)
* `mu_psi_O2_Rb`: mean probability of maturing at age 4 given did not mature at age 3 and survived to that point (`[1]`: females, `[2]`: males)

`sig_L*` are the among-year logit-normal standard deviations of these quantities. `sigma_Pb` is lognormal standard deviation of parr recruitment.

## Means

```{r mu-boxplots, fig.width = 6, fig.height = 6}
# parameters to display
keep = match_params(post, "mu")

# remove redundant elements
keep = keep[-which(keep %in% c("mu_init_recruits", "mu_omega[2]", "mu_phi_Mb_Ma[2]", "mu_pi[2]"))]

# extract posterior samples of these parameters: for drawing initial box plot
post_samples = post_subset(post, keep, T)

# calculate custom summaries of these parameters: for drawing actual box plot
post_summaries = post_summ(post, keep, probs = c(0.025, 0.25, 0.5, 0.75, 0.975))[-c(1:2),]

# graphical parameters
par(mar = c(8,3,1,1), mgp = c(2,0.3,0), tcl = -0.2)

# set up a box plot and replace the stats with the custom stats
bp = boxplot(post_samples, plot = F)
bp$stats = post_summaries

# draw the box plot
bxp(bp, ylim = c(0,1), outline = F, las = 2, boxcol = "red", medcol = "red", whiskcol = "red", staplecol = "red", boxfill = alpha("salmon", 0.5))
```

## Standard Deviations

```{r sig-boxplots, fig.width = 6, fig.height = 6}
# parameters to display
keep = match_params(post, "sig")

# remove redundant elements
keep = keep[-which(keep %in% c("sig_init_lrecruits", "sig_Lphi_Mb_Ma[2]"))]

# extract posterior samples of these parameters: for drawing initial box plot
post_samples = post_subset(post, keep, T)

# calculate custom summaries of these parameters: for drawing actual box plot
post_summaries = post_summ(post, keep, probs = c(0.025, 0.25, 0.5, 0.75, 0.975))[-c(1:2),]

# graphical parameters
par(mar = c(8,3,1,1), mgp = c(2,0.3,0), tcl = -0.2)

# set up a box plot and replace the stats with the custom stats
bp = boxplot(post_samples, plot = F)
bp$stats = post_summaries

# draw the box plot
bxp(bp, ylim = c(0,max(post_summaries)), outline = F, las = 2, boxcol = "red", medcol = "red", whiskcol = "red", staplecol = "red", boxfill = alpha("salmon", 0.5))
```

# Numerical Summaries

## Recruitment Function

```{r}
# extract posterior summaries
alpha_summ = post_summ(post, "alpha", digits = 3)
beta_summ = post_summ(post, "^beta$", digits = -3)
beta_per_peu_summ = post_summ(post, "beta_per_peu", digits = -1)
sigma_summ = post_summ(post, "sigma_Pb", digits = 3)

# create/format the table
tab = cbind(alpha_summ, beta_summ, beta_per_peu_summ, sigma_summ)
colnames(tab) = c("$\\alpha$", "$\\beta$", "$\\beta/\\mathrm{PEU}$", "$\\sigma_{Pb}$")

# produce html table
kable(tab, format.args = list(big.mark = ","), escape = F) %>%
  kable_styling(full_width = F, bootstrap_options = "condensed") %>%
  column_spec(1, bold = T)
```

## Carcass Correction Factors

```{r}
# extract posterior summaries
carc_adj = post_summ(post, "carc_adj", digits = 1)

# create/format table
x = paste0(carc_adj["mean",], " (", carc_adj["2.5%",], " -- ", carc_adj["97.5%",], ")")
names(x) = colnames(carc_adj)
tab = array_format(x)
colnames(tab) = c("Female", "Male")
rownames(tab) = c("Age 3", "Age 4", "Age 5")

# produce html table
kable(tab) %>%
  kable_styling(full_width = F, bootstrap_options = "condensed") %>%
  column_spec(1, bold = T)
```

## AR(1) Coefficients

```{r}
post_summ(post, "kappa", Rhat = TRUE, neff = TRUE, digits = 3)
```

# JAGS Model and Data {.tabset .tabset-pills}

## JAGS Model Code

```{r, comment = NA}
# print the JAGS model code
cat(model_info$jags_model_code, sep = "\n")
```

## JAGS Model Data

```{r, comment = NA}
# print the JAGS model data
model_info$jags_data
```
