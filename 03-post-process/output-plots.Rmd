---
title: "Output Summary"
subtitle: "Multi-Population Model"
output: 
  html_document:
    toc: true
    toc_float: true
params:
  scenario:
    label: "Scenario"
    value: "mvn-short"
    input: text
editor_options: 
  chunk_output_type: console
---

```{r directories, include = F}
# set root directory to the project directory: one level up from this location
knitr::opts_knit$set(root.dir = "../")
```

```{r setup, include = FALSE}
# set global knitting options
knitr::opts_chunk$set(echo = FALSE, fig.align = "center")

# load packages
source("00-packages.R")

# load all necessary functions
invisible(sapply(list.files(path = "01-functions", pattern = "\\.R$", full.names = T), source))

# set the input directory
in_dir = "02-model/model-output"

# read information from this model
model_info = readRDS(file.path(in_dir, paste0("output-", params$scenario, ".rds")))

# extract the two key structures from this object
post = model_info$post
# post = post_thin(model_info$post, keep_percent = 0.1)  # uncomment this to run document with 10% of the retained MCMC samples
jags_data = model_info$jags_data
```

```{r dimension-ids}
# the years included by the model
all_yrs = as.numeric(dimnames(jags_data$Pa_obs)[[1]])

# which years are "observable" for at least some quantities?
observable = (jags_data$kmax+1):jags_data$ny

# population names
pops = colnames(jags_data$Ra_obs)

# dimension IDs
i_fall   = 1  # fall migrants are i = 1
i_spring = 2  # spring migrants are i = 2,
o_nor    = 1  # natural origin are o = 1,
o_hor    = 2  # hatchery origin are o = 2,
j_cat    = 1  # Catherine Creek is j = 1
j_los    = 2  # Lostine River is j = 2
j_min    = 3  # Minam River is j = 3
j_ugr    = 4  # Upper Grande Ronde River is j = 4
k_3      = 1  # age 3 is k = 1
k_4      = 2  # age 4 is k = 2
k_5      = 3  # age 5 is k = 3

# ko represents "age/origin" combo
# e.g., ko = 1 is age 3 NORs
# e.g., ko = 5 is age 4 HORs
# these objects specify which elements of ko are for different aggregations of these
ko_age = list(
  ko_3 = c(1, 4),
  ko_4 = c(2, 5),
  ko_5 = c(3, 6)
)

ko_origin = list(
  ko_nor = 1:3,
  ko_hor = 4:6
)

# make the labels for which elements of the rho matrices contain unique elements
dummy_cols = matrix(rep(1:jags_data$nj, each = jags_data$nj), jags_data$nj, jags_data$nj)
dummy_rows = matrix(rep(1:jags_data$nj, jags_data$nj), jags_data$nj, jags_data$nj)
vcov_cols = dummy_cols[lower.tri(dummy_cols)]
vcov_rows = dummy_rows[lower.tri(dummy_rows)]
vcov_labels = paste0(pops[vcov_rows], "-", pops[vcov_cols])
```

# MCMC Information {.tabset .tabset-pills}

## Time Information

```{r mcmc-time-info}
# Calculate hours per 10,000 iterations
hrs_per_ten_thousand_iters = with(model_info$jags_dims, {
  # calculation of total iters differs if parallel or not
  if (parallel) {
    total_iters = n_adapt + n_post + n_burn
  } else {
    total_iters = (n_adapt + n_post + n_burn) * n_chains
  }
  ten_thousands_of_total_iters = total_iters/10000
  
  # calculate hours elapsed
  time_diff = as.POSIXct.default(model_info$jags_time["stoptime"]) - as.POSIXct.default(model_info$jags_time["starttime"])
  time_number = as.numeric(time_diff)
  time_units = attributes(time_diff)$units
  hour_convert = switch(time_units,
                        "secs" = 3600,
                        "mins" = 60,
                        "hours" = 1,
                        "days" = 1/24)
  hours_diff = time_number/hour_convert
  
  # calculate/round rate
  round(hours_diff/ten_thousands_of_total_iters, 2)
})

# combine relevant info into a data frame
df = data.frame(Value = c(model_info$jags_time, ifelse(model_info$jags_dims$parallel, "Yes", "No"), hrs_per_ten_thousand_iters))
rownames(df) = c("Time Started", "Time Ended", "Time Elapsed", "Chains Ran in Parallel?", "Hours Per 10,000 Iterations")

# make a kable for printing in output
kable(df) %>%
  kable_styling(full_width = F, bootstrap_options = "condensed") %>%
  column_spec(1, bold = TRUE)
```

## Attributes

This table shows some dimensions of the MCMC run.

```{r mcmc-dims}
# query the dimensions of the posterior samples
dims = post_dim(post)

# build a data frame for printing
df = data.frame(Quantity = c("Burn-in + Adapt Iters", "Post Burn-in Iters", "Thinning Interval", "Chains", "Saved Iters", "Monitored Quantities"), Value = unname(dims))

# render the table
kable(df, format.args = list(big.mark = ",")) %>%
  kable_styling(full_width = F, bootstrap_options = c("striped", "condensed")) %>%
  column_spec(1, bold = TRUE)
```

## Diagnostic Summaries

```{r mcmc-diag-function}
# a function to get MCMC diagnoses for a group of parameters
# params: a string to match with postpack::match_params()
# L1: a "Level-1" group label; such as component of the model (e.g., LH apportionment)
# L2: a "Level-2" group label; such as type of parameter (e.g., mean, sd, or year-specific value)
# L3: a "Level-3" group label; such as NOR or HOR


diag_fn = function(params, L1 = NA, L2 = NA, L3 = NA) {
  
  # extract the posteriors of interest and format for 'posterior' package
  post_sub = as_draws_df(post_subset(post, params))

  # summarize the posteriors
  diags = summarize_draws(post_sub, mean, ~quantile(.x, c(0.025, 0.975)), rhat, ess_mean, ~ess_quantile(.x, probs = c(0.025, 0.975)), mcse_mean, ~mcse_quantile(.x, probs = c(0.025, 0.975)))
  
  # discard any parameters that were the same value every MCMC iteration
  # (will have an NA for rhat)
  diags = diags[!is.na(diags$rhat),]
  
  # add "Monte Carlo CV"
  diags$mccv_mean = diags$mcse_mean/diags$mean
  diags$mccv_q2.5 = diags$mcse_q2.5/diags$`2.5%`
  diags$mccv_q97.5 = diags$mcse_q97.5/diags$`97.5%`
  
  # summarize the summaries
  out = data.frame(
    L1 = L1,
    L2 = L2,
    L3 = L3,
    match = params,
    n_params = nrow(diags),
    Rhat_1.05 = sum(diags$rhat >= 1.05),
    Rhat_1.1 = sum(diags$rhat >= 1.1),
    Rhat_1.2 = sum(diags$rhat >= 1.2),
    ess_mean_400 = sum(diags$ess_mean < 400),
    ess_q2.5_400 = sum(diags$ess_q2.5 < 400),
    ess_q97.5_400 = sum(diags$ess_q97.5 < 400),
    mccv_mean_0.05 = sum(diags$mccv_mean > 0.05),
    mccv_q2.5_0.05 = sum(diags$mccv_q2.5 > 0.05),
    mccv_q97.5_0.05 = sum(diags$mccv_q97.5 > 0.05)
  )
  
  # return the summarized summaries
  return(out)
}

```

```{r calculate-mcmc-diagnostics}
# parr recruitment
L1 = "Parr Recruitment"
L2 = c("BH Productivity", "BH Capacity", "Process SD", "Among-pop Correlation", "Parr States")
match = c("alpha", "^beta[", "sig_lPb", "rho_lPb", "^Pb[")
parr_recruit_diags = unlist_dfs(lapply(1:length(match), function(i) diag_fn(match[i], L1 = L1, L2 = L2[i])))

# LH apportionment
L1 = "Life History Apportionment"
L2 = c("Mean", "Process SD", "Among-pop Correlation", "Realized")
match = c("mu_pi[1,.]", "sig_Lpi", "rho_Lpi", "^pi[.+,1,.]")
pi_diags = unlist_dfs(lapply(1:length(match), function(i) diag_fn(match[i], L1 = L1, L2 = L2[i])))

# Overwinter survival
L1 = "Overwinter Survival"
L2 = c("Intercept", "Slope", "Process SD", "Among-pop Correlation", "Realized")
base = list("gamma0[LH_type,pop]", "gamma1[LH_type,pop]", "sig_Lphi_Pa_Mb[LH_type,pop]", "rho_Lphi_Pa_Mb[.,.,LH_type]", "^phi_Pa_Mb[year,LH_type,pop]")
match = sub_index(base, year = ".+", LH_type = i_fall, pop = ".")
tmp1 = unlist_dfs(lapply(1:length(match), function(i) diag_fn(match[i], L1 = L1, L2 = L2[i], L3 = "Fall Migrants")))
match = sub_index(base, year = ".+", LH_type = i_spring, pop = ".")
tmp2 = unlist_dfs(lapply(1:length(match), function(i) diag_fn(match[i], L1 = L1, L2 = L2[i], L3 = "Spring Migrants")))
phi_Pa_Mb_diags = rbind(tmp1, tmp2)

# Migration survival: trib to LGR
L1 = "Migration Survival (Trib to LGR)"
L2 = c("Mean", "Process SD", "Among-pop Correlation", "Realized")
base = list("mu_phi_Mb_Ma[LH_type,origin,pop]", "sig_Lphi_Mb_Ma[pop,origin]", "rho_Lphi_Mb_Ma[.,.,origin]", "phi_Mb_Ma[year,LH_type,origin,pop]")
match = sub_index(base, year = ".+", LH_type = i_spring, origin = o_nor, pop = ".")
tmp1 = unlist_dfs(lapply(1:length(match), function(i) diag_fn(match[i], L1 = L1, L2 = L2[i], L3 = "NOR")))
match = sub_index(base, year = ".+", LH_type = i_spring, origin = o_hor, pop = ".")
tmp2 = unlist_dfs(lapply(1:length(match), function(i) diag_fn(match[i], L1 = L1, L2 = L2[i], L3 = "HOR")))
phi_Mb_Ma_diags = rbind(tmp1, tmp2)

# Migration survival: LGR to BON
L1 = "Migration Survival (LGR to Ocean)"
L2 = c("Mean", "Process SD", "Realized")
base = c("mu_phi_Ma_O0[origin]", "sig_Lphi_Ma_O0[origin]", "phi_Ma_O0[year,origin]")
match = sub_index(base, year = ".+", origin = o_nor)
tmp1 = unlist_dfs(lapply(1:length(match), function(i) diag_fn(match[i], L1 = L1, L2 = L2[i], L3 = "NOR")))
match = sub_index(base, year = ".+", origin = o_hor)
tmp2 = unlist_dfs(lapply(1:length(match), function(i) diag_fn(match[i], L1 = L1, L2 = L2[i], L3 = "HOR")))
tmp3 = diag_fn("rho_Lphi_Ma_O0[2,1]", L1 = "Migration Survival (LGR to Ocean)", L2 = "Among-origin Correlation")
phi_Ma_O0_diags = rbind(tmp1, tmp2, tmp3)

# Probability of Maturing at Age-3
L1 = "Pr(Mature at Age-3)"
L2 = c("Mean", "Process SD", "Among-pop Correlation", "Realized")
base = c("mu_psi_O1_Rb[origin,pop]", "sig_Lpsi_O1_Rb[origin,pop]", "rho_Lpsi_O1_Rb[.,.,origin]", "psi_O1_Rb[.+,origin,pop]")
match = sub_index(base, year = ".+", origin = o_nor, pop = ".")
tmp1 = unlist_dfs(lapply(1:length(match), function(i) diag_fn(match[i], L1 = L1, L2 = L2[i], L3 = "NOR")))
match = sub_index(base, year = ".+", origin = o_hor, pop = ".")
tmp2 = unlist_dfs(lapply(1:length(match), function(i) diag_fn(match[i], L1 = L1, L2 = L2[i], L3 = "HOR")))
psi_O1_Rb_diags = rbind(tmp1, tmp2)

# Probability of Maturing at Age-4
L1 = "Pr(Mature at Age-4)"
L2 = c("Mean", "Process SD", "Among-pop Correlation", "Realized")
base = c("mu_psi_O2_Rb[origin,pop]", "sig_Lpsi_O2_Rb[origin,pop]", "rho_Lpsi_O1_Rb[.,.,origin]", "psi_O2_Rb[.+,origin,pop]")
match = sub_index(base, year = ".+", origin = o_nor, pop = ".")
tmp1 = unlist_dfs(lapply(1:length(match), function(i) diag_fn(match[i], L1 = L1, L2 = L2[i], L3 = "NOR")))
match = sub_index(base, year = ".+", origin = o_hor, pop = ".")
tmp2 = unlist_dfs(lapply(1:length(match), function(i) diag_fn(match[i], L1 = L1, L2 = L2[i], L3 = "HOR")))
psi_O2_Rb_diags = rbind(tmp1, tmp2)

# Year 1 ocean survival
L1 = "Year 1 Ocean Survival"
L2 = c("Mean", "Process SD", "Among-pop Correlation", "Realized")
base = c("mu_phi_O0_O1[origin,pop]", "sig_Lphi_O0_O1[pop]", "rho_Lphi_O0_O1", "phi_O0_O1[year,origin,pop]")
match = sub_index(base, year = ".+", origin = o_nor, pop = ".+")
phi_O0_O1_diags = unlist_dfs(lapply(1:length(match), function(i) diag_fn(match[i], L1 = L1, L2 = L2[i])))

# Year 2 ocean survival
L1 = "Year 2&3 Ocean Survival"
L2 = c("Mean")
base = c("mu_phi_O1_O2[origin,pop]")
match = sub_index(base, year = ".+", origin = o_nor, pop = ".+")
phi_O1_O2_diags = unlist_dfs(lapply(1:length(match), function(i) diag_fn(match[i], L1 = L1, L2 = L2[i])))

# Misc ocean survival
L1 = "Misc Ocean Survival"
L2 = c("NOR:HOR Scaler", "Year 0 Residual", "AR(1) Coefficient")
base = c("O_phi_scaler_nat_hat[pop]", "Lphi_O0_O1_resid[5,1,pop]", "kappa_phi_O0_O1[pop]")
match = sub_index(base, pop = ".")
misc_ocean_surv_diags = unlist_dfs(lapply(1:length(match), function(i) diag_fn(match[i], L1 = L1, L2 = L2[i])))

# Migration survival: BON to LGR
L1 = "Migration Survival (BON to LGR)"
L2 = c("Mean", "Process SD", "Realized")
base = c("mu_phi_Rb_Ra[origin]", "sig_Lphi_Rb_Ra[origin]", "phi_Rb_Ra[year,origin]")
match = sub_index(base, year = ".+", origin = o_nor)
tmp1 = unlist_dfs(lapply(1:length(match), function(i) diag_fn(match[i], L1 = L1, L2 = L2[i], L3 = "NOR")))
match = sub_index(base, year = ".+", origin = o_hor)
tmp2 = unlist_dfs(lapply(1:length(match), function(i) diag_fn(match[i], L1 = L1, L2 = L2[i], L3 = "HOR")))
tmp3 = diag_fn("rho_Lphi_Rb_Ra[2,1]", L1 = "Migration Survival (BON to LGR)", L2 = "Among-origin Correlation")
phi_Rb_Ra_diags = rbind(tmp1, tmp2)

# Pre-spawn Survival
L1 = "Pre-spawn Survival"
L2 = c("Mean", "Process SD", "Among-pop Correlation", "Realized")
match = c("mu_phi_Sb_Sa[.]", "sig_Lphi_Sb_Sa[.]", "rho_Lphi_Sb_Sa", "phi_Sb_Sa[.+,.]")
phi_Sb_Sa_diags = unlist_dfs(lapply(1:length(match), function(i) diag_fn(match[i], L1 = L1, L2 = L2[i])))

# Carcass Correction
L1 = "Carcass Correction Factor"
L2 = c("Among-Pop Mean", "Among-Pop SD", "Pop-Specific")
match = c("mu_z[.]", "sig_z[.]", "^z[.,.]")
z_diags = unlist_dfs(lapply(1:length(match), function(i) diag_fn(match[i], L1 = L1, L2 = L2[i])))

# Initial adult recruitment
L1 = "Initial Adult Recruitment"
L2 = c("Mean", "Realized")
match = c("mu_init_recruits[.]", "^init_recruits[.+,.]")
init_diags = unlist_dfs(lapply(1:length(match), function(i) diag_fn(match[i], L1 = L1, L2 = L2[i])))

# Straying
L1 = "Strays"
L2 = c("Realized Number", "Age Comp")
match = c("n_stray_tot[.+,.]", sub_index("stray_comp[age,origin,pop]", age = ".", origin = o_hor, pop = "."))
stray_diags = unlist_dfs(lapply(1:length(match), function(i) diag_fn(match[i], L1 = L1, L2 = L2[i])))

# combine diagnostic summaries into one massive table
diags_table = rbind(
  parr_recruit_diags,
  pi_diags,
  phi_Pa_Mb_diags,
  phi_Mb_Ma_diags,
  phi_Ma_O0_diags,
  psi_O1_Rb_diags,
  psi_O2_Rb_diags,
  phi_O0_O1_diags,
  phi_O1_O2_diags,
  phi_Rb_Ra_diags,
  phi_Sb_Sa_diags,
  misc_ocean_surv_diags,
  z_diags,
  init_diags,
  stray_diags
)

# remove any summaries for nodes that don't have diagnostics
# e.g., if that "parameter" takes on a fixed value in the model
diags_table = diags_table[diags_table$n_params > 0,]
```

This table displays summaries of MCMC diagnostics for all unobserved stochastic nodes in the model. Values in cells represent the percentage of parameters of a given type that fail a diagnostic check. E.g., 50% in the "Rhat > 1.05" column means that half of the parameters of that type had Rhat values greater than 1.05. Cells with no color indicate no offense and darker reds indicate greater frequency of an offense.

* **Rhat** measures convergence of multiple chains to a common target distribution. Values close to 1 are ideal, greater than 1.1 are problematic but possibly passable, and greater than 1.2 should not be used for inference (general rules).
* **ESS** measures the number of effective MCMC samples are available to estimate a given summary statistic of the posterior -- here the posterior mean and quantiles of the 95% equal-tailed CRI. Percentages shown represent the fraction of parameters that have fewer than 400 ESS -- which Vehtari et al. [2021](https://projecteuclid.org/journals/bayesian-analysis/advance-publication/Rank-Normalization-Folding-and-Localization--An-Improved-R%cb%86-for/10.1214/20-BA1221.full) suggest as a good rule of thumb.
* **MCCV** is Monte Carlo Standard Error of a summary statistic divided by the estimated posterior summary statistic, intended to represent a measure of precision for estimating posterior summary statistics -- here the posterior mean and quantiles of the 95% equal-tailed CRI. Percentages shown represent the fraction of parameters that have greater than 5% MCCV -- which Staton has (arbitrarily and at this time) chosen as the greatest amount of acceptable imprecision.

The calculations behind this table are implemented using the '[posterior](https://mc-stan.org/posterior/articles/posterior.html)' R package, which contains updated MCMC diagnostics (Vehtari et al. [2021](https://projecteuclid.org/journals/bayesian-analysis/advance-publication/Rank-Normalization-Folding-and-Localization--An-Improved-R%cb%86-for/10.1214/20-BA1221.full)).

```{r mcmc-diag-table}
# duplicate the diagnostic output
kable_table = diags_table

# order the rows
kable_table$L1 = factor(kable_table$L1, levels = unique(kable_table$L1))
kable_table = diags_table[order(kable_table$L1, kable_table$L2, kable_table$L3),]

# keep only relevant columns for kable
kable_table = kable_table[,-which(colnames(diags_table) %in% c("match", "mean_value", "Rhat_mean", "ess_bulk_mean"))]

# convert counts of offending parameters to percentages
kable_table$Rhat_1.05 = paste0(round(kable_table$Rhat_1.05/kable_table$n_params, 2) * 100, "%")
kable_table$Rhat_1.1 = paste0(round(kable_table$Rhat_1.1/kable_table$n_params, 2) * 100, "%")
kable_table$Rhat_1.2 = paste0(round(kable_table$Rhat_1.2/kable_table$n_params, 2) * 100, "%")
kable_table$ess_mean_400 = paste0(round(kable_table$ess_mean_400/kable_table$n_params, 2) * 100, "%")
kable_table$ess_q2.5_400 = paste0(round(kable_table$ess_q2.5_400/kable_table$n_params, 2) * 100, "%")
kable_table$ess_q97.5_400 = paste0(round(kable_table$ess_q97.5_400/kable_table$n_params, 2) * 100, "%")
kable_table$mccv_mean_0.05 = paste0(round(kable_table$mccv_mean_0.05/kable_table$n_params, 2) * 100, "%")
kable_table$mccv_q2.5_0.05 = paste0(round(kable_table$mccv_q2.5_0.05/kable_table$n_params, 2) * 100, "%")
kable_table$mccv_q97.5_0.05 = paste0(round(kable_table$mccv_q97.5_0.05/kable_table$n_params, 2) * 100, "%")

# add basic formatting
colnames(kable_table) = c("Model Component", "Parameter Type", "Group", "N", "> 1.05", "> 1.1", "> 1.2", "Mean", "q2.5", "q97.5", "Mean", "q2.5", "q97.5")
kable_table$Group[is.na(kable_table$Group)] = " "
kable_table$`Parameter Type`[is.na(kable_table$`Parameter Type`)] = " "

assign_color = function(x, colors = c("white","red")) {
  pal = colorRampPalette(colors)
  cols = pal(6)
  bin_names = levels(cut(rbeta(1e6, 1, 1) * 100, breaks = c(0,0.001,20,40,60,80,100), include.lowest = TRUE))
  names(cols) = bin_names
  bins = cut(x, breaks = c(0,0.001,20,40,60,80,100), include.lowest = TRUE)
  cols_use = cols[as.character(bins)]
  alpha(unname(cols_use), 0.5)
}

# produce the kable
kable(kable_table, row.names = FALSE, align = c("lllcccccccccc")) %>%
  kable_styling(full_width = TRUE, fixed_thead = TRUE, bootstrap_options = c("striped", "condensed")) %>%
  add_header_above(c(" " = 4, "Rhat" = 3, "ESS < 400" = 3, "MCCV > 5%" = 3)) %>%
  column_spec(2:3, width = "150px") %>%
  column_spec(c(4,7,10), border_right = TRUE) %>%
  column_spec(5, background = assign_color(as.numeric(stringr::str_remove(kable_table[,5], "%")))) %>%
  column_spec(6, background = assign_color(as.numeric(stringr::str_remove(kable_table[,6], "%")))) %>%
  column_spec(7, background = assign_color(as.numeric(stringr::str_remove(kable_table[,7], "%")))) %>%
  column_spec(8, background = assign_color(as.numeric(stringr::str_remove(kable_table[,8], "%")))) %>%
  column_spec(9, background = assign_color(as.numeric(stringr::str_remove(kable_table[,9], "%")))) %>%
  column_spec(10, background = assign_color(as.numeric(stringr::str_remove(kable_table[,10], "%")))) %>%
  column_spec(11, background = assign_color(as.numeric(stringr::str_remove(kable_table[,11], "%")))) %>%
  column_spec(12, background = assign_color(as.numeric(stringr::str_remove(kable_table[,12], "%")))) %>%
  column_spec(13, background = assign_color(as.numeric(stringr::str_remove(kable_table[,13], "%")))) %>%
  collapse_rows(columns = 1:2)
```

## WAIC

WAIC is a measure of model parsimony. The quantity `pD` is an index of model complexity (i.e., "effective parameters") and `deviance` is an index of model fit to the data. There are two methods of calculating `pD`, both are shown below. As for other measures like AIC or BIC, these numbers are really only relevant for comparing among models fitted to the same data set.

```{r calculate-waic}
summarize_lppd = function(param, LH_type = NULL, origin = NULL, pop = NULL) {
  # calculate total lppd summed across all data sets within a given year
  total_lppd = sapply(observable, function(y) rowSums(post_subset(post, sub_index(param, year = y, LH_type = LH_type, origin = origin, pop = pop), matrix = TRUE)))
  
  tmp_log = log(apply(exp(total_lppd), 2, mean))
  tmp_sum = -2 * sum(tmp_log)
  
  pD1 = 2 * sum(tmp_log - apply(total_lppd, 2, mean))
  pD2 = sum(apply(total_lppd, 2, var))
  round(c(deviance = tmp_sum, pD1 = pD1, pD2 = pD2, WAIC1 = tmp_sum + 2 * pD1, WAIC2 = tmp_sum + 2 * pD2))
}

waic_out = summarize_lppd("_lppd[year,.+]$")

waic_out = as.data.frame(as.list(waic_out))
waic_out %>%
  kbl(format.args = list(big.mark = ",")) %>%
  kable_styling(full_width = FALSE, bootstrap_options = c("condensed"))
```

## Posterior Predictive Checks

This output is a diagnostic of the consistency of variability in the data with the variability assumed by the model. For each observed data point and MCMC iteration, a value was simulated from the model. The fit of the observed and simulated data was calculated, and the proportion of MCMC iterations in which the observed data fitted more poorly than the simulated data (i.e., a Bayesian p-value) was calculated. P-values close the 0.5 are ideal (0.4 -- 0.6 have no color below), values closer to 1 (red below) indicate over-dispersion (i.e., model fits real data worse than expected), and values closer to 0 (blue below) indicate under-dispersion (i.e., model fits real data better than expected). Across years within a data set, p-values were summarized as the median and central 95% intervals. The left two columns show the percent of years that had extreme p-values, providing another indication of how often the model fit the real data far better (<0.05) or worse (>0.95) than expected.

The fit criterion differed depending on the likelihood function used to fit the model to the data set:

* **Log-normal**: squared difference of the log-scale observation and log-scale expectation. This applies to all abundance data.
* **Logit-normal**: squared difference of the logit-scale observation and logit-scale expectation. This applies to all survival data, expect pre-spawn survival which used a binomial distribution.
* **Binomial/Multinomial**: chi-squared fit statistic. This applies to all composition data and the pre-spawn survival data.

```{r calculate-bayesian-pvals}
# function to summarize bayesian p-values within a data source
summarize_bp = function(bp) {
  data.frame(
    "N" = apply(bp, 2, function(x) sum(!is.na(x))),
    "median" = apply(bp, 2, median, na.rm = TRUE),
    "q2.5" = apply(bp, 2, function(x) quantile(x, 0.025, na.rm = TRUE)),
    "q97.5" = apply(bp, 2, function(x) quantile(x, 0.975, na.rm = TRUE)),
    "p_lt_0.05" = apply(bp, 2, function(x) sum(x < 0.05 & !is.na(x))/sum(!is.na(x))),
    "p_gt_0.95" = apply(bp, 2, function(x) sum(x > 0.95 & !is.na(x))/sum(!is.na(x)))
  )
}

### CALCULATE BAYESIAN P-VALUES: ABUNDANCE DATA SOURCES ###

# fall trap
new = post_subset(post, "Pa_obs_new_dev", TRUE)
obs = post_subset(post, "Pa_obs_dev", TRUE)
bp = array_format(colMeans(obs > new))
dimnames(bp) = list(all_yrs[1:dim(bp)[1]], "fall-mig", pops)
bp = bp[,"fall-mig",]
Pa_bp = data.frame(
  name = rep("Juveniles", 4), pop = pops,
  origin = rep("NOR", 4), LH_type = rep("Fall Migrants", 4),
  summarize_bp(bp)
)
rownames(Pa_bp) = NULL

# spring trap
new = post_subset(post, "Mb_obs_new_dev", TRUE)
obs = post_subset(post, "Mb_obs_dev", TRUE)
bp = array_format(colMeans(obs > new))
dimnames(bp) = list(all_yrs[1:dim(bp)[1]], c("fall-mig", "spring-mig"), "NOR", pops)
bp = bp[,"spring-mig","NOR",]
Mb_bp = data.frame(
  name = rep("Juveniles", 4), pop = pops,
  origin = rep("NOR", 4), LH_type = rep("Spring Migrants", 4),
  summarize_bp(bp)
)
rownames(Mb_bp) = NULL

# adult abundance
new = post_subset(post, "Ra_obs_new_dev", TRUE)
obs = post_subset(post, "Ra_obs_dev", TRUE)
bp = array_format(colMeans(obs > new))
dimnames(bp) = list(all_yrs[1:dim(bp)[1]], pops)
Ra_bp = data.frame(
  name = rep("Adults", 4), pop = pops,
  origin = rep("Combined", 4), LH_type = rep("Combined", 4),
  summarize_bp(bp)
)
rownames(Ra_bp) = NULL

### CALCULATE BAYESIAN P-VALUES: SURVIVAL DATA SOURCES ###

# summer tagging survival
new = post_subset(post, "Lphi_obs_new_Pb_Ma_dev", TRUE)
obs = post_subset(post, "Lphi_obs_Pb_Ma_dev", TRUE)
bp = array_format(colMeans(obs > new))
dimnames(bp) = list(all_yrs[1:dim(bp)[1]], pops)
phi_Pb_Ma_bp = data.frame(
  name = rep("Summer Tagging to LGR", 4), pop = pops,
  origin = rep("NOR", 4), LH_type = rep("Combined", 4),
  summarize_bp(bp)
)
rownames(phi_Pb_Ma_bp) = NULL

# fall trap survival
new = post_subset(post, "Lphi_obs_new_Pa_Ma_dev", TRUE)
obs = post_subset(post, "Lphi_obs_Pa_Ma_dev", TRUE)
bp = array_format(colMeans(obs > new))
dimnames(bp) = list(all_yrs[1:dim(bp)[1]], "fall-mig", pops)
bp = bp[,"fall-mig",]
phi_Pa_Ma_bp = data.frame(
  name = rep("Fall Trap to LGR", 4), pop = pops,
  origin = rep("NOR", 4),   LH_type = rep("Fall Migrants", 4),
  summarize_bp(bp)
)
rownames(phi_Pa_Ma_bp) = NULL

# trib to lgr survival
new = post_subset(post, "Lphi_obs_new_Mb_Ma_dev", TRUE)
obs = post_subset(post, "Lphi_obs_Mb_Ma_dev", TRUE)
bp = array_format(colMeans(obs > new))
dimnames(bp) = list(all_yrs[1:dim(bp)[1]], c("fall-mig", "spring-mig"), c("NOR", "HOR"), pops)
bp = bp[,"spring-mig",,]
bp = cbind(CAT_NOR = bp[,"NOR","CAT"], CAT_HOR = bp[,"HOR","CAT"],
           LOS_NOR = bp[,"NOR","LOS"], LOS_HOR = bp[,"HOR","LOS"],
           MIN_NOR = bp[,"NOR","MIN"], MIN_HOR = bp[,"HOR","MIN"],
           UGR_NOR = bp[,"NOR","UGR"], UGR_HOR = bp[,"HOR","UGR"])
phi_Mb_Ma_bp = data.frame(
  name = rep("Spring Trap/Release to LGR", 8), pop = rep(pops, each = 2),
  origin = rep(c("NOR", "HOR"), 4), LH_type = rep("Spring Migrants", 8),
  summarize_bp(bp)
)
rownames(phi_Mb_Ma_bp) = NULL

# hydropower survival
new = post_subset(post, "Lphi_obs_new_Ma_O0_dev", TRUE)
obs = post_subset(post, "Lphi_obs_Ma_O0_dev", TRUE)
bp = array_format(colMeans(obs > new))
dimnames(bp) = list(all_yrs[1:dim(bp)[1]], c("NOR", "HOR"))
phi_Ma_O0_bp = data.frame(
  name = rep("Hydrosystem (Downstream)", 2), pop = rep("Combined", 2),
  origin = c("NOR", "HOR"), LH_type = rep("Combined", 2),
  summarize_bp(bp)
)
rownames(phi_Ma_O0_bp) = NULL

### CALCULATE BAYESIAN P-VALUES: COMPOSITION DATA SOURCES ###

# weir composition
new = post_subset(post, "weir_x_obs_new_dev", TRUE)
obs = post_subset(post, "weir_x_obs_dev", TRUE)
bp = array_format(colMeans(obs > new))
dimnames(bp) = list(all_yrs[1:dim(bp)[1]], pops)
bp[jags_data$weir_nx_obs == 0 | is.na(jags_data$weir_nx_obs)] = NA
weir_x_bp = data.frame(
  name = rep("Weir", 4), pop = pops,
  origin = rep("Combined", 4), LH_type = rep("Combined", 4),
  summarize_bp(bp)
)
rownames(weir_x_bp) = NULL

# carcass composition
new = post_subset(post, "carc_x_obs_new_dev", TRUE)
obs = post_subset(post, "carc_x_obs_dev", TRUE)
bp = array_format(colMeans(obs > new))
dimnames(bp) = list(all_yrs[1:dim(bp)[1]], pops)
bp[jags_data$carc_nx_obs == 0 | is.na(jags_data$carc_nx_obs)] = NA
carc_x_bp = data.frame(
  name = rep("Carcasses", 4), pop = pops,
  origin = rep("Combined", 4), LH_type = rep("Combined", 4),
  summarize_bp(bp)
)
rownames(carc_x_bp) = NULL

# pre-spawn survival
new = post_subset(post, "carcs_spawned_new_dev", TRUE)
obs = post_subset(post, "carcs_spawned_dev", TRUE)
bp = array_format(colMeans(obs > new))
dimnames(bp) = list(all_yrs[1:dim(bp)[1]], pops)
carcs_spawned_bp = data.frame(
  name = rep("Prespawn", 4), pop = pops,
  origin = rep("Combined", 4), LH_type = rep("Combined", 4),
  summarize_bp(bp)
)
rownames(carcs_spawned_bp) = NULL

# movement survival from BON to LGR
new = post_subset(post, "LGR_adults_new_dev", TRUE)
obs = post_subset(post, "LGR_adults_dev", TRUE)
bp = array_format(colMeans(obs > new))
dimnames(bp) = list(all_yrs[1:dim(bp)[1]], c("NOR", "HOR"))
LGR_adults_bp = data.frame(
  name = rep("Hydrosystem (Upstream)", 2), pop = rep("Combined", 2),
  origin = c("NOR", "HOR"), LH_type = rep("Combined", 2),
  summarize_bp(bp)
)
rownames(LGR_adults_bp) = NULL

### COMBINE INTO ONE TABLE ###
bp_tab = rbind(
  Pa_bp, Mb_bp, Ra_bp,
  phi_Pb_Ma_bp, phi_Pa_Ma_bp, phi_Mb_Ma_bp,
  phi_Ma_O0_bp, weir_x_bp, carc_x_bp, carcs_spawned_bp, LGR_adults_bp
)

# add a main data category variable
category = rep(NA, nrow(bp_tab))
category = ifelse(bp_tab$name %in% c("Adults", "Juveniles"), "Abundance", category)
category = ifelse(bp_tab$name %in% c("Weir", "Carcasses"), "Composition", category)
category[is.na(category)] = "Survival"
bp_tab = data.frame(category = category, bp_tab)

# drop the several cases with no data
# MIN HOR survival to LGR and MIN weir data
bp_tab = bp_tab[bp_tab$N > 0,]

# re-order output/misc formatting
bp_tab = bp_tab[order(bp_tab$category, bp_tab$name, bp_tab$pop, bp_tab$origin),]
bp_tab = bp_tab[,c("category", "name", "pop", "LH_type", "origin", "N", "median", "q2.5", "q97.5", "p_lt_0.05", "p_gt_0.95")]
bp_tab$p_lt_0.05 = paste0(round(bp_tab$p_lt_0.05 * 100), "%")
bp_tab$p_gt_0.95 = paste0(round(bp_tab$p_gt_0.95 * 100), "%")
rownames(bp_tab) = NULL
```

```{r bayesian-pvals-table}
# a function to color cells depending on the value
assign_color = function(x) {
  red_pal = colorRampPalette(c("white", "red"))
  blue_pal = colorRampPalette(c("blue", "white"))
  red_cols = red_pal(5)
  blue_cols = blue_pal(5)
  cols = c(blue_cols, red_cols)
  bin_names = levels(cut(rbeta(1e6, 1, 1), breaks = seq(0,1,0.1), include.lowest = TRUE))
  names(cols) = bin_names
  bins = cut(x, breaks = seq(0,1,0.1), include.lowest = TRUE)
  cols_use = cols[as.character(bins)]
  alpha(unname(cols_use), 0.5)
}

# produce the kable
bp_tab %>%
  kbl(digits = 2, col.names = c("Class", "Lifestage", "Population", "Migratory Type", "Origin", "Years w/Data", "Median", "2.5%", "97.5%", "<0.05", ">0.95"),
      align = c("lllllcccccc")) %>%
  kable_styling(full_width = FALSE, bootstrap_options = c("condensed")) %>%
  add_header_above(c("Data Type Information" = 5, "P-value Summaries" = 4, "% of Extreme P-values" = 2)) %>%
  column_spec(7, background = assign_color(bp_tab[,7])) %>%
  column_spec(8, background = assign_color(bp_tab[,8])) %>%
  column_spec(9, background = assign_color(bp_tab[,9])) %>%
  collapse_rows(1:5) 
```

# Fit to Data

In all figures below, the thick red line is the posterior median value each year, the red region is the equal-tailed 95% credible interval, and blue points are "observed" data (estimated from raw data external to the model).

## Abundance Data {.tabset .tabset-pills}

### Fall Parr Abundance

```{r fall-trap-N-fit, fig.width = 6, fig.height = 5}
plot_f = function(j) {
  plot_tseries(post_summ(post, sub_index("^Pa[.+,LH_type,pop]$", LH_type = i_fall, pop = j)),
               get_obs_ests_log_normal(log(jags_data$Pa_obs[observable,i_fall,j]), jags_data$sig_Pa_obs[observable,i_fall,j]),
               main = pops[j])
}

par(mfrow = c(2,2), oma = c(1.5,1.5,0,0))
junk = sapply(1:jags_data$nj, plot_f)
mtext(side = 1, outer = T, line = 0.25, "Brood Year")
mtext(side = 2, outer = T, line = 0.25, "Fall Parr Abundance")
```

### Spring Smolt Abundance

```{r spring-trap-N-fit, fig.width = 6, fig.height = 5}
plot_f = function(j) {
  plot_tseries(post_summ(post, sub_index("^Mb[.+,LH_type,origin,pop]$", origin = o_nor, LH_type = i_spring, pop = j)), 
               get_obs_ests_log_normal(log(jags_data$Mb_obs[observable,i_spring,o_nor,j]), jags_data$sig_Mb_obs[observable,i_spring,o_nor,j]),
               main = pops[j])
}

par(mfrow = c(2,2), oma = c(1.5,1.5,0,0))
junk = sapply(1:jags_data$nj, plot_f)
mtext(side = 1, outer = T, line = 0.25, "Brood Year")
mtext(side = 2, outer = T, line = 0.25, "Spring Smolt Abundance")
```

### Adult Return Abundance

```{r adult-N-fit, fig.width = 6, fig.height = 5}
plot_f = function(j) {
  plot_tseries(post_summ(post, sub_index("^Ra_tot[.+,pop]$", pop = j)),
               get_obs_ests_log_normal(log(jags_data$Ra_obs[observable,j]), jags_data$sig_Ra_obs[observable,j]),
               main = pops[j])
}

par(mfrow = c(2,2), oma = c(1.5,1.5,0,0))
junk = sapply(1:jags_data$nj, plot_f)
mtext(side = 1, outer = T, line = 0.25, "Return Year")
mtext(side = 2, outer = T, line = 0.25, "Adult Return Abundance")
```

## Survival Data {.tabset .tabset-pills}

### Summer Parr $\rightarrow$ LGR

```{r summer-surv-fit, fig.width = 6, fig.height = 5}
plot_f = function(j) {
  plot_tseries(post_summ(post, sub_index("^phi_Pb_Ma[.+,pop]", pop = j)),
               get_obs_ests_logit_normal(jags_data$Lphi_obs_Pb_Ma[observable,j], jags_data$sig_Lphi_obs_Pb_Ma[observable,j]),
               main = pops[j])
}

par(mfrow = c(2,2), oma = c(1.5,1.5,0,0))
junk = sapply(1:jags_data$nj, plot_f)
mtext(side = 1, outer = T, line = 0.25, "Brood Year")
mtext(side = 2, outer = T, line = 0.25, TeX("$Summer\\,Parr \\rightarrow LGR\\,Survival$"))
```

### Fall Parr $\rightarrow$ LGR

```{r fall-surv-fit, fig.width = 6, fig.height = 5}
plot_f = function(j) {
  plot_tseries(post_summ(post, sub_index("^phi_Pa_Ma[.+,LH_type,pop]$", LH_type = i_fall, pop = j)),
               get_obs_ests_logit_normal(jags_data$Lphi_obs_Pa_Ma[observable,i_fall,j], jags_data$sig_Lphi_obs_Pa_Ma[observable,i_fall,j]),
               main = pops[j])
}

par(mfrow = c(2,2), oma = c(1.5,1.5,0,0))
junk = sapply(1:jags_data$nj, plot_f)
mtext(side = 1, outer = T, line = 0.25, "Brood Year")
mtext(side = 2, outer = T, line = 0.25, TeX("$Fall\\,Parr \\rightarrow LGR\\,Survival$"))
```

### Spring Smolt $\rightarrow$ LGR (NOR)

```{r spring-surv-fit-nor, fig.width = 6, fig.height = 5}
plot_f = function(j) {
  plot_tseries(post_summ(post, sub_index("^phi_Mb_Ma[.+,LH_type,origin,pop]$",LH_type = i_spring, origin = o_nor, pop = j)),
               get_obs_ests_logit_normal(jags_data$Lphi_obs_Mb_Ma[observable,i_spring,o_nor,j], jags_data$sig_Lphi_obs_Mb_Ma[observable,i_spring,o_nor,j]),
               main = pops[j])
}

par(mfrow = c(2,2), oma = c(1.5,1.5,0,0))
junk = sapply(1:jags_data$nj, plot_f)
mtext(side = 1, outer = T, line = 0.25, "Brood Year")
mtext(side = 2, outer = T, line = 0.25, TeX("$Spring\\,Smolt \\rightarrow LGR\\,Survival\\,(NOR)$"))
```

### Spring Smolt $\rightarrow$ LGR (HOR)

```{r spring-surv-fit-hor, fig.width = 6, fig.height = 5}
plot_f = function(j) {
  plot_tseries(post_summ(post, sub_index("^phi_Mb_Ma[.+,LH_type,origin,pop]$", LH_type = i_spring, origin = o_hor, pop = j)),
               get_obs_ests_logit_normal(jags_data$Lphi_obs_Mb_Ma[observable,i_spring,o_hor,j], jags_data$sig_Lphi_obs_Mb_Ma[observable,i_spring,o_hor,j]),
               main = pops[j])
}

par(mfrow = c(2,2), oma = c(1.5,1.5,0,0))
junk = sapply(1:jags_data$nj, plot_f)
mtext(side = 1, outer = T, line = 0.25, "Brood Year")
mtext(side = 2, outer = T, line = 0.25, TeX("$Spring\\,Smolt \\rightarrow LGR\\,Survival\\,(HOR)"))
```

### LGR Smolt $\rightarrow O_0$ (NOR)

```{r hydro-nor-surv-fit, fig.width = 6, fig.height = 5}
par(oma = c(1.5,1.5,0,0), mfrow = c(1,1))
plot_tseries(post_summ(post, sub_index("^phi_Ma_O0[.+,origin]$", origin = o_nor)),
             get_obs_ests_logit_normal(jags_data$Lphi_obs_Ma_O0[observable,o_nor], jags_data$sig_Lphi_obs_Ma_O0[observable,o_nor]),
             main = TeX("$LGR\\,Smolt \\rightarrow O_0\\,Survival\\,(NOR)"))
mtext(side = 1, outer = T, line = 0.25, "Brood Year")
mtext(side = 2, outer = T, line = 0.25, "Survival")
```

### LGR Smolt $\rightarrow O_0$ (HOR)

```{r hydro-hor-surv-fit, fig.width = 6, fig.height = 5}
par(oma = c(1.5,1.5,0,0), mfrow = c(1,1))
plot_tseries(post_summ(post, sub_index("^phi_Ma_O0[.+,origin]$", origin = o_hor)),
             get_obs_ests_logit_normal(jags_data$Lphi_obs_Ma_O0[observable,o_hor], jags_data$sig_Lphi_obs_Ma_O0[observable,o_hor]),
             main = TeX("$LGR\\,Smolt \\rightarrow O_0\\,Survival\\,(HOR)"))
mtext(side = 1, outer = T, line = 0.25, "Brood Year")
mtext(side = 2, outer = T, line = 0.25, "Survival")
```

### BON Adults $\rightarrow$ LGR (NOR)

```{r BON-LGR-surv-fit-nor, fig.width = 6, fig.height = 5}
par(oma = c(1.5,1.5,0,0), mfrow = c(1,1))
plot_tseries(post_summ(post, sub_index("^phi_Rb_Ra[.+,origin]$", origin = o_nor)),
             get_obs_ests_multinomial(cbind(jags_data$LGR_adults[observable,o_nor], jags_data$BON_adults[observable,o_nor] - jags_data$LGR_adults[observable,o_nor]), 1),
             main = TeX("$BON\\,Adults \\rightarrow LGR\\,Survival\\,(NOR)"))
mtext(side = 1, outer = T, line = 0.25, "Return Year")
mtext(side = 2, outer = T, line = 0.25, "Survival")
```

### BON Adults $\rightarrow$ LGR (HOR)

```{r BON-LGR-surv-fit-hor, fig.width = 6, fig.height = 5}
par(oma = c(1.5,1.5,0,0), mfrow = c(1,1))
plot_tseries(post_summ(post, sub_index("^phi_Rb_Ra[.+,origin]$", origin = o_hor)),
             get_obs_ests_multinomial(cbind(jags_data$LGR_adults[observable,o_hor], jags_data$BON_adults[observable,o_hor] - jags_data$LGR_adults[observable,o_hor]), 1),
             main = TeX("$BON\\,Adults \\rightarrow LGR\\,Survival\\,(HOR)"))
mtext(side = 1, outer = T, line = 0.25, "Return Year")
mtext(side = 2, outer = T, line = 0.25, "Survival")
```

## Composition Data {.tabset .tabset-pills .tabset-fade}

```{r calculate-aggregated-comps-model}
# extract the full posteriors of the two composition sets
q_Ra_full = post_subset(post, "q_Ra", matrix = TRUE)
q_Sa_adj_full = post_subset(post, "q_Sa", matrix = TRUE)

# primary containers: will store final recalculated output
q_Ra_age = q_Sa_adj_age = q_Ra_origin = q_Sa_adj_origin = NULL

# number of posterior samples
n = post_dim(post, "saved")

# loop through posterior samples, calculate various aggregates of composition by type
for (i in 1:n) {
  
  # format the posterior draw as arrays -- easier to subset
  q_Ra = array_format(q_Ra_full[i,])
  q_Sa_adj = array_format(q_Sa_adj_full[i,])
  
  ## BY AGE, AGGREGATED ACROSS ORIGINS
  
  # containers
  q_Ra_age_tmp = q_Sa_adj_age_tmp = array(NA, dim = c(jags_data$ny, jags_data$nk, jags_data$nj))
  inds_1_age = inds_2_age = inds_3_age = q_Ra_age_tmp
  for (j in 1:jags_data$nj) {
    for (k in 1:jags_data$nk) {
      # calculate aggregate proportions for each age
      q_Ra_age_tmp[,k,j] = rowSums(q_Ra[,ko_age[[k]],j])
      q_Sa_adj_age_tmp[,k,j] = rowSums(q_Sa_adj[,ko_age[[k]],j])
      
      # build the element identifiers - for building names later
      inds_1_age[,k,j] = 1:jags_data$ny
      inds_2_age[,k,j] = k
      inds_3_age[,k,j] = j
    }
  }
  
  # vectorize, add names, and remove NAs
  q_Ra_age_v = as.numeric(q_Ra_age_tmp)
  q_Sa_adj_age_v = as.numeric(q_Sa_adj_age_tmp)
  names(q_Ra_age_v) = paste0("q_Ra_age[", as.numeric(inds_1_age), ",", as.numeric(inds_2_age), ",", as.numeric(inds_3_age), "]")
  names(q_Sa_adj_age_v) = paste0("q_Sa_adj_age[", as.numeric(inds_1_age), ",", as.numeric(inds_2_age), ",", as.numeric(inds_3_age), "]")
  q_Ra_age_v = q_Ra_age_v[!is.na(q_Ra_age_v)]
  q_Sa_adj_age_v = q_Sa_adj_age_v[!is.na(q_Sa_adj_age_v)]
  
  ## BY ORIGIN, AGGREGATED ACROSS AGES
  
  # containers
  q_Ra_origin_tmp = q_Sa_adj_origin_tmp = array(NA, dim = c(jags_data$ny, jags_data$no, jags_data$nj))
  inds_1_origin = inds_2_origin = inds_3_origin = q_Ra_origin_tmp
  for (j in 1:jags_data$nj) {
    for (o in 1:jags_data$no) {
      # calculate aggregate proportions for each origin
      q_Ra_origin_tmp[,o,j] = rowSums(q_Ra[,ko_origin[[o]],j])
      q_Sa_adj_origin_tmp[,o,j] = rowSums(q_Sa_adj[,ko_origin[[o]],j])
      
      # build the element identifiers - for building names later
      inds_1_origin[,o,j] = 1:jags_data$ny
      inds_2_origin[,o,j] = o
      inds_3_origin[,o,j] = j
    }
  }
  
  # vectorize, add names, and remove NAs
  q_Ra_origin_v = as.numeric(q_Ra_origin_tmp)
  q_Sa_adj_origin_v = as.numeric(q_Sa_adj_origin_tmp)
  names(q_Ra_origin_v) = paste0("q_Ra_origin[", as.numeric(inds_1_origin), ",", as.numeric(inds_2_origin), ",", as.numeric(inds_3_origin), "]")
  names(q_Sa_adj_origin_v) = paste0("q_Sa_adj_origin[", as.numeric(inds_1_origin), ",", as.numeric(inds_2_origin), ",", as.numeric(inds_3_origin), "]")
  q_Ra_origin_v = q_Ra_origin_v[!is.na(q_Ra_origin_v)]
  q_Sa_adj_origin_v = q_Sa_adj_origin_v[!is.na(q_Sa_adj_origin_v)]
  
  ## COMBINE NEW CALCULATED QUANTITIES ACROSS POSTERIOR SAMPLES
  
  q_Ra_age = rbind(q_Ra_age, q_Ra_age_v)
  q_Sa_adj_age = rbind(q_Sa_adj_age, q_Sa_adj_age_v)
  q_Ra_origin = rbind(q_Ra_origin, q_Ra_origin_v)
  q_Sa_adj_origin = rbind(q_Sa_adj_origin, q_Sa_adj_origin_v)
  
}

# combine new calculated quantities into a big matrix
q_new = cbind(q_Ra_age, q_Sa_adj_age, q_Ra_origin, q_Sa_adj_origin)

# combine with the rest of the posterior samples
post = post_bind(post, q_new)

```

```{r calculate-aggregated-comps-data}

# these are the observed proportions by age (aggregated across origins) and origin (aggregated across ages)

# containers
x_weir_age_obs = x_carc_age_obs = array(NA, dim = c(jags_data$ny, jags_data$nk, jags_data$nj))
x_weir_origin_obs = x_carc_origin_obs = array(NA, dim = c(jags_data$ny, jags_data$no, jags_data$nj))

for (j in 1:jags_data$nj) {
  # calculate aggregate proportions for each age
  for (k in 1:jags_data$nk) {
    x_weir_age_obs[,k,j] = rowSums(jags_data$weir_x_obs[,ko_age[[k]],j])
    x_carc_age_obs[,k,j] = rowSums(jags_data$carc_x_obs[,ko_age[[k]],j])
  }
  
  # calculate aggregate proportions for each origin
  for (o in 1:jags_data$no) {
    x_weir_origin_obs[,o,j] = rowSums(jags_data$weir_x_obs[,ko_origin[[o]],j])
    x_carc_origin_obs[,o,j] = rowSums(jags_data$carc_x_obs[,ko_origin[[o]],j])
  }
}

dimnames(x_weir_age_obs)[[1]] = dimnames(x_weir_origin_obs)[[1]] = dimnames(x_carc_age_obs)[[1]] = dimnames(x_carc_origin_obs)[[1]] = dimnames(jags_data$weir_x_obs)[[1]]

x_weir_new_obs = list(
  x_weir_age_obs = x_weir_age_obs,
  x_weir_origin_obs = x_weir_origin_obs
)

x_carc_new_obs = list(
  x_carc_age_obs = x_carc_age_obs,
  x_carc_origin_obs = x_carc_origin_obs
)

```

Within a single year, the values across all panels sum to one.

### Weir Sampling {.tabset .tabset-pills}

```{r weir-comp-fit-funcs}

# for multinomial sample size
weir_sample_size = function(j) {
  par(mar = c(3,3,1.5,0.5), tcl = -0.15, mgp = c(2,0.35,0))
  mp = barplot(jags_data$weir_nx_obs[observable,j], xaxt = "n", col = alpha("skyblue2", 0.5), border = "blue",
               ylim = c(0, max(jags_data$weir_nx_obs[observable,j], na.rm = TRUE)),
               xlab = "Return Year", ylab = "Adults at Weir Sampled for Composition")
  usr = par("usr")
  at_x = seq(1, length(observable), 4)
  axis(side = 1, at = mp[at_x], labels = substr(names(jags_data$weir_nx_obs[observable,j]), 3, 4)[at_x])
  segments(usr[1], usr[3], usr[2], usr[3], xpd = TRUE)
}

# for completely disaggregated fits
weir_comp_fit_plot = function(j) {

  par(mfrow = c(2,3), oma = c(1.5,1.5,0,0))#, mar = c(1.5,1.5,1.5,0.5))
  plot_tseries(post_summ(post, sub_index("^q_Ra[.+,1,pop]$", pop = j)), get_obs_ests_multinomial(jags_data$weir_x_obs[observable,,j], 1), main = TeX("$Age\\,3\\,(NOR)$"))
  plot_tseries(post_summ(post, sub_index("^q_Ra[.+,2,pop]$", pop = j)), get_obs_ests_multinomial(jags_data$weir_x_obs[observable,,j], 2), main = TeX("$Age\\,4\\,(NOR)$"))
  plot_tseries(post_summ(post, sub_index("^q_Ra[.+,3,pop]$", pop = j)), get_obs_ests_multinomial(jags_data$weir_x_obs[observable,,j], 3), main = TeX("$Age\\,5\\,(NOR)$"))
  plot_tseries(post_summ(post, sub_index("^q_Ra[.+,4,pop]$", pop = j)), get_obs_ests_multinomial(jags_data$weir_x_obs[observable,,j], 4), main = TeX("$Age\\,3\\,(HOR)$"))
  plot_tseries(post_summ(post, sub_index("^q_Ra[.+,5,pop]$", pop = j)), get_obs_ests_multinomial(jags_data$weir_x_obs[observable,,j], 5), main = TeX("$Age\\,4\\,(HOR)$"))
  plot_tseries(post_summ(post, sub_index("^q_Ra[.+,6,pop]$", pop = j)), get_obs_ests_multinomial(jags_data$weir_x_obs[observable,,j], 6), main = TeX("$Age\\,5\\,(HOR)$"))
  
  mtext(side = 1, outer = T, line = 0.25, "Return Year")
  mtext(side = 2, outer = T, line = 0.25, "Proportion of Return")
}

# for fits to each age, aggregated across origins
weir_comp_fit_plot_age = function(j) {
  par(mfcol = c(1,3), oma = c(1.5,1.5,0,0))
  plot_tseries(post_summ(post, sub_index("^q_Ra_age[.+,1,pop]$", pop = j)), get_obs_ests_multinomial(x_weir_new_obs$x_weir_age_obs[observable,,j], 1), main = TeX("$Age\\,3$"), ylim = c(0,1))
  plot_tseries(post_summ(post, sub_index("^q_Ra_age[.+,2,pop]$", pop = j)), get_obs_ests_multinomial(x_weir_new_obs$x_weir_age_obs[observable,,j], 2), main = TeX("$Age\\,4$"), ylim = c(0,1))
  plot_tseries(post_summ(post, sub_index("^q_Ra_age[.+,3,pop]$", pop = j)), get_obs_ests_multinomial(x_weir_new_obs$x_weir_age_obs[observable,,j], 3), main = TeX("$Age\\,5$"), ylim = c(0,1))
  mtext(side = 1, outer = T, line = 0.25, "Return Year")
  mtext(side = 2, outer = T, line = 0.25, "Proportion of Return")
}

# for fits to each origin, aggregated across ages
weir_comp_fit_plot_origin = function(j) {
  par(mfcol = c(1,2), oma = c(1.5,1.5,0,0))
  
  plot_tseries(post_summ(post, sub_index("^q_Ra_origin[.+,1,pop]$", pop = j)), get_obs_ests_multinomial(x_weir_new_obs$x_weir_origin_obs[observable,,j], 1), main = TeX("$NOR$"), ylim = c(0,1))
  plot_tseries(post_summ(post, sub_index("^q_Ra_origin[.+,2,pop]$", pop = j)), get_obs_ests_multinomial(x_weir_new_obs$x_weir_origin_obs[observable,,j], 2), main = TeX("$HOR$"), ylim = c(0,1))
  mtext(side = 1, outer = T, line = 0.25, "Return Year")
  mtext(side = 2, outer = T, line = 0.25, "Proportion of Return")
}
```

#### By Age/Origin {.tabset .tabset-pills}

This is the resolution the model fits to: each year slice is treated as a 6-element multinomial vector.

##### CAT

```{r cat-weir-comp-fit, fig.width = 8, fig.height = 5}
weir_comp_fit_plot(j_cat)
```

##### LOS

```{r los-weir-comp-fit, fig.width = 8, fig.height = 5}
weir_comp_fit_plot(j_los)
```

##### MIN

```{r min-weir-comp-fit, fig.width = 8, fig.height = 5}
weir_comp_fit_plot(j_min)
```

##### UGR

```{r ugr-weir-comp-fit, fig.width = 8, fig.height = 5}
weir_comp_fit_plot(j_ugr)
```

#### By Age {.tabset .tabset-pills}

These figures show the agreement of the model with the weir composition data by age, aggregated across origins.

##### CAT

```{r cat-weir-comp-fit-age, fig.width = 8, fig.height = 3.5}
weir_comp_fit_plot_age(j_cat)
```

##### LOS

```{r los-weir-comp-fit-age, fig.width = 8, fig.height = 3.5}
weir_comp_fit_plot_age(j_los)
```

##### MIN

```{r min-weir-comp-fit-age, fig.width = 8, fig.height = 3.5}
weir_comp_fit_plot_age(j_min)
```

##### UGR

```{r ugr-weir-comp-fit-age, fig.width = 8, fig.height = 3.5}
weir_comp_fit_plot_age(j_ugr)
```

#### By Origin {.tabset .tabset-pills}

These figures show the agreement of the model with the weir composition data by origin, aggregated across ages.

##### CAT

```{r cat-weir-comp-fit-origin, fig.width = 8, fig.height = 4}
weir_comp_fit_plot_origin(j_cat)
```

##### LOS

```{r los-weir-comp-fit-origin, fig.width = 8, fig.height = 4}
weir_comp_fit_plot_origin(j_los)
```

##### MIN

```{r min-weir-comp-fit-origin, fig.width = 8, fig.height = 4}
weir_comp_fit_plot_origin(j_min)
```

##### UGR

```{r ugr-weir-comp-fit-origin, fig.width = 8, fig.height = 4}
weir_comp_fit_plot_origin(j_ugr)
```

#### Total Sample Size {.tabset .tabset-pills}

These figures show the number of samples gathered for age/origin composition information during carcass surveys. The model will fit more closely to years with more samples.

##### CAT

```{r cat-weir-ss, fig.width = 6, fig.height = 4}
weir_sample_size(j_cat)
```

##### LOS

```{r los-weir-ss, fig.width = 6, fig.height = 4}
weir_sample_size(j_los)
```

##### MIN

```{r min-weir-ss, fig.width = 6, fig.height = 4}
weir_sample_size(j_min)
```

##### UGR

```{r ugr-weir-ss, fig.width = 6, fig.height = 4}
weir_sample_size(j_ugr)
```

### Carcass Sampling {.tabset .tabset-pills}

```{r carc-comp-fit-funcs}

# for multinomial sample size
carc_sample_size = function(j) {
  par(mar = c(3,3,1.5,0.5), tcl = -0.15, mgp = c(2,0.35,0))
  mp = barplot(jags_data$carc_nx_obs[observable,j], xaxt = "n", col = alpha("skyblue2", 0.5), border = "blue",
               ylim = c(0, max(jags_data$carc_nx_obs[observable,j], na.rm = TRUE)),
               xlab = "Return Year", ylab = "Carcasses Sampled for Composition")
  usr = par("usr")
  at_x = seq(1, length(observable), 4)
  axis(side = 1, at = mp[at_x], labels = substr(names(jags_data$carc_nx_obs[observable,j]), 3, 4)[at_x])
  segments(usr[1], usr[3], usr[2], usr[3], xpd = TRUE)
}

# for completely disaggregated fits
carc_comp_fit_plot = function(j) {
  
  par(mfrow = c(2,3), oma = c(1.5,1.5,0,0))#, mar = c(1.5,1.5,1.5,0.5))
  plot_tseries(post_summ(post, sub_index("^q_Sa_adj[.+,1,pop]$", pop = j)), get_obs_ests_multinomial(jags_data$carc_x_obs[observable,,j], 1), main = TeX("$Age\\,3\\,(NOR)$"))
  plot_tseries(post_summ(post, sub_index("^q_Sa_adj[.+,2,pop]$", pop = j)), get_obs_ests_multinomial(jags_data$carc_x_obs[observable,,j], 2), main = TeX("$Age\\,4\\,(NOR)$"))
  plot_tseries(post_summ(post, sub_index("^q_Sa_adj[.+,3,pop]$", pop = j)), get_obs_ests_multinomial(jags_data$carc_x_obs[observable,,j], 3), main = TeX("$Age\\,5\\,(NOR)$"))
  plot_tseries(post_summ(post, sub_index("^q_Sa_adj[.+,4,pop]$", pop = j)), get_obs_ests_multinomial(jags_data$carc_x_obs[observable,,j], 4), main = TeX("$Age\\,3\\,(NOR)$"))
  plot_tseries(post_summ(post, sub_index("^q_Sa_adj[.+,5,pop]$", pop = j)), get_obs_ests_multinomial(jags_data$carc_x_obs[observable,,j], 5), main = TeX("$Age\\,4\\,(NOR)$"))
  plot_tseries(post_summ(post, sub_index("^q_Sa_adj[.+,6,pop]$", pop = j)), get_obs_ests_multinomial(jags_data$carc_x_obs[observable,,j], 6), main = TeX("$Age\\,5\\,(NOR)$"))
  mtext(side = 1, outer = T, line = 0.25, "Return Year")
  mtext(side = 2, outer = T, line = 0.25, "Proportion of Carcasses")
}

# for fits to each age, aggregated across origins
carc_comp_fit_plot_age = function(j) {
  par(mfcol = c(1,3), oma = c(1.5,1.5,0,0))
  plot_tseries(post_summ(post, sub_index("^q_Sa_adj_age[.+,1,pop]$", pop = j)), get_obs_ests_multinomial(x_carc_new_obs$x_carc_age_obs[observable,,j], 1), main = TeX("$Age\\,3$"))
  plot_tseries(post_summ(post, sub_index("^q_Sa_adj_age[.+,2,pop]$", pop = j)), get_obs_ests_multinomial(x_carc_new_obs$x_carc_age_obs[observable,,j], 2), main = TeX("$Age\\,4$"))
  plot_tseries(post_summ(post, sub_index("^q_Sa_adj_age[.+,3,pop]$", pop = j)), get_obs_ests_multinomial(x_carc_new_obs$x_carc_age_obs[observable,,j], 3), main = TeX("$Age\\,5$"))
  mtext(side = 1, outer = T, line = 0.25, "Return Year")
  mtext(side = 2, outer = T, line = 0.25, "Proportion of Return")
}

# for fits to each origin, aggregated across ages
carc_comp_fit_plot_origin = function(j) {
  par(mfcol = c(1,2), oma = c(1.5,1.5,0,0))
  plot_tseries(post_summ(post, sub_index("^q_Sa_adj_origin[.+,1,pop]$", pop = j)), get_obs_ests_multinomial(x_carc_new_obs$x_carc_origin_obs[observable,,j], 1), main = TeX("$NOR$"))
  plot_tseries(post_summ(post, sub_index("^q_Sa_adj_origin[.+,2,pop]$", pop = j)), get_obs_ests_multinomial(x_carc_new_obs$x_carc_origin_obs[observable,,j], 2), main = TeX("$HOR$"))
  mtext(side = 1, outer = T, line = 0.25, "Return Year")
  mtext(side = 2, outer = T, line = 0.25, "Proportion of Return")
}

```

#### By Age/Origin {.tabset .tabset-pills}

This is the resolution the model fits to: each year slice is treated as a 12-element multinomial vector.

##### CAT

```{r cat-carc-comp-fit, fig.width = 8, fig.height = 5}
carc_comp_fit_plot(j_cat)
```

##### LOS

```{r los-carc-comp-fit, fig.width = 8, fig.height = 5}
carc_comp_fit_plot(j_los)
```

##### MIN

```{r min-carc-comp-fit, fig.width = 8, fig.height = 5}
carc_comp_fit_plot(j_min)
```

##### UGR

```{r ugr-carc-comp-fit, fig.width = 8, fig.height = 5}
carc_comp_fit_plot(j_ugr)
```

#### By Age {.tabset .tabset-pills}

These figures show the agreement of the model with the carcass composition data by age, aggregated across origins.

##### CAT

```{r cat-carc-comp-fit-age, fig.width = 8, fig.height = 3.5}
carc_comp_fit_plot_age(j_cat)
```

##### LOS

```{r los-carc-comp-fit-age, fig.width = 8, fig.height = 3.5}
carc_comp_fit_plot_age(j_los)
```

##### MIN

```{r min-carc-comp-fit-age, fig.width = 8, fig.height = 3.5}
carc_comp_fit_plot_age(j_min)
```

##### UGR

```{r ugr-carc-comp-fit-age, fig.width = 8, fig.height = 3.5}
carc_comp_fit_plot_age(j_ugr)
```

#### By Origin {.tabset .tabset-pills}

These figures show the agreement of the model with the carcass composition data by origin, aggregated across ages.

##### CAT

```{r cat-carc-comp-fit-origin, fig.width = 8, fig.height = 4}
carc_comp_fit_plot_origin(j_cat)
```

##### LOS

```{r los-carc-comp-fit-origin, fig.width = 8, fig.height = 4}
carc_comp_fit_plot_origin(j_los)
```

##### MIN

```{r min-carc-comp-fit-origin, fig.width = 8, fig.height = 4}
carc_comp_fit_plot_origin(j_min)
```

##### UGR

```{r ugr-carc-comp-fit-origin, fig.width = 8, fig.height = 4}
carc_comp_fit_plot_origin(j_ugr)
```

#### Total Sample Size {.tabset .tabset-pills}

These figures show the number of samples gathered for age/origin composition information during carcass surveys. The model will fit more closely to years with more samples.

##### CAT

```{r cat-carc-ss, fig.width = 6, fig.height = 4}
carc_sample_size(j_cat)
```

##### LOS

```{r los-carc-ss, fig.width = 6, fig.height = 4}
carc_sample_size(j_los)
```

##### MIN

```{r min-carc-ss, fig.width = 6, fig.height = 4}
carc_sample_size(j_min)
```

##### UGR

```{r ugr-carc-ss, fig.width = 6, fig.height = 4}
carc_sample_size(j_ugr)
```

## Spawn Status Data

```{r spawn-status-fits, fig.width = 8, fig.height = 5}
par(oma = c(2,2,0,0))
layout(matrix(1:(jags_data$nj * 2), 2, jags_data$nj), heights = c(1, 0.65))

plot_f = function(j) {
  par(yaxs = "r")
  plot_tseries(post_summ(post, sub_index("^phi_Sb_Sa[.+,pop]", pop = j)),
               get_obs_ests_multinomial(cbind(jags_data$carcs_spawned[,j], jags_data$carcs_sampled[,j] - jags_data$carcs_spawned[,j])[observable,], 1),
               main = pops[j], ylim = c(0,1))
  par(mar = c(1.5,1.5,2,0.5), yaxs = "i")
  
  if (j == 1) mtext(side = 2, "Survival Probability", line = 2)
  mp = barplot(jags_data$carcs_sampled[observable,j], xaxt = "n", ylim = c(0, max(jags_data$carcs_sampled, na.rm = T)) + c(0, 5))
  at_x = seq(1, length(observable), 4)
  axis(side = 1, at = mp[at_x], labels = substr(names(jags_data$carcs_sampled[observable,j]), 3, 4)[at_x])
  box()
  
  if (j == 1) mtext(side = 2, "Carcasses Sampled", line = 2)
}

junk = sapply(1:jags_data$nj, plot_f)
```

# Spawner-to-Parr Relationship {.tabset .tabset-pills}

## Beverton-Holt

All red components are posterior summaries (medians and 95% credible intervals). The black curve is from an `nls()` fit on reconstructed parr and roughly approximated total egg production -- the grey region is the confidence interval around this fit.

```{r eggs-to-parr, fig.width = 6, fig.height = 5}
plot_f = function(j) {
  # extract posterior samples of the BH productivity and capacity parameters
  bh_params = post_subset(post, sub_index(c("alpha[pop]", "^beta[pop]$"), pop = j), matrix = TRUE)
  
  # extract posterior summaries of total spawners by brood year
  Sa_tot = post_summ(post, sub_index("^Sa_tot[.+,pop]", pop = j))
  
  # extract posterior summaries of total egg production by brood year
  f_tot = post_summ(post, sub_index("^f_tot[.+,pop]", pop = j))
  
  # extract posterior summaries of total parr recruits by brood year
  Pb = post_summ(post, sub_index("^Pb[.+,pop]", pop = j))
  
  # predict parr recruits along a sequence of spawner abundances
  Sa_pred = seq(0, max(Sa_tot[5,]), length = 30)
  f_pred = seq(0, max(f_tot[5,]), length = 30)
  
  Pb_pred = t(sapply(1:post_dim(post, "saved"), function(i) BH(f_pred, bh_params[i,1], bh_params[i,2])))
  colnames(Pb_pred) = paste0("Pb_pred[", 1:length(Sa_pred), "]")
  Pb_pred = post_convert(cbind(postpack:::id_mat(post), Pb_pred))
  Pb_pred = post_summ(Pb_pred, "Pb_pred")
  
  # fit ordinary least squares version
  ols_fit = fit_fecund_BH(jags_data, pop = j)$BH_fit
  
  # draw 1000 random parameters
  ols_params = exp(rmvnorm(1000, coef(ols_fit), vcov(ols_fit)))
  
  # calculate predicted curve at each pair/summarize
  ols_R_pred = t(sapply(1:1000, function(i) BH(f_pred, ols_params[i,1], ols_params[i,2])))
  ols_R_pred = apply(ols_R_pred, 2, function(x) quantile(x, c(0.5, 0.025, 0.975)))
  
  # graphical parameters
  par(mar = c(1.5,1.5,1.5,0.5), tcl = -0.15, mgp = c(2,0.35,0))
  
  # empty plot
  plot(1, 1, type = "n", xlim = range(0, f_tot[5,]), ylim = range(0, Pb[5,], Pb_pred[5,]),
       xlab = "", ylab = "", xaxt = "n", yaxt = "n", main = pops[j])
  
  x_ticks = axisTicks(par("usr")[1:2], log = FALSE)
  y_ticks = axisTicks(par("usr")[3:4], log = FALSE)
  axis(side = 1, at = x_ticks, labels = x_ticks/1e6)
  axis(side = 2, at = y_ticks, labels = y_ticks/1e3)
  
  # draw fitted relationship: Bayesian
  polygon(c(f_pred, rev(f_pred)), c(Pb_pred[4,], rev(Pb_pred[5,])), col = alpha("salmon", 0.5), border = NA)
  lines(Pb_pred[4,] ~ f_pred, col = "red", lty = 2)
  lines(Pb_pred[5,] ~ f_pred, col = "red", lty = 2)
  
  # draw fitted relationship: OLS
  polygon(c(f_pred, rev(f_pred)), c(ols_R_pred[2,], rev(ols_R_pred[3,])), col = alpha("grey", 0.5), border = NA)
  lines(ols_R_pred[1,] ~ f_pred, lwd = 2)
  lines(ols_R_pred[2,] ~ f_pred, lty = 2)
  lines(ols_R_pred[3,] ~ f_pred, lty = 2)
  lines(Pb_pred[3,] ~ f_pred, col = "red", lwd = 2)
  
  # draw state pairs + uncertainty
  segments(f_tot[4,], Pb[3,], f_tot[5,], Pb[3,], col = alpha("red", 0.5))
  segments(f_tot[3,], Pb[4,], f_tot[3,], Pb[5,], col = alpha("red", 0.5))
  points(Pb[3,] ~ f_tot[3,], pch = 21, col = "red", bg = alpha("salmon", 0.5), cex = 1.2)
}

par(mfrow = c(2,2), oma = c(1.5,1.5,0,0))
junk = sapply(1:jags_data$nj, plot_f)
mtext(side = 1, outer = T, line = 0.25, "Total Egg Production (Millions)")
mtext(side = 2, outer = T, line = 0.25, "Parr Recruits (Thousands)")
```

## Total Eggs vs. Total Spawners

This figure illustrates that total spawners is a reasonable index of total egg production, according to the assumptions of our model. The three lines illustrate the relationship if each spawner (regardless of age or sex) had a fixed number of eggs.

```{r eggs-vs-spawners, fig.width = 6, fig.height = 5}
plot_f = function(j) {
  # extract posterior summaries of total spawners by brood year
  Sa_tot = post_summ(post, sub_index("^Sa_tot[.+,pop]", pop = j))
  
  # extract posterior summaries of total egg production by brood year
  f_tot = post_summ(post, sub_index("^f_tot[.+,pop]", pop = j))

  # graphical parameters
  par(mar = c(1.5,1.5,1.5,0.5), tcl = -0.15, mgp = c(2,0.35,0))
  
  # empty plot
  plot(f_tot["mean",] ~ Sa_tot["mean",],
       ylim = c(0, max(f_tot["97.5%",])),
       xlim = c(0, max(Sa_tot["97.5%",])), type = "n",
       ylab = "", xlab = "", las = 1, yaxt = "n")
  
  # yaxis ticks
  y_ticks = axisTicks(par("usr")[3:4], log = F)
  axis(side = 2, at = y_ticks, labels = y_ticks/1e6, las = 2)
  
  segments(Sa_tot["2.5%",], f_tot["mean",], Sa_tot["97.5%",], f_tot["mean",], col = alpha("red", 0.5))
  segments(Sa_tot["mean",], f_tot["2.5%",], Sa_tot["mean",], f_tot["97.5%",], col = alpha("red", 0.5))
  points(f_tot["mean",] ~ Sa_tot["mean",], pch = 21, col = "red", bg = alpha("salmon", 0.5), cex = 1.2)
  abline(c(0, 1000), lty = 1)
  abline(c(0, 1800), lty = 2)
  abline(c(0, 3600), lty = 3)

  if (j == 1) {
    legend("bottomright", title = "If Each Spawner Had:",
           legend = c("1000 Eggs", "1800 Eggs", "3600 Eggs"),
           lty = c(1,2,3), bty = "n", cex = 0.75)
  }
}

par(mfrow = c(2,2), oma = c(1.5,1.5,0,0))
junk = sapply(1:jags_data$nj, plot_f)
mtext(side = 1, outer = T, line = 0.25, "Total Spawners")
mtext(side = 2, outer = T, line = 0.25, "Total Egg Production (Millions)")
```

## Parr per Egg

This figure shows the density dependence built in to the Beverton-Holt recruitment function: with increasing egg density, survival per egg decreases. The horizontal line/region shows the theoretical maximum ($\alpha_j$) in the absence of density dependence.

```{r parr-per-egg-v-eggs, fig.width = 6, fig.height = 5}
plot_f = function(j) {
  # extract posterior summaries of total egg production by brood year
  f_tot = post_summ(post, sub_index("^f_tot[.+,pop]", pop = j))
  
  # conversion rates
  Pb_per_f_tot = post_summ(post, sub_index("^Pb_per_f_tot[.+,pop]", pop = j))
  
  # max survival
  alpha = post_summ(post, sub_index("^alpha[pop]", pop = j))
  
  # graphical parameters
  par(mar = c(1.5,1.5,1.5,0.5), tcl = -0.15, mgp = c(2,0.35,0))
  
  # empty plot
  plot(Pb_per_f_tot["mean",] ~ f_tot["mean",],
       # ylim = c(0, max(Pb_per_f_tot["97.5%",], alpha["97.5%",])),
       ylim = c(0, 1),
       xlim = c(0, max(f_tot["97.5%",])), type = "n",
       ylab = "", xlab = "", las = 1, xaxt = "n", main = pops[j])
  
  # x-axis
  x_ticks = axisTicks(par("usr")[1:2], log = F)
  axis(side = 1, at = x_ticks, labels = x_ticks/1e6)
  
  segments(f_tot["2.5%",], Pb_per_f_tot["mean",], f_tot["97.5%",], Pb_per_f_tot["mean",], col = alpha("red", 0.5))
  segments(f_tot["mean",], Pb_per_f_tot["2.5%",], f_tot["mean",], Pb_per_f_tot["97.5%",], col = alpha("red", 0.5))
  points(Pb_per_f_tot["mean",] ~ f_tot["mean",], pch = 21, col = "red", bg = alpha("salmon", 0.5), cex = 1.2)
  
  rect(par("usr")[1], alpha["2.5%",], par("usr")[2], alpha["97.5%",], border = alpha("red", 0.5), col = alpha("salmon", 0.5))
  abline(h = alpha["mean",], lwd = 2, col = "red")
  box()
}
  
par(mfrow = c(2,2), oma = c(1.5,1.5,0,0))
junk = sapply(1:jags_data$nj, plot_f)
mtext(side = 1, outer = T, line = 0.25, "Total Egg Production (Millions)")
mtext(side = 2, outer = T, line = 0.25, "Parr per Egg")
```

## Parr per Spawner

This figure is identical to above, but shows parr production per spawner instead of per egg.

```{r parr-per-spawner-v-spawners, fig.width = 6, fig.height = 5}
plot_f = function(j) {
  # extract posterior summaries of total spawners by brood year
  Sa_tot = post_summ(post, sub_index("^Sa_tot[.+,pop]", pop = j))
  
  # conversion rates
  Pb_per_Sa_tot = post_summ(post, sub_index("^Pb_per_Sa_tot[.+,pop]", pop = j))
  
  # graphical parameters
  par(mar = c(1.5,1.5,1.5,0.5), tcl = -0.15, mgp = c(2,0.35,0))
  
  # empty plot
  plot(Pb_per_Sa_tot["mean",] ~ Sa_tot["mean",],
       ylim = c(0, max(Pb_per_Sa_tot["97.5%",])),
       xlim = c(0, max(Sa_tot["97.5%",])), type = "n",
       ylab = "", xlab = "", las = 1)
  
  segments(Sa_tot["2.5%",], Pb_per_Sa_tot["mean",], Sa_tot["97.5%",], Pb_per_Sa_tot["mean",], col = alpha("red", 0.5))
  segments(Sa_tot["mean",], Pb_per_Sa_tot["2.5%",], Sa_tot["mean",], Pb_per_Sa_tot["97.5%",], col = alpha("red", 0.5))
  points(Pb_per_Sa_tot["mean",] ~ Sa_tot["mean",], pch = 21, col = "red", bg = alpha("salmon", 0.5), cex = 1.2)
}

par(mfrow = c(2,2), oma = c(1.5,1.5,0,0))
junk = sapply(1:jags_data$nj, plot_f)
mtext(side = 1, outer = T, line = 0.25, "Total Spawners")
mtext(side = 2, outer = T, line = 0.25, "Parr per Spawner")
```

# Overwinter Survival Relationships

```{r overwinter-survival-plots, fig.width = 8, fig.height = 5}
plot_fn = function(j) {
  # extract parr, scale it to PEU, and create new post object
  Pa = post_subset(post, sub_index("^Pa[.+,.,pop]", pop = j), matrix = TRUE)
  Pa_scaled = Pa/jags_data$peu[j]
  colnames(Pa_scaled) = gsub("Pa", "Pa_scaled", x = colnames(Pa_scaled))
  post_pa = post_convert(cbind(postpack:::id_mat(post), Pa_scaled))
  
  # summarize posterior of scaled parr
  Pa_scaled_mean = array_format(post_summ(post_pa, sub_index("Pa_scaled[.+,.+,pop]", pop = j))["mean",])
  Pa_scaled_lwr = array_format(post_summ(post_pa, sub_index("Pa_scaled[.+,.+,pop]", pop = j))["2.5%",])
  Pa_scaled_upr = array_format(post_summ(post_pa, sub_index("Pa_scaled[.+,.+,pop]", pop = j))["97.5%",])
  
  # create vectors to predict survival at: for credible regions and mean curve
  Pa_scaled_seq = matrix(NA, 30, 2)
  Pa_scaled_seq[,i_fall] = seq(min(Pa_scaled_lwr[,i_fall,j], na.rm = TRUE), max(Pa_scaled_upr[,i_fall,j], na.rm = T), length = 30)
  Pa_scaled_seq[,i_spring] = seq(min(Pa_scaled_lwr[,i_spring,j], na.rm = TRUE), max(Pa_scaled_upr[,i_spring,j], na.rm = T), length = 30)
  
  # extract posteriors of coefficients
  gamma0 = post_subset(post, sub_index("gamma0[.,pop]", pop = j), matrix = TRUE)
  gamma1 = post_subset(post, sub_index("gamma1[.,pop]", pop = j), matrix = TRUE)
  
  # extract/format posterior summaries of realized survivals
  phi_Pa_Mb_mean = array_format(post_summ(post, sub_index("^phi_Pa_Mb[.+,.+,pop]", pop = j))["mean",])
  phi_Pa_Mb_lwr = array_format(post_summ(post,  sub_index("^phi_Pa_Mb[.+,.+,pop]", pop = j))["2.5%",])
  phi_Pa_Mb_upr = array_format(post_summ(post,  sub_index("^phi_Pa_Mb[.+,.+,pop]", pop = j))["97.5%",])
  
  # function to create predicted survival curves for one posterior sample
  pred_fn = function(i) {
    pred_phi_Pa_Mb1 = plogis(gamma0[i,1] + gamma1[i,1] * Pa_scaled_seq[,1])
    pred_phi_Pa_Mb2 = plogis(gamma0[i,2] + gamma1[i,2] * Pa_scaled_seq[,2])
    
    names(pred_phi_Pa_Mb1) = paste0("pred_phi_Pa_Mb[", 1:30, ",1]")
    names(pred_phi_Pa_Mb2) = paste0("pred_phi_Pa_Mb[", 1:30, ",2]")
    
    c(pred_phi_Pa_Mb1, pred_phi_Pa_Mb2)
  }
  
  # calculate predicted survivals and add to posterior samples
  pred_phi_Pa_Mb = t(sapply(1:post_dim(post, "saved"), pred_fn))
  post_pa = post_bind(post_pa, pred_phi_Pa_Mb)
  
  # summarize predicted survivals
  pred_phi_Pa_Mb_mean = array_format(post_summ(post_pa, "pred_phi_Pa_Mb")["mean",])
  pred_phi_Pa_Mb_lwr = array_format(post_summ(post_pa, "pred_phi_Pa_Mb")["2.5%",])
  pred_phi_Pa_Mb_upr = array_format(post_summ(post_pa, "pred_phi_Pa_Mb")["97.5%",])

  # function to draw plot for one LH-type
  plot_fn2 = function(i) {
    # blank plot of correct dimensions
    plot(1,1, type = "n", 
         ylim = range(pred_phi_Pa_Mb_lwr[,i], pred_phi_Pa_Mb_upr[,i], phi_Pa_Mb_lwr[,i,j], phi_Pa_Mb_upr[,i,j], na.rm = T),
         xlim = range(0, Pa_scaled_seq), 
         main = ifelse(i == 1, pops[j], "")
    )
    
    # expected relationship
    polygon(c(Pa_scaled_seq[,i], rev(Pa_scaled_seq[,i])), c(pred_phi_Pa_Mb_lwr[,i], rev(pred_phi_Pa_Mb_upr[,i])), border = NA, col = alpha("salmon", 0.5))
    lines(pred_phi_Pa_Mb_lwr[,i] ~ Pa_scaled_seq[,i], col = "red", lty = 2)
    lines(pred_phi_Pa_Mb_upr[,i] ~ Pa_scaled_seq[,i], col = "red", lty = 2)
    lines(pred_phi_Pa_Mb_mean[,i] ~ Pa_scaled_seq[,i], col = "red", lwd = 2)
    
    # realized survivals
    segments(Pa_scaled_lwr[,i,j], phi_Pa_Mb_mean[,i,j], Pa_scaled_upr[,i,j], phi_Pa_Mb_mean[,i,j], col = alpha("red", 0.5))
    segments(Pa_scaled_mean[,i,j], phi_Pa_Mb_lwr[,i,j], Pa_scaled_mean[,i,j], phi_Pa_Mb_upr[,i,j], col = alpha("red", 0.5))
    points(phi_Pa_Mb_mean[,i,j] ~ Pa_scaled_mean[,i,j], pch = 21, col = "red", bg = alpha("salmon", 0.5), cex = 1.2)
  }
  
  # create the plot
  par(mgp = c(2,0.35, 0), tcl = -0.15, mar = c(1,1,2,1))
  plot_fn2(1); if (j == 1) mtext(side = 2, line = 1.5, "Fall Migrants")
  plot_fn2(2); if (j == 1) mtext(side = 2, line = 1.5, "Spring Migrants")
  
}

par(mfcol = c(jags_data$ni,jags_data$nj), oma = c(2.5,3.5,0,0))
junk = sapply(1:jags_data$nj, plot_fn)
mtext(side = 1, line = 1.5, outer = T, "LH-Specific Parr/PEU", cex = 1.2)
mtext(side = 2, line = 2, outer = T, "Overwinter Survival", cex = 1.2)
```

# Equivilency Rates {.tabset .tabset-pills}

## Smolt-to-Adult Rates {.tabset .tabset-pills}

### LGR to Tributary

This is survival from $Ma$ (smolts at the top of LGD) to $Ra$ (adults returning to tributary, vulnerable to being counted at weir).

The adult part is calculated across return years, by summing the number of adults of each age that return in the appropriate years. For example, the SAR for brood year 1991 uses smolt that were spawned in 1991, out-migrated in spring 1993, divided by the sum of age 3 adults in 1994, age 4 adults in 1995, and age 5 adults in 1996. The calculation is done for hatchery and natural origin fish separately. Only SARs through brood year 2014 are calculated, since this is the last year of complete adult returns.

```{r adults-per-smolt, fig.width = 6, fig.height = 5}
sar_yrs = all_yrs[(jags_data$kmax+1):(jags_data$ny - jags_data$kmax)]

plot_fn = function(j) {
  # which years had zero hatchery smolt released
  zero_hor_smolt = post_summ(post, sub_index("Mb[year,LH_type,origin,pop]", year = c(6:29), LH_type = i_spring, origin = o_hor, pop = j))["mean",] == 0

  # summarize rates
  Ra_per_Ma_nor = post_summ(post, sub_index("Ra_per_Ma[.+,origin,pop]", origin = o_nor, pop = j)) * 100
  Ra_per_Ma_hor = post_summ(post, sub_index("Ra_per_Ma[.+,origin,pop]", origin = o_hor, pop = j)) * 100

  # make hatchery values NA in year with no smolt
  Ra_per_Ma_hor[,zero_hor_smolt] = NA

  # plot natural origin time series
  plot_tseries(est = Ra_per_Ma_nor, yrs = sar_yrs, main = pops[j], ylim = c(0, 10))
  
  # add hatchery origin time series
  polygon(x = c(sar_yrs, rev(sar_yrs)), y = c(Ra_per_Ma_hor["2.5%",], rev(Ra_per_Ma_hor["97.5%",])), col = alpha("skyblue2", 0.5), border = NA)
  lines(Ra_per_Ma_hor["2.5%",] ~ sar_yrs, col = "blue", lty = 2)
  lines(Ra_per_Ma_hor["97.5%",] ~ sar_yrs, col = "blue", lty = 2)
  lines(Ra_per_Ma_hor["mean",] ~ sar_yrs, col = "blue", lwd = 2)

  if (j == 1) {
    legend("topright", legend = c("NOR", "HOR"), title = "Origin",
         pch = 22, col = c("red", "blue"), pt.cex = 2, pt.bg = alpha(c("salmon", "skyblue2"), 0.5), bty = "n")
  }
}
par(mfrow = c(2,2), oma = c(1.5,1.5,0,0))
junk = sapply(1:jags_data$nj, plot_fn)
mtext(side = 1, outer = T, line = 0.25, "Brood Year")
mtext(side = 2, outer = T, line = 0.25, "Adults per 100 Smolt")
```

### BON to BON

```{r bon-to-bon, fig.width = 6, fig.height = 5}
sar_yrs = all_yrs[(jags_data$kmax+1):(jags_data$ny - jags_data$kmax)]

plot_fn = function(j) {
  # which years had zero hatchery smolt released
  zero_hor_smolt = post_summ(post, sub_index("Mb[year,LH_type,origin,pop]", year = c(6:29), LH_type = i_spring, origin = o_hor, pop = j))["mean",] == 0
  
  # summarize rates
  phi_nor = post_summ(post, sub_index("phi_O0_Rb_BON[.+,origin,pop]", origin = o_nor, pop = j))
  phi_hor = post_summ(post, sub_index("phi_O0_Rb_BON[.+,origin,pop]", origin = o_hor, pop = j))
  
  # get a max value for ylim
  ymax = max(post_summ(post, sub_index("phi_O0_Rb_BON[.+,origin,pop]", origin = o_nor, pop = "."))["97.5%",])

  # make hatchery values NA in year with no smolt
  phi_hor[,zero_hor_smolt] = NA

  # plot natural origin time series
  plot_tseries(est = phi_nor, yrs = sar_yrs, main = pops[j], ylim = c(0, ymax))
  
  # add hatchery origin time series
  polygon(x = c(sar_yrs, rev(sar_yrs)), y = c(phi_hor["2.5%",], rev(phi_hor["97.5%",])), col = alpha("skyblue2", 0.5), border = NA)
  lines(phi_hor["2.5%",] ~ sar_yrs, col = "blue", lty = 2)
  lines(phi_hor["97.5%",] ~ sar_yrs, col = "blue", lty = 2)
  lines(phi_hor["mean",] ~ sar_yrs, col = "blue", lwd = 2)

  if (j == 1) {
    legend("topright", legend = c("NOR", "HOR"), title = "Origin",
         pch = 22, col = c("red", "blue"), pt.cex = 2, pt.bg = alpha(c("salmon", "skyblue2"), 0.5), bty = "n")
  }
}
par(mfrow = c(2,2), oma = c(1.5,1.5,0,0))
junk = sapply(1:jags_data$nj, plot_fn)
mtext(side = 1, outer = T, line = 0.25, "Brood Year")
mtext(side = 2, outer = T, line = 0.25, "BON -> BON Survival")
```

## Parr per Spawner

"Spawner" means total spawners that survive pre-spawn mortality.

```{r parr-per-spawner, fig.width = 6, fig.height = 5}
plot_fn = function(j) {
  plot_tseries(est = post_summ(post, sub_index("Pb_per_Sa_tot[.+,pop]", pop = j)), yrs = as.numeric(rownames(jags_data$Pa_obs[,,j])[observable]), main = pops[j])
}

par(mfrow = c(2,2), oma = c(1.5,1.5,0,0))
junk = sapply(1:jags_data$nj, plot_fn)
mtext(side = 1, outer = T, line = 0.25, "Brood Year")
mtext(side = 2, outer = T, line = 0.25, "Parr per Spawner")
```

## Smolt per Spawner

"Smolt" means total NOR smolt that survive their second winter, immediately prior to migration out of basin.

```{r smolt-per-spawner, fig.width = 6, fig.height = 5}
plot_fn = function(j) {
  plot_tseries(est = post_summ(post, sub_index("Mb_per_Sa_tot[.+,pop]", pop = j)), yrs = as.numeric(rownames(jags_data$Pa_obs[,,j])[observable]), main = pops[j])
}

par(mfrow = c(2,2), oma = c(1.5,1.5,0,0))
junk = sapply(1:jags_data$nj, plot_fn)
mtext(side = 1, outer = T, line = 0.25, "Brood Year")
mtext(side = 2, outer = T, line = 0.25, "Parr per Spawner")
```

## Spawners per Spawner

This is the sum of all spawners that were produced by the spawners in a given brood year (i.e., accounts for adult recruits returning across multiple ages/years). "Brood year" refers to the year the returning production was spawned. 

```{r spawners-per-spawner, fig.width = 6, fig.height = 5}
plot_fn = function(j) {
  plot_tseries(est = post_summ(post, sub_index("Sa_tot_per_Sa_tot[.+,pop]", pop = j)), yrs = all_yrs[(jags_data$kmax+1):(jags_data$ny - jags_data$kmax)], main = pops[j])
 abline(h = 1, lty = 2)
}
par(mfrow = c(2,2), oma = c(1.5,1.5,0,0))
junk = sapply(1:jags_data$nj, plot_fn)
mtext(side = 1, outer = T, line = 0.25, "Brood Year")
mtext(side = 2, outer = T, line = 0.25, "Spawner per Spawner")
```

# Straying Dynamics {.tabset .tabset-pills}

## Number of Strays

```{r n-stray, fig.width = 6, fig.height = 5}
plot_fn = function(j) {
  plot_tseries(est = post_summ(post, sub_index("n_stray_tot[.+,pop]", pop = j)), yrs = as.numeric(rownames(jags_data$Pa_obs[,,j])[observable]), main = pops[j])
}

par(mfrow = c(2,2), oma = c(1.5,1.5,0,0))
junk = sapply(1:jags_data$nj, plot_fn)
mtext(side = 1, outer = T, line = 0.25, "Return Year")
mtext(side = 2, outer = T, line = 0.25, "Number of Strays Entering Population")
```

## Stray Composition

```{r stray-comp, fig.width = 6, fig.height = 5}
plot_fn = function(j) {
  x = post_summ(post, sub_index("stray_comp[age,origin,pop]", age = ".", origin = o_hor, pop = j))
  
  par(mar = c(5,2,1,1), tcl = -0.15, mgp = c(2, 0.35, 0))
  mp = barplot(x["mean",], ylim = c(0, 1), xaxt = "n", main = pops[j], col = alpha("salmon", 0.5), border = alpha("red", 0.5))
  segments(mp, x["2.5%",], mp, x["97.5%",], col = alpha("red", 0.5))
  axis(side = 1, at = mp, labels = paste0("Age", jags_data$kmin:jags_data$kmax), las = 2)
  segments(par("usr")[1], par("usr")[3], par("usr")[2], par("usr")[3], xpd = TRUE)
}

par(mfrow = c(2,2), oma = c(0,1.5,0,0))
junk = sapply(1:jags_data$nj, plot_fn)
mtext(side = 2, outer = T, line = 0.25, "Proportion of Strays by Age")
```

# Ocean Survival {.tabset .tabset-pills}

```{r ocean-surv-plots, fig.width = 6, fig.height = 5}
ocean_surv_plot = function(j) {
  par(mfrow = c(3,2), oma = c(1.5,1.5,0,0))
  plot_tseries(post_summ(post, sub_index("^phi_O0_O1[.+,origin,pop]", origin = o_nor, pop = j)),
               main = TeX("$O_0 \\rightarrow O_1\\,(NOR)$"), yrs = all_yrs[observable], ylim = c(0,1))
  plot_tseries(post_summ(post, sub_index("^phi_O0_O1[.+,origin,pop]", origin = o_hor, pop = j)),
               main = TeX("$O_0 \\rightarrow O_1\\,(HOR)$"), yrs = all_yrs[observable], ylim = c(0,1))
  plot_tseries(post_summ(post, sub_index("^phi_O1_O2[.+,origin,pop]", origin = o_nor, pop = j)),
               main = TeX("$O_1 \\rightarrow O_2\\,(NOR)$"), yrs = all_yrs[observable], ylim = c(0,1))
  plot_tseries(post_summ(post, sub_index("^phi_O1_O2[.+,origin,pop]", origin = o_hor, pop = j)),
               main = TeX("$O_1 \\rightarrow O_2\\,(HOR)$"), yrs = all_yrs[observable], ylim = c(0,1))
  plot_tseries(post_summ(post, sub_index("^phi_O2_O3[.+,origin,pop]", origin = o_nor, pop = j)),
               main = TeX("$O_2 \\rightarrow O_3\\,(NOR)$"), yrs = all_yrs[observable], ylim = c(0,1))
  plot_tseries(post_summ(post, sub_index("^phi_O2_O3[.+,origin,pop]", origin = o_hor, pop = j)),
               main = TeX("$O_2 \\rightarrow O_3\\,(HOR)$"), yrs = all_yrs[observable], ylim = c(0,1))
  mtext(side = 1, outer = T, line = 0.5, "Brood Year")
  mtext(side = 2, outer = T, line = 0, "Survival")
}
```

## CAT

```{r}
ocean_surv_plot(j_cat)
```

## LOS

```{r}
ocean_surv_plot(j_los)
```

## MIN

```{r}
ocean_surv_plot(j_min)
```

## UGR

```{r}
ocean_surv_plot(j_ugr)
```

# Maturity {.tabset .tabset-pills}

```{r maturity-plot-fn}
maturity_plot = function(j) {
  par(mfrow = c(2,2), oma = c(1.5,1.5,0,0))
  plot_tseries(post_summ(post, sub_index("^psi_O1_Rb[.+,origin,pop]$", origin = o_nor, pop = j)), main = "Age 3 (NOR)", yrs = all_yrs[observable], ylim = c(0,1))
  plot_tseries(post_summ(post, sub_index("^psi_O1_Rb[.+,origin,pop]$", origin = o_hor, pop = j)), main = "Age 3 (HOR)", yrs = all_yrs[observable], ylim = c(0,1))
  plot_tseries(post_summ(post, sub_index("^psi_O2_Rb[.+,origin,pop]$", origin = o_nor, pop = j)), main = "Age 4 (NOR)", yrs = all_yrs[observable], ylim = c(0,1))
  plot_tseries(post_summ(post, sub_index("^psi_O2_Rb[.+,origin,pop]$", origin = o_hor, pop = j)), main = "Age 4 (HOR)", yrs = all_yrs[observable], ylim = c(0,1))

  mtext(side = 1, outer = T, line = 0.25, "Brood Year")
  mtext(side = 2, outer = T, line = 0.25, "Pr(Mature-at-Age|Alive in Ocean)")
}
```

## CAT

```{r maturity-cat, fig.width = 6, fig.height = 5}
maturity_plot(j_cat)
```

## LOS

```{r maturity-los, fig.width = 6, fig.height = 5}
maturity_plot(j_los)
```

## MIN

```{r maturity-min, fig.width = 6, fig.height = 5}
maturity_plot(j_min)
```

## UGR

```{r maturity-ugr, fig.width = 6, fig.height = 5}
maturity_plot(j_ugr)
```

# Parameter Summaries {.tabset .tabset-dropdown}

```{r my-boxplot-function}
my_boxplot = function(params, ylab = NULL, ticklabs = pops, ylim = NULL, boxfill = alpha("salmon", 0.5), border = alpha("red", 0.5), ...) {
  # extract posterior samples and rename them
  post_sub = post_subset(post, params, matrix = TRUE)
  
  if (ncol(post_sub) >= 2) {
    colnames(post_sub) = ticklabs
  }

  # initialize a boxplot object
  bp = boxplot(post_sub, plot = FALSE)
  
  # replace the summary stats with my preferred quantiles
  par(mar = c(5,3,1,1), mgp = c(2,0.35,0), tcl = -0.15)
  bp$stats = apply(post_sub, 2, function(x) quantile(x, c(0.025, 0.25, 0.5, 0.75, 0.975)))
  bxp(bp, ylab = ylab, xlab = "", outline = FALSE, ylim = ylim, ...,
      staplelty = 0, whisklty = 1, boxfill = boxfill, boxcol = border, medcol = border, whiskcol = border)
} 
```

## Parr Recruitment

```{r recruit-bxp, fig.width = 8, fig.height = 3.5}
par(mfrow = c(1,4))
my_boxplot("^alpha[.]$", "Productivity")
my_boxplot("^beta[.]$", "Capacity")
my_boxplot("^sig_lPb[.]$", "Process SD")
my_boxplot("^rho_lPb", "Among-pop Correlation", ticklabs = vcov_labels, las = 3)
```

## Life History Apportionment

```{r LH-type-bxp, fig.width = 8, fig.height = 3.5}
par(mfrow = c(1,3))
my_boxplot("^mu_pi[1,.]$", "Mean Proportion Fall Migrants")
my_boxplot("^sig_Lpi[.]$", "Process SD")
my_boxplot("^rho_Lpi", "Among-pop Correlation", ticklabs = vcov_labels, las = 3)
```

## Overwinter Survival {.tabset .tabset-pills}

### Logistic Function Parameters

```{r overwinter-survival-bxp1, fig.width = 8, fig.height = 3.5}
par(mfrow = c(1,3))
my_boxplot(sub_index("gamma0[LH_type,pop]", LH_type = i_fall, pop = "."), "Intercept (Fall)")
my_boxplot(sub_index("gamma0[LH_type,pop]", LH_type = i_spring, pop = "."), "Intercept (Spring)")
my_boxplot(sub_index("gamma1[LH_type,pop]", LH_type = i_spring, pop = "."), "Slope")
```

### Process SD

```{r overwinter-survival-bxp2, fig.width = 8, fig.height = 3.5}
par(mfrow = c(1,2))
my_boxplot(sub_index("sig_Lphi_Pa_Mb[pop,LH_type]", LH_type = i_fall, pop = "."), "Process SD (Fall)")
my_boxplot(sub_index("sig_Lphi_Pa_Mb[pop,LH_type]", LH_type = i_spring, pop = "."), "Process SD (Spring)")
```

### Among-pop Correlation

```{r overwinter-survival-bxp3, fig.width = 8, fig.height = 3.5}
par(mfrow = c(1,2))
my_boxplot(sub_index("rho_Lphi_Pa_Mb[.,.,LH_type]", LH_type = i_fall), "Among-pop Correlation (Fall)", ticklabs = vcov_labels, las = 3)
my_boxplot(sub_index("rho_Lphi_Pa_Mb[.,.,LH_type]", LH_type = i_spring), "Among-pop Correlation (Spring)", ticklabs = vcov_labels, las = 3)
```

## Movement Survival to LGR {.tabset .tabset-pills}

### Mean

```{r trib-to-lgr-bxp1, fig.width = 8, fig.height = 3.5}
par(mfrow = c(1,2))
my_boxplot(sub_index("mu_phi_Mb_Ma[LH_type,origin,pop]", LH_type = i_spring, origin = o_nor, pop = "."), "Average Migration Survival", main = "NOR", ylim = c(0,1))
my_boxplot(sub_index("mu_phi_Mb_Ma[LH_type,origin,pop]", LH_type = i_spring, origin = o_hor, pop = "."), "Average Migration Survival", main = "HOR", ylim = c(0,1))
```

### Process SD

```{r trib-to-lgr-bxp2, fig.width = 8, fig.height = 3.5}
par(mfrow = c(1,2))
my_boxplot(sub_index("sig_Lphi_Mb_Ma[pop,origin]", origin = o_nor, pop = "."), "Process SD", main = "NOR")
my_boxplot(sub_index("sig_Lphi_Mb_Ma[pop,origin]", origin = o_hor, pop = "."), "Process SD", main = "HOR")
```

### Among-pop Correlation

```{r trib-to-lgr-bxp3, fig.width = 8, fig.height = 3.5}
par(mfrow = c(1,2))
my_boxplot(sub_index("rho_Lphi_Mb_Ma[.,.,origin]", origin = o_nor), "Among-pop Correlation (NOR)", ticklabs = vcov_labels, las = 3)
my_boxplot(sub_index("rho_Lphi_Mb_Ma[.,.,origin]", origin = o_hor), "Among-pop Correlation (HOR)", ticklabs = vcov_labels, las = 3)
```

## Movement Survival to Ocean

```{r lgr-to-ocean-bxp}
par(mfrow = c(1,3))
my_boxplot(sub_index("mu_phi_Ma_O0[origin]", origin = "."), "Average Migration Survival", ylim = c(0,1), ticklab = c("NOR", "HOR"))
my_boxplot(sub_index("sig_Lphi_Ma_O0[origin]", origin = "."), "Process SD", ylim = c(0,1), ticklab = c("NOR", "HOR"))
my_boxplot(sub_index("rho_Lphi_Ma_O0[2,1]"), "Among-origin Correlation", ylim = c(-1,1), ticklab = c(""))
```

## Probability of Maturing at Age-3 {.tabset .tabset-pills}

### Means

```{r age3-mean-bxp, fig.width = 8, fig.height = 3.5}
par(mfrow = c(1,2))
my_boxplot(sub_index("mu_psi_O1_Rb[origin,pop]", origin = o_nor, pop = "."), "", main = "NOR", ylim = c(0,1))
my_boxplot(sub_index("mu_psi_O1_Rb[origin,pop]", origin = o_hor, pop = "."), "", main = "HOR", ylim = c(0,1))
```

### Process SD

```{r age3-sd-bxp, fig.width = 8, fig.height = 3.5}
par(mfrow = c(1,2))
my_boxplot(sub_index("sig_Lpsi_O1_Rb[pop,origin]", origin = o_nor, pop = "."), "", main = "NOR")
my_boxplot(sub_index("sig_Lpsi_O1_Rb[pop,origin]", origin = o_hor, pop = "."), "", main = "HOR")
```

### Among-pop Correlation

```{r age3-rho-bxp, fig.width = 8, fig.height = 3.5}
par(mfrow = c(1,2))
my_boxplot(sub_index("rho_Lpsi_O1_Rb[.,.,origin]", origin = o_nor), "Among-pop Correlation (NOR)", ticklabs = vcov_labels, las = 3)
my_boxplot(sub_index("rho_Lpsi_O1_Rb[.,.,origin]", origin = o_hor), "Among-pop Correlation (HOR)", ticklabs = vcov_labels, las = 3)
```

## Probability of Maturing at Age-4 {.tabset .tabset-pills}

### Means

```{r age4-mean-bxp, fig.width = 8, fig.height = 3.5}
par(mfrow = c(1,2))
my_boxplot(sub_index("mu_psi_O2_Rb[origin,pop]", origin = o_nor, pop = "."), "", main = "NOR", ylim = c(0,1))
my_boxplot(sub_index("mu_psi_O2_Rb[origin,pop]", origin = o_hor, pop = "."), "", main = "HOR", ylim = c(0,1))
```

### Process SD

```{r age4-sd-bxp, fig.width = 8, fig.height = 3.5}
par(mfrow = c(1,2))
my_boxplot(sub_index("sig_Lpsi_O2_Rb[pop,origin]", origin = o_nor, pop = "."), "", main = "NOR")
my_boxplot(sub_index("sig_Lpsi_O2_Rb[pop,origin]", origin = o_hor, pop = "."), "", main = "HOR")
```

### Among-pop Correlation

```{r age4-rho-bxp, fig.width = 8, fig.height = 3.5}
par(mfrow = c(1,2))
my_boxplot(sub_index("rho_Lpsi_O2_Rb[.,.,origin]", origin = o_nor), "Among-pop Correlation (NOR)", ticklabs = vcov_labels, las = 3)
my_boxplot(sub_index("rho_Lpsi_O2_Rb[.,.,origin]", origin = o_hor), "Among-pop Correlation (HOR)", ticklabs = vcov_labels, las = 3)
```

## Ocean Survival {.tabset .tabset-pills}

### Year 1 {.tabset .tabset-pills}

#### Mean

```{r yr1-ocean-bxp, fig.width = 8, fig.height = 3.5}
par(mfrow = c(1,2))
my_boxplot(sub_index("mu_phi_O0_O1[origin,pop]", origin = o_nor, pop = "."), main = "NOR", ylim = c(0,1), ylab = "Average Survival")
my_boxplot(sub_index("mu_phi_O0_O1[origin,pop]", origin = o_hor, pop = "."), main = "HOR", ylim = c(0,1), ylab = "Average Survival")
```

#### Process SD and Correlation

```{r yr1-ocean-bxp2, fig.width = 8, fig.height = 3.5}
par(mfrow = c(1,3))
my_boxplot(sub_index("sig_Lphi_O0_O1[pop]", pop = "."), ylab = "Process SD")
my_boxplot(sub_index("kappa_phi_O0_O1[pop]", pop = "."), ylab = "Autocorrelation")
my_boxplot("rho_Lphi_O0_O1[", ticklabs = vcov_labels, ylab = "Among-pop Correlation", ylim = c(-1,1), las = 2)
```

### Year 2 {.tabset .tabset-pills}

```{r yr2-ocean-bxp, fig.width = 8, fig.height = 3.5}
par(mfrow = c(1,2))
my_boxplot(sub_index("mu_phi_O1_O2[origin,pop]", origin = o_nor, pop = "."), main = "NOR", ylim = c(0,1), ylab = "Average Survival")
my_boxplot(sub_index("mu_phi_O1_O2[origin,pop]", origin = o_hor, pop = "."), main = "HOR", ylim = c(0,1), ylab = "Average Survival")
```

### Year 3 {.tabset .tabset-pills}

**NOTE:** The Year 3 parameters are the same as the Year 2 parameters.

```{r yr3-ocean-bxp, fig.width = 8, fig.height = 3.5}
par(mfrow = c(1,2))
my_boxplot(sub_index("mu_phi_O2_O3[origin,pop]", origin = o_nor, pop = "."), main = "NOR", ylim = c(0,1), ylab = "Average Survival")
my_boxplot(sub_index("mu_phi_O2_O3[origin,pop]", origin = o_hor, pop = "."), main = "HOR", ylim = c(0,1), ylab = "Average Survival")
```

### NOR:HOR Log Odds Ratio

```{r ocean-surv-scaler, fig.width = 8, fig.height = 3.5}
my_boxplot(sub_index("O_phi_scaler_nat_hat[pop]", pop = "."), ylab = "Log Odds Ratio")
```

## Movement Survival BON to LGR

```{r bon-to-lgr-bxp}
par(mfrow = c(1,3))
my_boxplot(sub_index("mu_phi_Rb_Ra[origin]", origin = "."), "Average Migration Survival", ylim = c(0,1), ticklab = c("NOR", "HOR"))
my_boxplot(sub_index("sig_Lphi_Rb_Ra[origin]", origin = "."), "Process SD", ticklab = c("NOR", "HOR"))
my_boxplot(sub_index("rho_Lphi_Rb_Ra[2,1]"), "Among-origin Correlation", ylim = c(-1,1), ticklab = c(""))
```

## Pre-spawn Survival

```{r prespawn-surv-bxp}
par(mfrow = c(1,3))
my_boxplot(sub_index("mu_phi_Sb_Sa[pop]", pop = "."), "Average Survival", ylim = c(0,1))
my_boxplot(sub_index("sig_Lphi_Sb_Sa[pop]", pop = "."), "Process SD")
my_boxplot("rho_Lphi_Sb_Sa", "Among-pop Correlation", ylim = c(-1,1), ticklab = vcov_labels)
```

# JAGS Model and Data {.tabset .tabset-pills}

## JAGS Model Code

```{r jags-model, comment = NA}
# print the JAGS model code
cat(model_info$jags_model_code, sep = "\n")
```

## JAGS Model Data

```{r jags-data, comment = NA}
# print the JAGS model data
model_info$jags_data
```
