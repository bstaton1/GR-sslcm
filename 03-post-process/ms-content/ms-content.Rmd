---
output: 
  pdf_document:
    keep_tex: true
params:
  scenario:
    label: "Scenario"
    value: "base_vlong"
    input: text
  thin_percent:
    label: "Proportion of Posterior Samples to Retain?"
    value: 1
    input: numeric
  include_sim_years:
    value: FALSE
  map_fig:
    value: TRUE
  diagram_fig:
    value: TRUE
  beta_fig:
    value: TRUE
  relationship_fig:
    value: TRUE
  no_fall_fig:
    value: TRUE
  no_fall_tab:
    value: TRUE
  surv_compare_fig:
    value: TRUE
  apportion_compare_fig:
    value: TRUE
  corr_compare_fig:
    value: TRUE
  WUL_change_fig:
    value: TRUE
  obs_vs_fit_fig:
    value: TRUE
  time_table:
    value: FALSE
header-includes:
  - \usepackage{sansmathfonts}
  - \usepackage{helvet}
  - \renewcommand{\rmdefault}{\sfdefault}
  - \usepackage[labelfont={bf,sc},labelsep=period]{caption}
  - \captionsetup{width=\textwidth}
  - \usepackage{floatrow}
  - \floatsetup[figure]{style=plaintop}
  - \floatsetup[table]{style=plaintop}
editor_options: 
  chunk_output_type: console
---

\rule{\textwidth}{1pt}

\vspace{-6pt}

::: {.Huge data-latex=""}
**Potential Manuscript Content**
:::

\vspace{-6pt}

::: {.Large data-latex=""}
**GR-sslcm**
:::

\vspace{-6pt}

::: {.normalsize data-latex=""}
**Scenario:** ``r params$scenario``  
**Kept MCMC Iterations:** `r paste0(params$thin_percent * 100, "\\%")`
:::

\vspace{-6pt}

\rule{\textwidth}{1pt}

\listoftables

\listoffigures

\pagenumbering{gobble}
\newpage
\pagenumbering{arabic}

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, fig.align = "center", fig.pos = "H")
knitr::opts_knit$set(root.dir = "C:/Users/bstaton/Desktop/Staton/1_critfc/analyses/GR-sslcm/03-post-process")

# set up a chunk hook to calculate how long chunks took to run
# modified from https://bookdown.org/yihui/rmarkdown-cookbook/time-chunk.html#time-chunk

start_times = list()  # store the time for each chunk
end_times = list()  # store the time for each chunk
knitr::knit_hooks$set(time_it = local({
  function(before, options) {
    if (before) {
      start_times[[options$label]] <<- lubridate::now()
    } else {
      end_times[[options$label]] <<- lubridate::now()
    }
  }
}))
```

```{r load-post, time_it = TRUE}
source("C:/Users/bstaton/Desktop/source_rmd_chunk.R")
rmd_file = "C:/Users/bstaton/Desktop/Staton/1_critfc/analyses/GR-sslcm/03-post-process/output-plots.Rmd"
source_rmd_chunk(rmd_file, "setup")
source_rmd_chunk(rmd_file, "dimension-ids")
knitr::opts_chunk$set(out.width = "100%", dev = "cairo_pdf")
```

```{r load-packages}
source("../00-packages.R")
```

```{r plot-settings}
solid_col = "grey30"
solid_col2 = "black"
tranp_col = alpha(solid_col, 0.25)
pt_cex = 1.3
```

```{r captions}
map_caption = "
  Placeholder for a map figure. The map should show at least: Grande Ronde basin with relevant tributaries, locations of weirs and screw traps, inset map showing region of US covered.
"

diagram_caption = "
  Schematic of the primary states and transitions among states that are captured in the state-space life cycle model for Grande Ronde spring Chinook salmon.
"

beta_caption = "
  Estimated relationship between parr capacity and weighted usable habitat length.
  Darker grey/thicker error bars represent 80% credible regions and lighter grey/thinner error bars represent 95% credible regions.
"

relationship_caption = "
  Estimated relationships showing density effects on recruitment (panels _a_ and _b_) and mean length (panel _c_), and length effects on future length (panel _d_) and survival (panels _e_ and _f_). 
  Process model relationships are shown as the posterior mean (thick line) and 95% credible region (shaded); points show process model realizations (i.e., with process noise) by brood year.
  Panels within the same row show the process model relationship for each of the four populations; _x_- and _y_-axis limits are identical for all panels within a row.
"

no_fall_fig_caption = "
  Ratios between the across-year mean (dark grey) and coefficient of variation (light grey) abundance of natural-origin smolt reaching Lower Granite Dam with (denominator) and without (numerator) the fall migrant life history strategy.
  The 'without' scenario was calculated by assuming all parr recruits experienced freshwater survival rates of spring migrants.
  Mean ratios <1 and CV ratios >1 indicate LGR smolt abundance would be lower and more variable, respectively, in the absence of the fall migrant strategy.
  Values presented are posterior means and 95% credible regions.
"

no_fall_table_caption = "
  Inter-annual mean and coefficient of variation (\\%CV) of natural-origin smolt reaching Lower Granite Dam in the presence and (hypothetical) absence of the fall migrant life history type.
  Findings indicate that smolt abundance would be lower on average and more variable across years if the fall migrant strategy did not exist.
"

surv_compare_caption = "
  Survival probability parameters estimated by the state-space model, separated by stage transition and other demographic features (migratory type, origin, population) where applicable.
  Small points show posterior means of year-specific realized values (jitter for visual effect only) and large points show the average across years.
  Information about mortality due to sources/stages not displayed here was either assumed known without error (e.g., prespawn mortality) or expressed as strong prior information with no inter-annual variability (i.e., mortality experienced in ocean-1 $\\to$ ocean-2 and ocean-2 $\\to$ ocean-3).
"

apportion_compare_caption = "
  Transition probability parameters (unrelated to survival) estimated by the state-space model, separated by life stage and origin where applicable.
  Small points show posterior means of year-specific realized values (jitter for visual effect only) and large points show the average across years.
"

corr_compare_caption = "
  Correlation terms of the covariance matrices controlling process variability.
  Posterior means of population pair-specific correlations are displayed as points, and the posterior of the average of the 6 pairs is summarized in black (thin lines are 95% CRIs, thick lines 50% CRIs, and cross marks are means).
  Survival processes are denoted by $x \\to y$, where as transition processes are denoted by $\\Pr(x)$.
  The correlation in survival processes representing the migration downstream and upstream through the mainstem (LGR $\\to$ BON and BON $\\to$ LGR, respectively) represent among-origin correlation, hence the lack of points.
"

WUL_change_fig_caption = "
  Freshwater juvenile density-dependent relationships under current (solid lines) and increased (dashed lines) weighted usable habitat.
  Panels (_a_-_d_): composite survival from egg to smolt at Lower Granite Dam (LGR) including both direct (i.e., egg density affects egg survival via Beverton-Holt dynamics) and indirect (i.e., egg density affects growth rates, size affects parr and smolt survival) density effects; panels (_e_-_h_): composite survival from parr to smolt at LGR which includes only indirect effects; panels (_i_-_l_): smolt reaching LGR.
  Calculations operate based on density of juveniles -- _x_-axis converted to approximate spawner abundance (all ages, origins, and sexes) for ease of interpretation. Grey bands show the 95% credible region for the current relationship only; lines show posterior means.
"

obs_vs_fit_fig_caption = "
  Consistency between model fitted values (posterior means) and nearly all data sources with an explicit likelihood function; only parr and smolt mean length data have been omitted here for space.
  Each data point is one year for one population, with the exceptions of panels _g_, _h_, and _i_, which display values for both natural- and hatchery-origin survival rates, and in the cases of _h_ and _i_, these rates apply equally to all populations.
  More detailed visualizations of model fit are shown in Supplement B (Section 3: model fits as time series with magnitude of observation uncertainty shown; Section 11: diagnostics based on quantile-standardized residuals; Section 12: posterior predictive checks).
"
```

```{r map-fig, fig.width = 7.2, fig.height = 5, fig.cap = msdown::prep_caption(map_caption), eval = params$map_fig}
par(mar = rep(0.25, 4), ljoin = "mitre")
plot(1,1, xlim = c(0,1), ylim = c(0,1), type = "n", axes = FALSE, ann = FALSE)
text(x = 0.5, y = 0.5, "MAP\nPLACEHOLDER", font = 2, cex = 3)
box(lwd = 4)
```

\newpage

\begin{figure}[H]
{\centering \includegraphics[width=1\linewidth,]{../../100-math-description/GR-sslcm-diagram.pdf}}
\caption{Schematic of the primary states and transitions among states that are captured in the state-space life cycle model for Grande Ronde spring Chinook salmon.}
\label{fig:diagram}
\end{figure}

\newpage

```{r obs-vs-fit-fig, fig.width = 7.2, fig.height = 7, eval = params$obs_vs_fit_fig, fig.cap = msdown::prep_caption(obs_vs_fit_fig_caption)}
# initialize an empty list
plot_dat = list()

# prep values to plot: fall trap passage
plot_dat$Pa_fall = list(
  obs = jags_data$Pa_obs[,i_fall,],
  fitted = {
    tmp = post_summ(post, sub_index("^Pa[.+,LH_type,.]", LH_type = i_fall))
    list(
      mn = array_format(tmp["mean",])[,i_fall,],
      lwr = array_format(tmp["2.5%",])[,i_fall,],
      upr = array_format(tmp["97.5%",])[,i_fall,]
    )
  }
)

# prep values to plot: spring trap passage
plot_dat$Mb_spring = list(
  obs = jags_data$Mb_obs[,i_spring,o_nor,],
  fitted = {
    tmp = post_summ(post, sub_index("^Mb[.+,LH_type,origin,.]", LH_type = i_spring, origin = o_nor))
    list(
      mn = array_format(tmp["mean",])[,i_spring,o_nor,],
      lwr = array_format(tmp["2.5%",])[,i_spring,o_nor,],
      upr = array_format(tmp["97.5%",])[,i_spring,o_nor,]
    )
  }
)

# prep values to plot: adult return to river
plot_dat$Ra_tot = list(
  obs = jags_data$Ra_obs,
  fitted = {
    tmp = post_summ(post, "^Ra_tot[")
    list(
      mn = array_format(tmp["mean",]),
      lwr = array_format(tmp["2.5%",]),
      upr = array_format(tmp["97.5%",])
    )
  }
)

# prep values to plot: summer to LGR survival
plot_dat$phi_Pb_Ma = list(
  obs = plogis(jags_data$Lphi_obs_Pb_Ma),
  fitted = {
    tmp = post_summ(post, "^phi_Pb_Ma[")
    list(
      mn = array_format(tmp["mean",]),
      lwr = array_format(tmp["2.5%",]),
      upr = array_format(tmp["97.5%",])
    )
  }
)

# prep values to plot: fall to LGR survival
plot_dat$phi_Pa_Ma_fall = list(
  obs = plogis(jags_data$Lphi_obs_Pa_Ma[,i_fall,]),
  fitted = {
    tmp = post_summ(post, sub_index("^phi_Pa_Ma[year,LH_type,pop]", year = ".+", LH_type = i_fall, pop = ".+"))
    list(
      mn = array_format(tmp["mean",])[,i_fall,],
      lwr = array_format(tmp["2.5%",])[,i_fall,],
      upr = array_format(tmp["97.5%",])[,i_fall,]
    )
  }
)

# prep values to plot: winter to LGR survival
plot_dat$phi_Pa_Ma_winter = list(
  obs = plogis(jags_data$Lphi_obs_Pa_Ma[,i_spring,]),
  fitted = {
    tmp = post_summ(post, sub_index("^phi_Pa_Ma[year,LH_type,pop]", year = ".+", LH_type = i_spring, pop = ".+"))
    list(
      mn = array_format(tmp["mean",])[,i_spring,],
      lwr = array_format(tmp["2.5%",])[,i_spring,],
      upr = array_format(tmp["97.5%",])[,i_spring,]
    )
  }
)

# prep values to plot: spring to LGR survival (NOR)
plot_dat$phi_Mb_Ma_nor = list(
  obs = plogis(jags_data$Lphi_obs_Mb_Ma[,i_spring,o_nor,]),
  fitted = {
    tmp = post_summ(post, sub_index("^phi_Mb_Ma[year,LH_type,origin,pop]", year = ".+", LH_type = i_spring, origin = o_nor, pop = ".+"))
    list(
      mn = array_format(tmp["mean",])[,i_spring,o_nor,],
      lwr = array_format(tmp["2.5%",])[,i_spring,o_nor,],
      upr = array_format(tmp["97.5%",])[,i_spring,o_nor,]
    )
  }
)

# prep values to plot: spring to LGR survival (HOR)
plot_dat$phi_Mb_Ma_hor = list(
  obs = plogis(jags_data$Lphi_obs_Mb_Ma[,i_spring,o_hor,]),
  fitted = {
    tmp = post_summ(post, sub_index("^phi_Mb_Ma[year,LH_type,origin,pop]", year = ".+", LH_type = i_spring, origin = o_hor, pop = ".+"))
    list(
      mn = array_format(tmp["mean",])[,i_spring,o_hor,],
      lwr = array_format(tmp["2.5%",])[,i_spring,o_hor,],
      upr = array_format(tmp["97.5%",])[,i_spring,o_hor,]
    )
  }
)

# prep values to plot: spring to LGR survival (NOR & HOR both)
plot_dat$phi_Mb_Ma = list(
  obs = plogis(jags_data$Lphi_obs_Mb_Ma[,i_spring,,]),
  fitted = {
    tmp = post_summ(post, sub_index("^phi_Mb_Ma[year,LH_type,.,pop]", year = ".+", LH_type = i_spring, origin = o_hor, pop = ".+"))
    list(
      mn = array_format(tmp["mean",])[,i_spring,,],
      lwr = array_format(tmp["2.5%",])[,i_spring,,],
      upr = array_format(tmp["97.5%",])[,i_spring,,]
    )
  }
)

# prep values to plot: LGR to BON (NOR & HOR both)
plot_dat$phi_Ma_O0 = list(
  obs = plogis(jags_data$Lphi_obs_Ma_O0),
  fitted = {
    tmp = post_summ(post, "^phi_Ma_O0[")
    list(
      mn = array_format(tmp["mean",]),
      lwr = array_format(tmp["2.5%",]),
      upr = array_format(tmp["97.5%",])
    )
  }
)

# prep values to plot: BON to LGR (NOR & HOR both)
plot_dat$phi_Rb_Ra = list(
  obs = jags_data$x_LGR/jags_data$x_BON,
  fitted = {
    tmp = post_summ(post, "^phi_Rb_Ra[")
    list(
      mn = array_format(tmp["mean",]),
      lwr = array_format(tmp["2.5%",]),
      upr = array_format(tmp["97.5%",])
    )
  }
)

# add aggregate age/origin compositions
source_rmd_chunk("output-plots-children/03-fit-to-data.Rmd", "calculate-aggregated-comps-model")
source_rmd_chunk("output-plots-children/03-fit-to-data.Rmd", "calculate-aggregated-comps-data")

# prep values to plot: weir compositon age-3
plot_dat$p_Ra_age3 = list(
  obs = x_Ra_new_obs$x_Ra_age_obs[,k_3,]/apply(x_Ra_new_obs$x_Ra_age_obs, 3, rowSums),
  fitted = {
    tmp = post_summ(post, sub_index("^p_Ra_age[year,1,pop]", year = ".+", pop = ".+"))
    list(
      mn = array_format(tmp["mean",])[,k_3,],
      lwr = array_format(tmp["2.5%",])[,k_3,],
      upr = array_format(tmp["97.5%",])[,k_3,]
    )
  }
)

# prep values to plot: weir compositon age-4
plot_dat$p_Ra_age4 = list(
  obs = x_Ra_new_obs$x_Ra_age_obs[,k_4,]/apply(x_Ra_new_obs$x_Ra_age_obs, 3, rowSums),
  fitted = {
    tmp = post_summ(post, sub_index("^p_Ra_age[year,2,pop]", year = ".+", pop = ".+"))
    list(
      mn = array_format(tmp["mean",])[,k_4,],
      lwr = array_format(tmp["2.5%",])[,k_4,],
      upr = array_format(tmp["97.5%",])[,k_4,]
    )
  }
)

# prep values to plot: weir compositon age-5
plot_dat$p_Ra_age5 = list(
  obs = x_Ra_new_obs$x_Ra_age_obs[,k_5,]/apply(x_Ra_new_obs$x_Ra_age_obs, 3, rowSums),
  fitted = {
    tmp = post_summ(post, sub_index("^p_Ra_age[year,3,pop]", year = ".+", pop = ".+"))
    list(
      mn = array_format(tmp["mean",])[,k_5,],
      lwr = array_format(tmp["2.5%",])[,k_5,],
      upr = array_format(tmp["97.5%",])[,k_5,]
    )
  }
)

# prep values to plot: weir compositon origin
plot_dat$p_Ra_nor = list(
  obs = x_Ra_new_obs$x_Ra_origin_obs[,o_nor,]/apply(x_Ra_new_obs$x_Ra_origin_obs, 3, rowSums),
  fitted = {
    tmp = post_summ(post, sub_index("^p_Ra_origin[year,1,pop]", year = ".+", pop = ".+"))
    list(
      mn = array_format(tmp["mean",])[,o_nor,],
      lwr = array_format(tmp["2.5%",])[,o_nor,],
      upr = array_format(tmp["97.5%",])[,o_nor,]
    )
  }
)

# prep values to plot: carcass compositon age-3
plot_dat$p_Sa_prime_age3 = list(
  obs = x_Sa_prime_new_obs$x_Sa_prime_age_obs[,k_3,]/apply(x_Sa_prime_new_obs$x_Sa_prime_age_obs, 3, rowSums),
  fitted = {
    tmp = post_summ(post, sub_index("^p_Sa_prime_age[year,1,pop]", year = ".+", pop = ".+"))
    list(
      mn = array_format(tmp["mean",])[,k_3,],
      lwr = array_format(tmp["2.5%",])[,k_3,],
      upr = array_format(tmp["97.5%",])[,k_3,]
    )
  }
)

# prep values to plot: carcass compositon age-4
plot_dat$p_Sa_prime_age4 = list(
  obs = x_Sa_prime_new_obs$x_Sa_prime_age_obs[,k_4,]/apply(x_Sa_prime_new_obs$x_Sa_prime_age_obs, 3, rowSums),
  fitted = {
    tmp = post_summ(post, sub_index("^p_Sa_prime_age[year,2,pop]", year = ".+", pop = ".+"))
    list(
      mn = array_format(tmp["mean",])[,k_4,],
      lwr = array_format(tmp["2.5%",])[,k_4,],
      upr = array_format(tmp["97.5%",])[,k_4,]
    )
  }
)

# prep values to plot: weir compositon age-5
plot_dat$p_Sa_prime_age5 = list(
  obs = x_Sa_prime_new_obs$x_Sa_prime_age_obs[,k_5,]/apply(x_Sa_prime_new_obs$x_Sa_prime_age_obs, 3, rowSums),
  fitted = {
    tmp = post_summ(post, sub_index("^p_Sa_prime_age[year,3,pop]", year = ".+", pop = ".+"))
    list(
      mn = array_format(tmp["mean",])[,k_5,],
      lwr = array_format(tmp["2.5%",])[,k_5,],
      upr = array_format(tmp["97.5%",])[,k_5,]
    )
  }
)

# prep values to plot: weir compositon origin
plot_dat$p_Sa_prime_nor = list(
  obs = x_Sa_prime_new_obs$x_Sa_prime_origin_obs[,o_nor,]/apply(x_Sa_prime_new_obs$x_Sa_prime_origin_obs, 3, rowSums),
  fitted = {
    tmp = post_summ(post, sub_index("^p_Sa_prime_origin[year,1,pop]", year = ".+", pop = ".+"))
    list(
      mn = array_format(tmp["mean",])[,o_nor,],
      lwr = array_format(tmp["2.5%",])[,o_nor,],
      upr = array_format(tmp["97.5%",])[,o_nor,]
    )
  }
)

# function to create plot for one data type
plot_f = function(dat_list, f, label = "", adj_label = FALSE) {
  
  with(dat_list, {
    
    # handle outlying values
    # obs[obs == 0] = NA
    # obs[obs == 1] = NA
    obs[obs == "NaN"] = NA
    
    # apply transformations
    obs = f(obs)
    mn = f(fitted$mn)
    lwr = f(fitted$lwr)
    upr = f(fitted$upr)
    
    # set fitted value to NA if no data value
    mn[is.na(obs)] = NA
    lwr[is.na(obs)] = NA
    upr[is.na(obs)] = NA
    
    # obtain axis limits
    lim = range(mn, lwr, upr, obs, na.rm = TRUE)
    
    # create the plot
    plot(mn ~ obs, xlim = lim, ylim = lim, pch = 21, col = solid_col, bg = tranp_col, cex = 1.5)
    
    # draw fitted value CRIs
    # segments(obs, lwr, obs, upr)
    
    # draw 1:1 line
    abline(0,1, lty = 2)
    
    # add text
    panel_label(label, x_inp = ifelse(adj_label, 0.05, 0.015), cex = 0.95)
  })
}

# identity function
ifun = function(x) x

# png("fig.png", h = 7 * ppi, w = 7.2 * ppi, res = ppi)
mypar(mfrow = c(1,1), oma = c(1.5,1.5,0,1.5), col.axis = "black", mar = c(1,0.75,0.5,0.25))
# r1 = rep(1:3, each = 4); r2 = rep(4:7, each = 3); r3 = rep(8:11, each = 3); r4 = rep(12:15, each = 3)
r1 = rep(1:3, each = 4); r2 = rep(4:9, each = 2); r3 = rep(10:13, each = 3); r4 = rep(14:17, each = 3)
layout(rbind(r1, r2, r3, r4))
# layout.show(17); dev.off()

# abundance plots
plot_f(plot_dat[["Pa_fall"]], ifun, "(a) Fall Trap Passage")
plot_f(plot_dat[["Mb_spring"]], ifun, "(b) Spring Trap Passage")
plot_f(plot_dat[["Ra_tot"]], ifun, "(c) Adult Return to River"); mtext(side = 4, text = "Abundance", outer = FALSE, line = 0.55)

# survival plots
plot_f(plot_dat[["phi_Pb_Ma"]], ifun, "(d) Summer \u2192 LGR", TRUE)
plot_f(plot_dat[["phi_Pa_Ma_fall"]], ifun, "(e) Fall \u2192 LGR", TRUE)
plot_f(plot_dat[["phi_Pa_Ma_winter"]], ifun, "(f) Winter \u2192 LGR", TRUE)
plot_f(plot_dat[["phi_Mb_Ma"]], ifun, "(g) Spring \u2192 LGR", TRUE)#; mtext(side = 4, text = "Survival", outer = FALSE, line = 0.75)
plot_f(plot_dat[["phi_Ma_O0"]], ifun, "(h) LGR \u2192 BON", TRUE)
plot_f(plot_dat[["phi_Rb_Ra"]], ifun, "(i) BON \u2192 LGR", TRUE); mtext(side = 4, text = "Survival", outer = FALSE, line = 0.55)

# composition plots
plot_f(plot_dat[["p_Ra_age3"]], ifun, "(j) Proportion Age-3")
plot_f(plot_dat[["p_Ra_age4"]], ifun, "(k) Proportion Age-4")
plot_f(plot_dat[["p_Ra_age5"]], ifun, "(l) Proportion Age-5")
plot_f(plot_dat[["p_Ra_nor"]], ifun, "(m) Proportion NOR"); mtext(side = 4, text = "Weir Composition", outer = FALSE, line = 0.55)

# composition plots
plot_f(plot_dat[["p_Sa_prime_age3"]], ifun, "(n) Proportion Age-3")
plot_f(plot_dat[["p_Sa_prime_age4"]], ifun, "(o) Proportion Age-4")
plot_f(plot_dat[["p_Sa_prime_age5"]], ifun, "(p) Proportion Age-5")
plot_f(plot_dat[["p_Sa_prime_nor"]], ifun, "(q) Proportion NOR"); mtext(side = 4, text = "Carcass Composition", outer = FALSE, line = 0.55)

# axis labels
axis_labels("Observed Value", "Fitted Value", yline = 0.25)

# dev.off(); file.show("fig.png")
```

\newpage

```{r compare-fn, eval = params$surv_compare_fig | params$apportion_compare_fig}
pch = c(21, 23)

cex_main = 2.5
cex_sub = 1.1

solid_col = "grey40"
tranp_col = alpha(solid_col, 0.25)

f_horiz = function(ests1, ests2, lim, label) {
  # prepare the first group of estimates
  ests1 = ests1[-1,]; x1 = colMeans(ests1)
  
  # figure out the correct axis labels
  if (ncol(ests1) == 4) tick_labels = pops else tick_labels = c("NOR", "HOR")
  jitter = runif(nrow(ests1), -0.25, 0.25)
  
  if (is.null(ests2)) {
    # empty barplot with correct dimensions
    mp = barplot(x1, col = "white", border = "white", xlim = lim, ylim = c(ncol(ests1) + 0.5, 0.05), horiz = TRUE)
    
    # figure out location of jittered points
    mp_all = t(sapply(1:nrow(ests1), function(i) mp))
    mp_all = apply(mp_all, 2, function(x) x + jitter)
    
    # draw year-specific estimates
    points(ests1, mp_all, col = solid_col, bg = tranp_col, pch = pch[1], cex = cex_sub)
    
    # draw year averages
    points(x1, mp, pch = pch[1], col = "white", bg = "black", cex = cex_main, lwd = 1.5)
    
    # draw axis
    omgp = par("mgp"); nmgp = omgp; nmgp[2] = 0.15
    par(mgp = nmgp)
    usr = par("usr"); xdiff = diff(usr[1:2]); ydiff = diff(usr[3:4])
    segments(usr[1], usr[3], usr[1], usr[4], xpd = TRUE, col = par("col.axis"))
    axis(side = 2, at = mp, labels = tick_labels, las = 1)
    par(mgp = omgp)
    
  } else {
    # prepare the second group of estimates if supplied
    ests2 = ests2[-1,]; x2 = colMeans(ests2)
    
    # empty barplot with correct dimensions
    mp = barplot(rbind(x1, x2), beside = TRUE, space = c(0.25,1), col = "white", border = "white", xlim = lim, ylim = c(ncol(ests1) * 3 + 1, 0.15), horiz = TRUE)
    mp1 = mp[1,]; mp2 = mp[2,]
    
    # figure out location of jittered points
    mp1_all = t(sapply(1:nrow(ests1), function(i) mp1))
    mp1_all = apply(mp1_all, 2, function(x) x + jitter)
    mp2_all = t(sapply(1:nrow(ests2), function(i) mp2))
    mp2_all = apply(mp2_all, 2, function(x) x + jitter)
    
    # draw year-specific estimates
    points(ests1, mp1_all, col = solid_col, bg = tranp_col, pch = pch[1], cex = cex_sub)
    points(ests2, mp2_all, col = solid_col, bg = tranp_col, pch = pch[2], cex = cex_sub)
    
    # draw year averages
    points(x1, mp1, pch = pch[1], cex = cex_main, bg = "black", col = "white", lwd = 1.5)
    points(x2, mp2, pch = pch[2], cex = cex_main, bg = "black", col = "white", lwd = 1.5)
    
    # draw axis
    omgp = par("mgp"); nmgp = omgp; nmgp[2] = 0.15
    par(mgp = nmgp)
    usr = par("usr"); xdiff = diff(usr[1:2]); ydiff = diff(usr[3:4])
    segments(usr[1], usr[3], usr[1], usr[4], xpd = TRUE, col = par("col.axis"))
    axis(side = 2, at = (mp1 + mp2)/2, labels = tick_labels, las = 1)
    par(mgp = omgp)
  }
  
  # draw panel label
  panel_label(label, y_inp = ifelse(ncol(ests1) == 4, 0.05, 0.1), cex = 1.2)
}

legend_f = function(title, grp1, grp2, loc = "topright") {
  legend(loc, title = title, legend = c(grp1, grp2), pch = pch, pt.cex = 1.3, cex = 0.9, bty = "n",
         text.col = par("col.axis"), col = "black", pt.bg = "black")
}
```

```{r surv-compare-fig, fig.width = 3.4, fig.height = 8, fig.cap = msdown::prep_caption(surv_compare_caption), time_it = TRUE, eval = params$surv_compare_fig}

# extract the posterior means to plot
phi_E_Pb = array_format(post_summ(post, sub_index("^phi_E_Pb[year,pop]", year = observable, pop = ".+"))["mean",])
phi_Pa_Mb_fall = array_format(post_summ(post, sub_index("^phi_Pa_Mb[year,LH_type,pop]", year = observable, pop = ".+", LH_type = i_fall))["mean",])[,i_fall,]
phi_Pa_Mb_spring = array_format(post_summ(post, sub_index("^phi_Pa_Mb[year,LH_type,pop]", year = observable, pop = ".+", LH_type = i_spring))["mean",])[,i_spring,]
phi_Mb_Ma_nor = array_format(post_summ(post, sub_index("^phi_Mb_Ma[year,LH_type,origin,pop]", year = observable, pop = ".+", LH_type = i_spring, origin = o_nor))["mean",])[,i_spring,o_nor,]
phi_Mb_Ma_hor = array_format(post_summ(post, sub_index("^phi_Mb_Ma[year,LH_type,origin,pop]", year = observable, pop = ".+", LH_type = i_spring, origin = o_hor))["mean",])[,i_spring,o_hor,]
phi_Ma_O0 = array_format(post_summ(post, sub_index("^phi_Ma_O0[year,origin]", year = observable, origin = ".+"))["mean",])
phi_O0_O1_nor = array_format(post_summ(post, sub_index("^phi_O0_O1[year,origin,pop]", year = observable, pop = ".+", origin = o_nor))["mean",])[,o_nor,]
phi_O0_O1_hor = array_format(post_summ(post, sub_index("^phi_O0_O1[year,origin,pop]", year = observable, pop = ".+", origin = o_hor))["mean",])[,o_hor,]
phi_Rb_Ra = array_format(post_summ(post, sub_index("^phi_Rb_Ra[year,origin]", year = observable, origin = ".+"))["mean",])

# set MIN to NA for HOR values
phi_Mb_Ma_hor[,j_min] = NA
phi_O0_O1_hor[,j_min] = NA

mypar(mfrow = c(1,1), oma = c(1.5,1,0,1), col.axis = "black")
layout(matrix(1:5, ncol = 1), height = c(1,1,1,0.5,1))
f_horiz(ests1 = phi_E_Pb, ests2 = NULL, lim = c(0, 0.5), label = "(a) Egg \u2192 Parr")

f_horiz(ests1 = phi_Pa_Mb_fall, ests2 = phi_Pa_Mb_spring, lim = c(0,1), label = "(b) Parr \u2192 Smolt")
legend_f("Mig. Type", "Fall", "Spring")

f_horiz(ests1 = phi_Mb_Ma_nor, ests2 = phi_Mb_Ma_hor, lim = c(0,1), label = "(c) Smolt \u2192 LGR")
legend_f("Origin", "NOR", "HOR")

f_horiz(ests1 = phi_Ma_O0, ests2 = phi_Rb_Ra, lim = c(0,1), label = "(d) Mainstem")
legend_f("Direction", "LGR \u2192 BON", "BON \u2192 LGR", "bottomleft")

f_horiz(ests1 = phi_O0_O1_nor, ests2 = phi_O0_O1_hor, lim = c(0,0.4), label = "(e) Ocean-0 \u2192 Ocean-1")
legend_f("Origin", "NOR", "HOR", "bottomright")
axis_labels("Survival Probability")
```

\newpage

```{r apportion-compare-fig, fig.width = 3.4, fig.height = 8 * (3/4.5), fig.cap = msdown::prep_caption(apportion_compare_caption), time_it = TRUE, eval = params$apportion_compare_fig}

# extract the posterior means to plot
pi_fall = array_format(post_summ(post, sub_index("^pi[year,LH_type,pop]", year = observable, pop = ".+", LH_type = i_fall))["mean",])[,i_fall,]
psi_O1_nor = array_format(post_summ(post, sub_index("^psi_O1[year,origin,pop]", year = observable, pop = ".+", origin = o_nor))["mean",])[,o_nor,]
psi_O1_hor = array_format(post_summ(post, sub_index("^psi_O1[year,origin,pop]", year = observable, pop = ".+", origin = o_hor))["mean",])[,o_hor,]
psi_O2_nor = array_format(post_summ(post, sub_index("^psi_O2[year,origin,pop]", year = observable, pop = ".+", origin = o_nor))["mean",])[,o_nor,]
psi_O2_hor = array_format(post_summ(post, sub_index("^psi_O2[year,origin,pop]", year = observable, pop = ".+", origin = o_hor))["mean",])[,o_hor,]

# set MIN to NA for HOR values
psi_O1_hor[,j_min] = NA
psi_O1_hor[,j_min] = NA

mypar(mfrow = c(1,1), oma = c(1.5,1,0,1), col.axis = "black")
layout(matrix(1:3, ncol = 1), height = c(1,1,1))
f_horiz(ests1 = pi_fall, ests2 = NULL, lim = c(0, 0.6), label = "(a) Pr(Fall Migrant)")

f_horiz(ests1 = psi_O1_nor, ests2 = psi_O1_hor, lim = c(0,0.4), label = "(b) Pr(Mature Age-3)")
legend_f("Origin", "NOR", "HOR")

f_horiz(ests1 = psi_O2_nor, ests2 = psi_O2_hor, lim = c(0,1), label = "(c) Pr(Mature Age-4)")
legend_f("Origin", "NOR", "HOR", "bottomleft")

axis_labels("Transition Probability (Non-Survival)")
```

\newpage

```{r relationship-fig, fig.width = 7.2, fig.height = 9, fig.cap = msdown::prep_caption(relationship_caption), time_it = TRUE, eval = params$relationship_fig}

##### EGG-TO-PARR SURVIVAL VS. EGG DENSITY #####

phi_E_Pa_VS_E_per_WUL = function(j, xlim = NULL, ylim = NULL) {
  
  # extract posterior summaries of total egg production by brood year
  E = post_summ(post, sub_index("^E[.+,pop]", pop = j))
  
  # extract posterior summaries of egg to parr survival rates
  phi_E_Pb = post_summ(post, sub_index("^phi_E_Pb[.+,pop]", pop = j))
  
  # extract posterior samples of the BH parameters
  bh_params = post_subset(post, sub_index(c("alpha[pop]", "^beta[pop]$"), pop = j), matrix = TRUE)
  
  # construct vector of egg abundances to predict at
  E_pred = seq(0.1, max(E[1,]), length = 30)
  
  # obtain predicted curves for each posterior sample
  phi_E_Pb_pred = t(sapply(1:post_dim(post, "saved"), function(i) 1/((1/bh_params[i,1]) + E_pred/bh_params[i,2])))
  
  # obtain posterior summary of predicted curve
  colnames(phi_E_Pb_pred) = paste0("phi_E_Pb_pred[", 1:length(E_pred), "]")
  phi_E_Pb_pred = post_convert(cbind(postpack:::id_mat(post), phi_E_Pb_pred))
  phi_E_Pb_pred = post_summ(phi_E_Pb_pred, "phi_E_Pb_pred")
  
  # set xaxis limits
  if (is.null(xlim)) xlim = c(0, max(E[1,]))
  
  # set yaxis limits
  if (is.null(ylim)) ylim = range(0, phi_E_Pb["mean",], phi_E_Pb_pred["2.5%",], phi_E_Pb_pred["97.5%",])
  
  # empty plot with correct dimensions
  plot(phi_E_Pb["mean",] ~ E["mean",],
       ylim = ylim,
       xlim = xlim, type = "n",
       xaxt = "n")
  
  # panel label
  panel_label(paste0("(", paste0("a", j), ")"), "topright", y_inp = 0.075)
  
  # draw prettier x-axis
  x_ticks = axisTicks(par("usr")[1:2], log = F)
  axis(side = 1, at = x_ticks, labels = x_ticks/1e6)
  
  # add credible region for predicted curve
  polygon(c(E_pred, rev(E_pred)), c(phi_E_Pb_pred["2.5%",], rev(phi_E_Pb_pred["97.5%",])), col = tranp_col, border = NA)
  
  # add posterior mean predicted curve
  lines(phi_E_Pb_pred["mean",] ~ E_pred, lwd = 2, col = solid_col2)
  
  # add posterior mean of realized pairs
  points(phi_E_Pb["mean",] ~ E["mean",], pch = 21, col = solid_col, bg = tranp_col, cex = pt_cex)
  
  # draw boundary box
  box()
}

##### PARR RECRUITMENT VS. EGG PRODUCTION #####

Pb_VS_E = function(j, xlim = NULL, ylim = NULL) {
  
  # extract posterior summaries of total egg production by brood year
  E = post_summ(post, sub_index("^E[.+,pop]", pop = j))
  
  # extract posterior summaries of total parr production by brood year
  Pb = post_summ(post, sub_index("^Pb[.+,pop]", pop = j))
  
  # extract posterior samples of the BH parameters
  bh_params = post_subset(post, sub_index(c("alpha[pop]", "^beta[pop]$"), pop = j), matrix = TRUE)
  
  # construct vector of egg abundances to predict at
  E_pred = seq(0.1, max(E[1,]), length = 30)
  
  # obtain predicted curves for each posterior sample
  Pb_pred = t(sapply(1:post_dim(post, "saved"), function(i) E_pred/((1/bh_params[i,1]) + E_pred/bh_params[i,2])))
  
  # obtain posterior summary of predicted curve
  colnames(Pb_pred) = paste0("Pb_pred[", 1:length(E_pred), "]")
  Pb_pred = post_convert(cbind(postpack:::id_mat(post), Pb_pred))
  Pb_pred = post_summ(Pb_pred, "Pb_pred")
  
  # set xaxis limits
  if (is.null(xlim)) xlim = c(0, max(E[1,]))
  
  # set yaxis limit
  if (is.null(ylim)) ylim = c(0, max(Pb[1,]))
  
  # empty plot with correct dimensions
  plot(Pb["mean",] ~ E["mean",],
       ylim = ylim,
       xlim = xlim, type = "n",
       xaxt = "n",
       yaxt = "n")
  
  # panel label
  panel_label(paste0("(", paste0("b", j), ")"), "topright", y_inp = 0.075)
  
  # draw prettier x-axis
  x_ticks = axisTicks(par("usr")[1:2], log = F)
  axis(side = 1, at = x_ticks, labels = x_ticks/1e6)
  
  # draw prettier y-axis
  y_ticks = axisTicks(par("usr")[3:4], log = F)
  axis(side = 2, at = y_ticks, labels = y_ticks/1e3)
  
  # add credible region for predicted curve
  polygon(c(E_pred, rev(E_pred)), c(Pb_pred["2.5%",], rev(Pb_pred["97.5%",])), col = tranp_col, border = NA)
  
  # add posterior mean predicted curve
  lines(Pb_pred["mean",] ~ E_pred, lwd = 2, col = solid_col2)
  
  # add posterior mean of realized pairs
  points(Pb["mean",] ~ E["mean",], pch = 21, col = solid_col, bg = tranp_col, cex = pt_cex)
  
  # draw boundary box
  box()
}

##### PARR SIZE VS. EGG DENSITY #####

L_Pb_VS_E_per_WUL = function(j, xlim = NULL, ylim = NULL) {
  # obtain posterior samples of total egg abundance scaled to WUL
  E = post_subset(post, sub_index("^E[.+,pop]", pop = j), matrix = TRUE)
  E_scaled = (E/jags_data$E_scale)/jags_data$wul[j]
  colnames(E_scaled) = gsub("E", "E_scaled", x = colnames(E_scaled))
  post_E = post_convert(cbind(postpack:::id_mat(post), E_scaled))
  
  # summarize scaled egg abundance
  E_scaled_mean = post_summ(post_E, "E_scaled")["mean",]
  
  # create a vector of scaled egg abundances to predict at
  E_scaled_seq = seq(min(E_scaled_mean), max(E_scaled_mean), length = 30)
  
  # extract posteriors of coefficients
  omega0 = post_subset(post, sub_index("omega0[pop]", pop = j), matrix = TRUE)
  omega1 = post_subset(post, sub_index("omega1[pop]", pop = j), matrix = TRUE)
  
  # extract posterior summaries of summer length outcomes
  L_Pb_mean = post_summ(post, sub_index("^L_Pb[.+,pop]", pop = j))["mean",]
  
  # function to create predicted survival curves for one posterior sample
  pred_fn = function(i) {
    pred_L_Pb = exp(omega0[i] + omega1[i] * log(E_scaled_seq))
    names(pred_L_Pb) = paste0("pred_L_Pb[", 1:30, "1]")
    pred_L_Pb
  }
  
  # calculate predicted length
  pred_L_Pb = t(sapply(1:post_dim(post, "saved"), pred_fn))
  post_pred_L_Pb = post_convert(cbind(postpack:::id_mat(post), pred_L_Pb))
  
  # extract summarized predicted length
  pred_L_Pb_mean = post_summ(post_pred_L_Pb, ".")["mean",]
  pred_L_Pb_lwr = post_summ(post_pred_L_Pb, ".")["2.5%",]
  pred_L_Pb_upr = post_summ(post_pred_L_Pb, ".")["97.5%",]
  
  E_scaled_seq = (E_scaled_seq * jags_data$wul[j] * jags_data$E_scale)/1e6
  E_scaled_mean = (E_scaled_mean * jags_data$wul[j] * jags_data$E_scale)/1e6
  
  # set xaxis limit
  if (is.null(xlim)) xlim = range(0, E_scaled_seq)
  
  # set yaxis limit
  if (is.null(ylim)) ylim = range(L_Pb_mean, pred_L_Pb_lwr, pred_L_Pb_upr, na.rm = TRUE)
  
  # empty plot with correct dimensions
  plot(1,1, type = "n", 
       ylim = ylim,
       xlim = xlim
  )
  
  # panel label
  panel_label(paste0("(", paste0("c", j), ")"), "topright", y_inp = 0.075)
  
  # add credible region for predicted curve
  polygon(c(E_scaled_seq, rev(E_scaled_seq)), c(pred_L_Pb_lwr, rev(pred_L_Pb_upr)), border = NA, col = tranp_col)
  
  # add posterior mean predicted curve
  lines(pred_L_Pb_mean ~ E_scaled_seq, col = solid_col2, lwd = 2)
  
  # add posterior mean of realized pairs
  points(L_Pb_mean ~ E_scaled_mean, pch = 21, col = solid_col, bg = tranp_col, cex = pt_cex)
  
  # draw boundary box
  box()
}

##### OVERWINTER SURVIVAL VS. PARR SIZE #####

phi_Pa_Mb_VS_L_Pb = function(j, i, xlim = NULL, ylim = NULL) {
  
  pch = c(21, 23)
  lty = c(1, 2)
  
  # extract posterior summaries of summer length outcomes
  L_Pb_mean = post_summ(post, sub_index("^L_Pb[year,pop]", year = ".+", pop = j))["mean",]
  
  # obtain scaled/centered versions
  L_Pb_star_mean = (L_Pb_mean - jags_data$L_Pb_center[j])/jags_data$L_Pb_scale[j]
  
  # summarize posterior of overwinter survival outcomes
  phi_Pa_Mb_mean = array_format(post_summ(post, sub_index("^phi_Pa_Mb[.+,LH_type,pop]", pop = j, LH_type = i))["mean",])[-1,i,j]
  
  # create vector of lengths to predict at
  L_Pb_seq = seq(min(L_Pb_mean), max(L_Pb_mean), length = 30)
  L_Pb_star_seq = seq(min(L_Pb_star_mean), max(L_Pb_star_mean), length = 30)
  
  # extract posteriors of coefficients
  gamma0 = post_subset(post, sub_index("gamma0[LH_type,pop]", pop = j, LH_type = i), matrix = TRUE)
  gamma1 = post_subset(post, sub_index("gamma1[LH_type,pop]", pop = j, LH_type = i), matrix = TRUE)
  
  # function to create predicted survival curve for one posterior sample
  pred_fn = function(i) {
    pred_phi_Pa_Mb = plogis(gamma0[i] + gamma1[i] * L_Pb_star_seq)
    names(pred_phi_Pa_Mb) = paste0("pred_phi_Pa_Mb[", 1:30, "]")
    pred_phi_Pa_Mb
  }
  
  # calculate predicted survivals and add to posterior samples
  pred_phi_Pa_Mb = t(sapply(1:post_dim(post, "saved"), pred_fn))
  post_pred_phi_Pa_Mb = post_convert(cbind(postpack:::id_mat(post), pred_phi_Pa_Mb))
  
  # summarize predicted survival
  pred_phi_Pa_Mb_mean = post_summ(post_pred_phi_Pa_Mb, ".")["mean",]
  pred_phi_Pa_Mb_lwr = post_summ(post_pred_phi_Pa_Mb, ".")["2.5%",]
  pred_phi_Pa_Mb_upr = post_summ(post_pred_phi_Pa_Mb, ".")["97.5%",]
  
  # set xaxis limits
  if (is.null(xlim)) xlim = range(L_Pb_seq)
  
  # set yaxis limits
  if (is.null(ylim)) ylim = range(0, pred_phi_Pa_Mb_lwr, pred_phi_Pa_Mb_upr, phi_Pa_Mb_mean)
  
  # empty plot with correct dimensions
  if (i == 1) {
    plot(1,1, type = "n", 
         ylim = ylim,
         xlim = xlim,
         xlab = "", ylab = ""
    )
  }
  
  # panel label
  panel_label(paste0("(", paste0("d", j), ")"), "topright", y_inp = 0.075)
  
  # add credible region for predicted curve
  polygon(c(L_Pb_seq, rev(L_Pb_seq)), c(pred_phi_Pa_Mb_lwr, rev(pred_phi_Pa_Mb_upr)), border = NA, col = tranp_col)
  
  # add posterior mean predicted curve
  lines(pred_phi_Pa_Mb_mean ~ L_Pb_seq, col = solid_col2, lwd = 2, lty = lty[i])
  
  # add posterior mean of realized pairs
  points(phi_Pa_Mb_mean ~ L_Pb_mean, pch = pch[i], col = solid_col, bg = tranp_col, cex = pt_cex)
  
  legend_pop = 2
  if (j == legend_pop & i == 1) {
    legend("topleft", legend = c("Fall", "Spring"), title = "Mig. Type", pch = pch, pt.bg = tranp_col, col = solid_col, pt.cex = pt_cex, cex = 0.8, bty = "n")
  }
  
  # draw boundary box
  box()
}


##### SMOLT SIZE VS PARR SIZE #####

L_Mb_VS_L_Pb = function(j, xlim = NULL, ylim = NULL) {
  
  # extract posterior summaries of summer length outcomes
  L_Pb_mean = post_summ(post, sub_index("^L_Pb[year,pop]", year = ".+", pop = j))["mean",]
  
  # extract posterior summaries of spring length outcomes
  L_Mb_mean = post_summ(post, sub_index("^L_Mb[year,pop]", year = ".+", pop = j))["mean",]
  
  # create a vector of scaled summer lengths to predict at
  L_Pb_seq = seq(min(L_Pb_mean), max(L_Pb_mean), length = 30)
  L_Pb_star_seq = (L_Pb_seq - jags_data$L_Pb_center[j])/jags_data$L_Pb_scale[j]
  
  # extract posteriors of coefficients
  theta0 = post_subset(post, sub_index("theta0[pop]", pop = j), matrix = TRUE)
  theta1 = post_subset(post, sub_index("theta1[pop]", pop = j), matrix = TRUE)
  
  # function to create predicted curves for one posterior sample
  pred_fn = function(i) {
    pred_L_Mb = exp(theta0[i] + theta1[i] * L_Pb_star_seq) * L_Pb_seq
    names(pred_L_Mb) = paste0("pred_L_Mb[", 1:30, "1]")
    pred_L_Mb
  }
  
  # calculate predicted growth values and add to posterior samples
  pred_L_Mb = t(sapply(1:post_dim(post, "saved"), pred_fn))
  post_pred_L_Mb = post_convert(cbind(postpack:::id_mat(post), pred_L_Mb))
  
  # summarize predicted growth
  pred_L_Mb_mean = post_summ(post_pred_L_Mb, ".")["mean",]
  pred_L_Mb_lwr = post_summ(post_pred_L_Mb, ".")["2.5%",]
  pred_L_Mb_upr = post_summ(post_pred_L_Mb, ".")["97.5%",]
  
  # set xaxis limits
  if (is.null(xlim)) xlim = range(L_Pb_seq)
  
  # set yaxis limits
  if (is.null(ylim)) ylim = range(pred_L_Mb_lwr, pred_L_Mb_upr, L_Mb_mean, na.rm = TRUE)
  
  # empty plot with the correct dimensions
  plot(1,1, type = "n", 
       ylim = ylim,
       xlim = xlim, 
       xlab = "", ylab = ""
  )
  
  # panel label
  panel_label(paste0("(", paste0("e", j), ")"), "topright", y_inp = 0.075)
  
  # add credible region for predicted curve
  polygon(c(L_Pb_seq, rev(L_Pb_seq)), c(pred_L_Mb_lwr, rev(pred_L_Mb_upr)), border = NA, col = tranp_col)
  
  # add posterior mean of predicted curve
  lines(pred_L_Mb_mean ~ L_Pb_seq, col = solid_col2, lwd = 2)
  
  # add posterior mean of realized pairs
  points(L_Mb_mean ~ L_Pb_mean, pch = 21, col = solid_col, bg = tranp_col, cex = pt_cex)
  
  # draw boundary box
  box()
}

##### SURVIVAL TO LGR VS. SMOLT SIZE #####

phi_Mb_Ma_VS_L_Mb = function(j, xlim = NULL, ylim = NULL) {
  
  # extract posterior summaries of spring length outcomes
  L_Mb_mean = post_summ(post, sub_index("^L_Mb[year,pop]", year = ".+", pop = j))["mean",]
  
  # obtain scaled/centered versions
  L_Mb_star_mean = (L_Mb_mean - jags_data$L_Mb_center[j])/jags_data$L_Mb_scale[j]
  
  # summarize posterior of migration to LGR survival outcomes
  phi_Mb_Ma_mean = array_format(post_summ(post, sub_index("^phi_Mb_Ma[.+,LH_type,origin,pop]", pop = j, LH_type = 1, origin = 1))["mean",])[-1,1,1,j]
  
  # create vectors to predict survival at: for credible regions and mean curve
  L_Mb_seq = seq(min(L_Mb_mean), max(L_Mb_mean), length = 30)
  L_Mb_star_seq = seq(min(L_Mb_star_mean), max(L_Mb_star_mean), length = 30)
  
  # extract posteriors of coefficients
  tau0 = post_subset(post, sub_index("tau0[pop]", pop = j), matrix = TRUE)
  tau1 = post_subset(post, sub_index("tau1[pop]", pop = j), matrix = TRUE)
  
  # function to create predicted survival curve for one posterior sample
  pred_fn = function(i) {
    pred_phi_Mb_Ma = plogis(tau0[i] + tau1[i] * L_Mb_star_seq)
    names(pred_phi_Mb_Ma) = paste0("pred_phi_Mb_Ma[", 1:30, "]")
    pred_phi_Mb_Ma
  }
  
  # calculate predicted survivals for each posterior sample
  pred_phi_Mb_Ma = t(sapply(1:post_dim(post, "saved"), pred_fn))
  post_pred_phi_Mb_Ma = post_convert(cbind(postpack:::id_mat(post), pred_phi_Mb_Ma))
  
  # summarize predicted survival
  pred_phi_Mb_Ma_mean = post_summ(post_pred_phi_Mb_Ma, ".")["mean",]
  pred_phi_Mb_Ma_lwr = post_summ(post_pred_phi_Mb_Ma, ".")["2.5%",]
  pred_phi_Mb_Ma_upr = post_summ(post_pred_phi_Mb_Ma, ".")["97.5%",]
  
  # set xaxis limits
  if (is.null(xlim)) xlim = range(L_Mb_seq)
  
  # set yaxis limits
  if (is.null(ylim)) ylim = range(pred_phi_Mb_Ma_lwr, pred_phi_Mb_Ma_upr, phi_Mb_Ma_mean)
  
  # empty plot with correct dimensions
  plot(1,1, type = "n", 
       ylim = ylim,
       xlim = xlim,
       xlab = "", ylab = ""
  )
  
  # panel label
  panel_label(paste0("(", paste0("f", j), ")"), "topright", y_inp = 0.075)
  
  # add credible region for predicted curve
  polygon(c(L_Mb_seq, rev(L_Mb_seq)), c(pred_phi_Mb_Ma_lwr, rev(pred_phi_Mb_Ma_upr)), border = NA, col = tranp_col)
  
  # add posterior mean of predicted curve
  lines(pred_phi_Mb_Ma_mean ~ L_Mb_seq, col = solid_col2, lwd = 2)
  
  # add posterior mean of realized pairs
  points(phi_Mb_Ma_mean ~ L_Mb_mean, pch = 21, col = solid_col, bg = tranp_col, cex = pt_cex)
}

##### LARGE MULTI-PANEL PLOT #####

make_layout = function(nrow, ncol, show = FALSE) {
  m = NULL
  for (r in 1:nrow) {
    if (r == 1) {
      f = 1
    } else {
      f = max(m) + 1
    }
    l = f+ncol-1
    tmp = rbind(f:l, rep(l+1, ncol))
    m = rbind(m, tmp)
  }
  layout(m, heights = rep(c(1, 0.25), nrow))
  if (show) layout.show(max(m))
}

g = function(ylim = c(-3,3), xlim = c(-3,3)) {
  x = rnorm(30)
  y = rnorm(30)
  plot(y ~ x, xlab = "", ylab = "", xlim = xlim, ylim = ylim)
}

yaxis_label = function(label_main, label_sub) {
  mtext(side = 2, outer = FALSE, label_main, line = 2.25, cex = 0.9)
  mtext(side = 2, outer = FALSE, label_sub, line = 1.25, cex = 0.75, font = 3)
}

xaxis_label = function(label) {
  plot(1, 1, type = "n", xlim = c(0,1), ylim = c(0,1), axes = FALSE)
  text(0.5, 0.3, label = label, cex = 1.25, xpd = TRUE)
}

make_layout(nrow = 6, ncol = 4, show = FALSE)

par(mar = c(0.5,1.5,0,0), oma = c(0,2,1.5,1), tcl = 0, mgp = c(200,0.05,0),
    lend = "square", ljoin = "mitre")

# egg to parr survival vs. egg density
# ylim = make_lim(post_summ(post, "^phi_E_Pb[")["mean",])
ylim = c(0,0.4)
xlim = make_lim(post_summ(post, "^E[")["mean",]); xlim[1] = 0
junk = sapply(1:4, function(j) {
  phi_E_Pa_VS_E_per_WUL(j, xlim = xlim, ylim = ylim)
  if (j == 1) yaxis_label("Egg \u2192 Parr Survival", "")
  mtext(side = 3, outer = FALSE, line = 0, pops[j], font = 2)
}); xaxis_label("Total Egg Production (Millions)")

# parr recruitment vs. total egg production
ylim = make_lim(post_summ(post, "^Pb[")["mean",]); ylim[1] = 0
xlim = make_lim(post_summ(post, "^E[")["mean",]); xlim[1] = 0
junk = sapply(1:4, function(j) {
  Pb_VS_E(j, xlim = xlim, ylim = ylim)
  if (j == 1) yaxis_label("Parr Recruitment", "Thousands")
}); xaxis_label("Total Egg Production (Millions)")

# parr size vs. egg production
ylim = make_lim(post_summ(post, "^L_Pb[")["mean",])
xlim = make_lim(post_summ(post, "^E[")["mean",]/1e6); xlim[1] = 0
junk = sapply(1:4, function(j) {
  L_Pb_VS_E_per_WUL(j, xlim = xlim, ylim = ylim)
  if (j == 1) yaxis_label("Parr Mean Length", "mm")
}); xaxis_label("Total Egg Production (Millions)")

# overwinter survival vs. parr size
ylim = make_lim(post_summ(post, "^phi_Pa_Mb[")["mean",])
xlim = make_lim(post_summ(post, "^L_Pb[")["mean",])
junk = sapply(1:4, function(j) {
  phi_Pa_Mb_VS_L_Pb(j, 1, xlim = xlim, ylim = ylim)
  phi_Pa_Mb_VS_L_Pb(j, 2, xlim = xlim, ylim = ylim)
  if (j == 1) yaxis_label("Parr \u2192 Smolt Survival", "")
}); xaxis_label("Parr Mean Length (mm)")

# smolt size vs. parr size
xlim = make_lim(post_summ(post, "^L_Pb[")["mean",])
ylim = make_lim(post_summ(post, "^L_Mb[")["mean",])
junk = sapply(1:4, function(j) {
  L_Mb_VS_L_Pb(j, xlim = xlim, ylim = ylim)
  if (j == 1) yaxis_label("Smolt Mean Length", "mm")
}); xaxis_label("Parr Mean Length (mm)")

# migration to LGR vs. smolt size
xlim = make_lim(post_summ(post, "^L_Mb[")["mean",])
ylim = make_lim(post_summ(post, sub_index("^phi_Mb_Ma[year,LH_type,origin,pop]", year = ".+", LH_type = "1", origin = 1, pop = ".")))

junk = sapply(1:4, function(j) {
  phi_Mb_Ma_VS_L_Mb(j, xlim = xlim, ylim = ylim)
  if (j == 1) yaxis_label("Smolt \u2192 LGR Survival", "")
}); xaxis_label("Smolt Mean Length (mm)")

```

\newpage

```{r beta-fig, fig.width = 3.4, fig.height = 3.4, fig.cap = msdown::prep_caption(beta_caption), time_it = TRUE, eval = params$beta_fig}
# extract posterior summaries of the capacity parameters
beta_ests = post_summ(post, "^beta[", probs = c(0.025, 0.1, 0.5, 0.9, 0.975))

# extract posterior samples of the slope parameter
beta_per = post_subset(post, "lambda", TRUE)

# create a sequence of WUL values to predict capacity at
wul_seq = seq(0, max(jags_data$wul) * 1.1, length = 30)

# obtain the regression line for each posterior sample
pred_beta = t(sapply(beta_per, function(slope) wul_seq * slope))

# summarize posterior of regression line
pred_beta_summ = apply(pred_beta, 2, function(x) c(mean = mean(x), quantile(x, c(0.025, 0.1, 0.5, 0.9, 0.975))))

# empty plot with correct labeling/dimensions
mypar(mfrow = c(1,1), col.axis = "black")
plot(1,1, type = "n", xlim = range(wul_seq),
     # ylim = c(0, max(beta_ests["97.5%",], pred_beta_summ["97.5%",])),
     ylim = c(0, 3000) * 1000,
     xlab = "",
     ylab = "", yaxt = "n")

# draw prettier y-axis
at_y = c(0, 1000, 2000, 3000) * 1000
axis(side = 2, at = at_y, labels = at_y/1000)
usr = par("usr"); xdiff = diff(usr[1:2]); ydiff = diff(usr[3:4])

# draw the regression uncertainty
polygon(x = c(wul_seq, rev(wul_seq)), y = c(pred_beta_summ["2.5%",], rev(pred_beta_summ["97.5%",])), border = NA, col = tranp_col)
polygon(x = c(wul_seq, rev(wul_seq)), y = c(pred_beta_summ["10%",], rev(pred_beta_summ["90%",])), border = NA, col = tranp_col)

# draw the posterior mean regression line
lines(pred_beta_summ["mean",] ~ wul_seq, lwd = 2, lty = 2, col = solid_col2)

# draw the population-specific capacity estimates w/error bars and labels
segments(jags_data$wul, beta_ests["2.5%",], jags_data$wul, beta_ests["97.5%",], col = solid_col2)
segments(jags_data$wul, beta_ests["10%",], jags_data$wul, beta_ests["90%",], col = solid_col2, lwd = 3)
points(beta_ests["mean",] ~ jags_data$wul, cex = 1.5, pch = 21, col = solid_col2, bg = solid_col2)

# draw the population labels
xoff = 0.015
yoff = 0.03
text(x = jags_data$wul      + xdiff * c(1.5,-1,1,1) * xoff,
     y = beta_ests["mean",] + ydiff * c(1,-1,1,1) * yoff,
     labels = c("CAT", "LOS", "MIN", "UGR"), pos = c(2,4,2,2), font = 1, cex = 0.8)

# add axis labels
axis_labels("Weighted Usable Habitat Length (km)", "Parr Capacity (Thousands)")
```

\newpage

```{r corr-compare-fig, fig.width = 3.4, fig.height = 3.4, fig.cap = msdown::prep_caption(corr_compare_caption), eval = params$corr_compare_fig, time_it = TRUE}

# get posterior summaries of the mean correlation across all pop pairs
# for each process separately
rho_params1 = match_params(post, "rho", type = "base_only")
rho_params2 = match_params(post, "rho_.+_pr", type = "base_only")
rho_params = rho_params1[!(rho_params1 %in% rho_params2)]

# function to extract posterior summaries of the rho parameters for a given process
f = function(p) {
  x = rowMeans(post_subset(post, paste0("^", p, "["), matrix = TRUE))
  c(mean = mean(x), sd = sd(x), quantile(x, c(0.025, 0.1, 0.25, 0.5, 0.75, 0.9, 0.975)))
}

# apply it and order
rho_mean_out = t(sapply(rho_params, f))
rho_mean_out = rho_mean_out[order(rho_mean_out[,"mean"]),]

# assign names to the different rho parameters
rho_labels = c(
  "rho_Lphi_E_Pb" = "Egg \u2192 Parr",
  "rho_Lphi_O0_O1" = "Ocean-0 \u2192 Ocean-1",
  "rho_Lpsi_O1" = "Pr(Mature Age-3)",
  "rho_Lpsi_O2" = "Pr(Mature Age-4)",
  "rho_lDelta_L_Pb_Mb" = "\u0394 Mean Length",
  "rho_Lphi_Mb_Ma" = "Smolt \u2192 LGR",
  "rho_lL_Pb" = "Mean Parr Length",
  "rho_Lphi_Pa_Mb" = "Parr \u2192 Smolt",
  "rho_Lphi_Rb_Ra" = "BON \u2192 LGR",
  "rho_Lpi" = "Pr(Fall Migrant)",
  "rho_Lphi_Ma_O0" = "LGR \u2192 BON"
)

# set up empty plotting region
mypar(mar = c(2.5,6,1,0.75), yaxs = "i", mfrow = c(1,1), oma = c(0,0,0,0), mgp = c(2,0.1,0), col.axis = "black", cex.axis = 0.75)
mp = barplot(rho_mean_out[,"mean"], 
             horiz = TRUE, xlim = c(-1,1),
             names.arg = rho_labels[rownames(rho_mean_out)],
             las = 1, col = "white", border = "white")
usr = par("usr")

box_upr = mp - rbind(diff(mp)/2, NA)
box_lwr = mp + rbind(diff(mp)/2, NA)
box_upr[nrow(box_upr),] = box_upr[nrow(box_upr)-1,] + diff(box_upr[1:2])
box_lwr[nrow(box_lwr),] = box_lwr[nrow(box_upr)-1,] + diff(box_lwr[1:2])

pop_rhos = function(param, at_mp) {
  
  # if the process is not one of the hydropower migration survival ones, do this
  # those processes are correlated across origins, because all populations share the same values each year
  if (!(param %in% c("rho_Lphi_Ma_O0", "rho_Lphi_Rb_Ra"))) {
    x = post_summ(post, paste0(param, vcov_inds), probs = c(0.1, 0.25, 0.75, 0.9))
    y = at_mp + runif(6, -0.3, 0.3)
    points(y ~ x["mean",], pch = 21, col = solid_col, bg = tranp_col)
  } 
}
abline(v = 0, lty = 1, lwd = 2, col = "grey")

junk = sapply(1:nrow(mp), function(i) pop_rhos(rownames(rho_mean_out)[i], mp[i,]))
segments(rho_mean_out[,"25%"], mp, rho_mean_out[,"75%"], mp, lwd = 5, col = "white")
segments(rho_mean_out[,"2.5%"], mp, rho_mean_out[,"97.5%"], mp, col = "white", lwd = 2)
points(mp ~ rho_mean_out[,"mean"], pch = 3, cex = 1, col = "white", lwd = 3)

segments(rho_mean_out[,"25%"], mp, rho_mean_out[,"75%"], mp, lwd = 4, col = "black")
segments(rho_mean_out[,"2.5%"], mp, rho_mean_out[,"97.5%"], mp, col = "black", lwd = 1)
points(mp ~ rho_mean_out[,"mean"], pch = 3, cex = 1, col = "black", lwd = 2)

abline(h = mp + rbind(diff(mp)/2, NA), xpd = FALSE, col = "grey", lty = 2)
# par(tcl = -7)
# axis(side = 2, at = mp + rbind(diff(mp)/2, NA), col = "grey", line = NA, labels = FALSE, lty = 2)
box(col = par("col.axis"))
axis_labels(xlab = "Process Noise Correlation", xline = 1.25, outer = FALSE)
```

\newpage

```{r WUL-change-fig, fig.width = 7.2, fig.height = 6, eval = params$WUL_change_fig, fig.cap = msdown::prep_caption(WUL_change_fig_caption), time_it = TRUE}

prep_samples = function(j) {
  
  # the parameters needed to calculate process model expected values
  the_params = c("alpha[pop]", "beta[pop]", "^lambda$",
                 "omega0[pop]", "omega1[pop]", "mu_pi[1,pop]",
                 "gamma0[1,pop]", "gamma1[1,pop]",
                 "gamma0[2,pop]", "gamma1[2,pop]",
                 "theta0[pop]", "theta1[pop]",
                 "tau0[pop]", "tau1[pop]"
  )
  
  # extract the posterior samples for all of these parameters for this population
  the_samps = post_subset(post, sub_index(the_params, pop = j), matrix = TRUE)
  
  # handle the names
  the_names = postpack:::drop_index(names(the_samps[1,]))
  the_names[which(the_names == "gamma0")] = paste0("gamma0", c("_fall", "_spring"))
  the_names[which(the_names == "gamma1")] = paste0("gamma1", c("_fall", "_spring"))
  colnames(the_samps) = the_names
  
  return(the_samps)
}

prep_sample = function(the_samps, i, j) {
  c(the_samps[i,],
    WUL = unname(jags_data$wul[j]),
    E_scale = unname(jags_data$E_scale),
    L_Pb_scale = unname(jags_data$L_Pb_scale[j]),
    L_Pb_center = unname(jags_data$L_Pb_center[j]),
    L_Mb_scale = unname(jags_data$L_Mb_scale[j]),
    L_Mb_center = unname(jags_data$L_Mb_center[j])
  )
}

get_phi_hat = function(x, E, WUL_change = 0, start = "E", out_type = "phi") {
  with(as.list(c(x, E = E, WUL_change = WUL_change)), {
    beta_hat = lambda * WUL
    
    WUL_new = WUL * (1 + WUL_change)
    beta_hat_new = lambda * WUL_new
    beta_new = beta_hat_new * (beta/beta_hat)
    
    phi_E_Pb = 1/(1/alpha + E/beta_new)
    Pb = E * phi_E_Pb
    
    L_Pb = exp(omega0 + omega1 * log((E/E_scale)/WUL_new))
    L_Pb_star = (L_Pb - L_Pb_center)/L_Pb_scale
    
    Pa_fall = Pb * mu_pi
    Pa_spring = Pb * (1 - mu_pi)
    
    phi_Pa_Mb_fall = plogis(gamma0_fall + gamma1_fall * L_Pb_star)
    phi_Pa_Mb_spring = plogis(gamma0_spring + gamma1_spring * L_Pb_star)
    
    Mb_fall = Pa_fall * phi_Pa_Mb_fall
    Mb_spring = Pa_spring * phi_Pa_Mb_spring
    
    Delta = exp(theta0 + theta1 * L_Pb_star)
    
    L_Mb = L_Pb * Delta
    L_Mb_star = (L_Mb - L_Mb_center)/L_Mb_scale
    
    phi_Mb_Ma = plogis(tau0 + tau1 * L_Mb_star)
    
    Ma_fall = Mb_fall * phi_Mb_Ma
    Ma_spring = Mb_spring * phi_Mb_Ma
    Ma = Ma_fall + Ma_spring
    
    if (start == "E") out = Ma/E
    if (start == "Pb") out = Pb/E
    
    if (out_type == "phi") return(out)
    if (out_type == "Ma") return(Ma)
  })
}

get_phi_hat_post = function(j, E_pred, WUL_change = 0, start = "E", out_type = "phi") {
  
  the_samps = prep_samples(j = j)
  
  out = sapply(1:nrow(the_samps), function(i) {
    x = prep_sample(the_samps, i = i, j = j)
    sapply(E_pred, function(e) get_phi_hat(x, E = e, WUL_change = WUL_change, start = start, out_type = out_type))
  })
  
  out = t(out)
  colnames(out) = paste0("var", 1:ncol(out))
  
  postpack::post_convert(cbind(postpack:::id_mat(post), out))
}

get_phi_real_post = function(j, start = "E") {
  
  if (start == "E") start_param = "^E[.+,pop]"
  if (start == "Pb") start_param = "^Pb[.+,pop]"
  
  Ma_fall = post_subset(post, sub_index("^Ma[.+,1,1,pop]", pop = j), matrix = TRUE)
  Ma_spring = post_subset(post, sub_index("^Ma[.+,2,1,pop]", pop = j), matrix = TRUE)
  start_out = post_subset(post, sub_index(start_param, pop = j), matrix = TRUE)
  
  phi = (Ma_fall + Ma_spring)/start_out
  
  colnames(phi) = paste0("var", 1:ncol(phi))
  postpack::post_convert(cbind(postpack:::id_mat(post), phi))
}

plot_f = function(j, start, out_type) {
  
  WUL_changes = c(0.5, 1, 2)
  lwd = 1.5
  
  eps = mean(post_summ(post, sub_index("E_per_Sa[year,pop]", year = ".+", pop = j))["mean",])
  phi_real_post = get_phi_real_post(j = j, start = start)
  phi_real = post_summ(phi_real_post, ".")
  E_real = post_summ(post, sub_index("^E[.+,pop]", pop = j))
  # E_pred = seq(min(E_real["mean",]), max(E_real["mean",]), length = 30)
  E_pred = seq(eps * 100, max(E_real["mean",]), length = 30)
  keep_yrs = stringr::str_extract(colnames(E_real), "[:digit:]+,") |> 
    stringr::str_remove(",")
  
  S_pred = E_pred/eps
  S_real = post_summ(post, sub_index("^Sa_tot[year,pop]", year = keep_yrs, pop = j))
  
  phi_hat_post = get_phi_hat_post(j = j, E_pred, start = start, out_type = out_type)
  phi_hat = post_summ(phi_hat_post, ".")
  
  phi_hat_new1_post = get_phi_hat_post(j = j, E_pred, WUL_change = WUL_changes[1], start = start, out_type = out_type)
  phi_hat_new1 = post_summ(phi_hat_new1_post, ".")
  phi_hat_new2_post = get_phi_hat_post(j = j, E_pred, WUL_change = WUL_changes[2], start = start, out_type = out_type)
  phi_hat_new2 = post_summ(phi_hat_new2_post, ".")
  phi_hat_new3_post = get_phi_hat_post(j = j, E_pred, WUL_change = WUL_changes[3], start = start, out_type = out_type)
  phi_hat_new3 = post_summ(phi_hat_new3_post, ".")
  
  plot(phi_real["mean",] ~ S_real["mean",], type = "n",
       ylim = make_lim(0, phi_hat[c("2.5%","97.5%"),], phi_hat_new3["mean",]),
       # phi_real["mean",]),
       # ylim = make_lim(0, ifelse(start == "E", 0.075, 0.3)),
       xlim = c(0, max(S_real["mean",], S_pred)),
       xaxt = "n", yaxt = "n")
  
  # points(phi_real["mean",] ~ S_real["mean",], pch = 21,
  #        col = "black", bg = scales::alpha("grey25", 0.25), cex = 0.8)
  
  polygon(x = c(S_pred, rev(S_pred)), 
          y = c(phi_hat["2.5%",], rev(phi_hat["97.5%",])),
          col = tranp_col, border = NA)
  
  lines(phi_hat["mean",] ~ S_pred, lwd = lwd)
  lines(phi_hat_new1["mean",] ~ S_pred, lty = 3, lwd = lwd)
  lines(phi_hat_new2["mean",] ~ S_pred, lty = 2, lwd = lwd)
  lines(phi_hat_new3["mean",] ~ S_pred, lty = 5, lwd = lwd)
  
  at_x = axisTicks(par("usr")[1:2], log = FALSE)
  axis(side = 1, at = at_x, labels = at_x/1000)
  
  at_y = axisTicks(par("usr")[3:4], log = FALSE)
  axis(side = 2, at = at_y, labels = at_y/ifelse(out_type == "Ma", 1000, 1))
  
  base = ifelse(start == "E", 0, 4)
  base = ifelse(out_type == "Ma", 8, base)
  panel_label(paste0("(", letters[base + j], ") "))
  
  if (j == 1) {
    if (start == "E" & out_type == "phi") {
      axis_labels(ylab = "Egg \u2192 LGR Survival", outer = FALSE, yline = 2)
      legend("topright", title = "Weighted Habitat", legend = c("Current", paste0("\u2191", WUL_changes * 100, "%")), lty = c(1,3,2,5), seg.len = 2.7, bty = "n", lwd = lwd, cex = 0.9)
    } 
    if (start == "Pb" & out_type == "phi") axis_labels(ylab = "Parr \u2192 LGR Survival", outer = FALSE, yline = 2)
    if (out_type == "Ma") {
      axis_labels(ylab = "LGR Smolt", outer = FALSE, yline = 2)
      axis_labels(ylab = "Thousands", outer = FALSE, yline = 1, cex = 0.8, font = 3)
    } 
  }
  
  if (start == "E" & out_type == "phi") {
    mtext(side = 3, line = 0.15, font = 2, text = pops[j], cex = 1)
  }
}

mypar(mfrow = c(3,4), oma = c(2.5,2.5,1,0), col.axis = "black")
junk = sapply(1:4, function(j) plot_f(j, "E", "phi"))
junk = sapply(1:4, function(j) plot_f(j, "Pb", "phi"))
junk = sapply(1:4, function(j) plot_f(j, "Pb", "Ma"))
axis_labels(xlab = "Spawner Abundance")
axis_labels(xlab = "Thousands", outer = TRUE, xline = 1.5, cex = 0.8, font = 3)
```

\newpage

```{r no-fall-analysis, time_it = TRUE, eval = params$no_fall_fig | params$no_fall_tab}
cv = function(x) {sd(x, na.rm = TRUE)/mean(x, na.rm = TRUE)}

##### STEP 1: EXTRACT POSTERIOR SAMPLES OF QUANTITIES NEEDED #####

# total parr recruitment (regardless of LH type)
Pb = post_subset(post, "^Pb[", matrix = TRUE)

# total smolt at LGR (separated by LH type)
Ma = post_subset(post, "^Ma[", matrix = TRUE)

# overwinter survival (separated by LH type)
phi_Pa_Mb = post_subset(post, "^phi_Pa_Mb[", matrix = TRUE)

# migration survival (separated by LH type, but assumed constant)
phi_Mb_Ma = post_subset(post, "^phi_Mb_Ma[", matrix = TRUE)

##### STEP 2: DEFINE A FUNCTION TO CALCULATE THE DESIRED STATS FOR A GIVEN POSTERIOR SAMPLE #####
f = function(i) {
  # put the values from this draw into the format used in the model
  Pb_i = array_format(Pb[i,])
  Ma_i = array_format(Ma[i,])
  phi_Pa_Mb_i = array_format(phi_Pa_Mb[i,])[,i_spring,]
  phi_Mb_Ma_i = array_format(phi_Mb_Ma[i,])[,i_spring,o_nor,]
  
  # calculate hypothetical NOR smolt reaching LGR if all parr were spring migrants
  Ma_tot_hyp_i = Pb_i * phi_Pa_Mb_i * phi_Mb_Ma_i
  
  # calculate actual NOR smolt reaching LGR
  Ma_tot_real_i = Ma_i[,i_fall,o_nor,] + Ma_i[,i_spring,o_nor,]
  
  # add columns storing the aggregate across populations
  Ma_tot_hyp_i = cbind(Ma_tot_hyp_i, rowSums(Ma_tot_hyp_i))
  Ma_tot_real_i = cbind(Ma_tot_real_i, rowSums(Ma_tot_real_i))
  
  # calculate the ratios between the actual and hypothetical
  mean_p_ratio_i = colMeans(Ma_tot_hyp_i/Ma_tot_real_i, na.rm = TRUE)
  cv_ratio_i = apply(Ma_tot_hyp_i, 2, cv)/apply(Ma_tot_real_i, 2, cv)
  
  # calculate interannual cv by population and scenario
  Ma_cv_hyp_i = apply(Ma_tot_hyp_i, 2, cv)
  Ma_cv_real_i = apply(Ma_tot_real_i, 2, cv)
  
  # calculate interannual mean by population and scenario
  Ma_mean_hyp_i = colMeans(Ma_tot_hyp_i, na.rm = TRUE)
  Ma_mean_real_i = colMeans(Ma_tot_real_i, na.rm = TRUE)
  
  # calculate percent changes
  Ma_mean_change_i = (Ma_mean_hyp_i - Ma_mean_real_i)/Ma_mean_real_i
  Ma_cv_change_i = (Ma_cv_hyp_i - Ma_cv_real_i)/Ma_cv_real_i
  
  # add names
  names(Ma_mean_hyp_i) = paste0("Ma_mean_hyp[", 1:5, "]")
  names(Ma_mean_real_i) = paste0("Ma_mean_real[", 1:5, "]")
  names(Ma_cv_hyp_i) = paste0("Ma_cv_hyp[", 1:5, "]")
  names(Ma_cv_real_i) = paste0("Ma_cv_real[", 1:5, "]")
  names(Ma_mean_change_i) = paste0("Ma_mean_change[", 1:5, "]")
  names(Ma_cv_change_i) = paste0("Ma_cv_change[", 1:5, "]")
  
  names(mean_p_ratio_i) = paste0("mean_p_ratio[", 1:5, "]")
  names(cv_ratio_i) = paste0("cv_ratio[", 1:5, "]")
  c(mean_p_ratio_i, cv_ratio_i, Ma_mean_hyp_i, Ma_mean_real_i, Ma_cv_hyp_i, Ma_cv_real_i, Ma_mean_change_i, Ma_cv_change_i)
}

# apply to each posterior sample
out = t(sapply(1:nrow(Pb), f))
out = post_convert(cbind(postpack:::id_mat(post), out))

```

```{r no-fall-fig, fig.width = 3.4, fig.height = 3.4, fig.cap = msdown::prep_caption(no_fall_fig_caption), eval = params$no_fall_fig}
# summarize
mean_summ = post_summ(out, "mean_p_ratio")
cv_summ = post_summ(out, "cv_ratio")

# format the summaries for barplotting
mns = rbind(mean_summ["mean",], cv_summ["mean",])
lwrs = rbind(mean_summ["2.5%",], cv_summ["2.5%",])
uprs = rbind(mean_summ["97.5%",], cv_summ["97.5%",])

# set the colors
cols = c("grey50", "grey80")

# make the plot
mypar(mfrow = c(1,1), col.axis = "black")
mp = barplot(mns, beside = TRUE, names.arg = c(pops, "TOTAL"),
             ylim = c(0, 1.35), border = NA, col = cols)

# draw error bars
segments(mp, lwrs, mp, uprs)

# draw x-axis
segments(par("usr")[1], par("usr")[3], par("usr")[2], par("usr")[3], xpd = TRUE, col = par("col.axis"))
axis_labels("Population", "Without:With Fall Migrant Strategy")

# draw a reference line
abline(h = 1, lty = 2)

# draw a legend
legend("topright", title = "LGR Smolt", legend = c("Mean", "CV"), pch = 15,
       col = cols, pt.cex = 1.5, bty = "n", text.col = par("col.axis"), cex = 0.8)
```

`r ifelse(params$no_fall_fig & params$no_fall_tab, "_**Alternatively**, as a table, showing the actual numbers and a percent change, rather than as ratios._", "")`

```{r no-fall-tab, eval = params$no_fall_tab}
f = function(x, is_percent) {
  g = function(x, is_percent) {
    if (!is_percent) {
      prettyNum(round(x, 1), big.mark = ",", scientific = FALSE)
    } else {
      paste0(round(x, 2) * 100, "\\%")
    }
  }
  paste0(g(x["mean",], is_percent), " (", g(x["sd",], is_percent), ")")
}

tab = cbind(
  pop = c("CAT", "LOS", "MIN", "UGR", "Total"),
  f(post_summ(out, "Ma_mean_real")/1000, FALSE),
  f(post_summ(out, "Ma_mean_hyp")/1000, FALSE),
  f(post_summ(out, "Ma_mean_change"), TRUE),
  f(post_summ(out, "Ma_cv_real"), TRUE),
  f(post_summ(out, "Ma_cv_hyp"), TRUE)
)

kbl(tab, "latex", booktabs = TRUE, 
    col.names = c(
      " ", "Real\\textsuperscript{1,3}", "All Spring\\textsuperscript{2,3}", "\\%$\\Delta$",
      "Real\\textsuperscript{1}", "All Spring\\textsuperscript{2}"), escape = FALSE,
    caption = msdown::prep_caption(no_fall_table_caption)) |>
  kable_styling(full_width = FALSE, latex_options = "HOLD") |>
  add_header_above(c(" " = 1, "Inter-Annual Mean" = 3, "Inter-Annual \\\\%CV" = 2), bold = TRUE, escape = FALSE) |>
  column_spec(1, bold = TRUE) |>
  row_spec(0, bold = TRUE) |>
  footnote(general_title = "",
           general = c(
             "\\\\textit{Posterior summaries represented as mean (standard deviation).}"
           ),
           number =  c(
             "Based on the observed time series, in which both spring and fall migrants were present.",
             "Based on the hypothetical case where no parr recruits were fall migrants -- calculated after model fitting by assuming all parr recruits experience the higher mortality rates of the spring migrant life history type.",
             "Abundance expressed as thousands of natural-origin smolt reaching Lower Granite Dam."
           ), threeparttable = TRUE, escape = FALSE)

```

\newpage

```{r time-table, eval = params$time_table}
# calculate times elapsed for each chunk
tab = data.frame(
  Item = names(start_times),
  Minutes = round(sapply(1:length(start_times), function(i) lubridate::int_length(lubridate::int_diff(c(start_times[[i]], end_times[[i]])))/60), 1)
)

# add a total time elapsed
tab = rbind(tab, data.frame(Item = "Total", "Minutes" = sum(tab$Minutes)))

# create the table
kbl(tab, format = "latex", booktabs = TRUE, longtable = FALSE, linesep = "", caption = "Time elapsed in calculating the content in this document.") |> 
  kable_styling(full_width = FALSE, latex_options = "HOLD_position") |> 
  row_spec(0, bold = TRUE) |> 
  column_spec(1, monospace = TRUE) |> 
  row_spec(nrow(tab), bold = TRUE)
```
