---
output: 
  pdf_document:
    keep_tex: true
params:
  scenario:
    label: "Scenario"
    value: "base_vlong"
    input: text
  thin_percent:
    label: "Proportion of Posterior Samples to Retain?"
    value: 1
    input: numeric
  beta_fig:
    value: TRUE
  relationship_fig:
    value: TRUE
  no_fall_fig:
    value: TRUE
  surv_compare_fig:
    value: TRUE
  apportion_compare_fig:
    value: TRUE
  corr_compare_fig:
    value: TRUE
header-includes:
  - \usepackage{sansmathfonts}
  - \usepackage{helvet}
  - \renewcommand{\rmdefault}{\sfdefault}
  - \usepackage{float}
  - \usepackage[labelfont={bf,sc},labelsep=period]{caption}
  - \captionsetup{width=\textwidth}
editor_options: 
  chunk_output_type: console
---

\rule{\textwidth}{1pt}

\vspace{-6pt}

::: {.Huge data-latex=""}
**Potential Manuscript Content**
:::

\vspace{-6pt}

::: {.Large data-latex=""}
**GR-sslcm**
:::

\vspace{-6pt}

::: {.normalsize data-latex=""}
**Scenario:** ``r params$scenario``  
**Kept MCMC Iterations:** `r paste0(params$thin_percent * 100, "\\%")`
:::

\vspace{-6pt}

\rule{\textwidth}{1pt}

\listoftables

\listoffigures

\pagenumbering{gobble}
\newpage
\pagenumbering{arabic}

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, fig.align = "center", fig.pos = "H")
knitr::opts_knit$set(root.dir = "C:/Users/bstaton/Desktop/Staton/1_critfc/analyses/GR-sslcm/03-post-process")

# set up a chunk hook to calculate how long chunks took to run
# modified from https://bookdown.org/yihui/rmarkdown-cookbook/time-chunk.html#time-chunk

start_times = list()  # store the time for each chunk
end_times = list()  # store the time for each chunk
knitr::knit_hooks$set(time_it = local({
  function(before, options) {
    if (before) {
      start_times[[options$label]] <<- lubridate::now()
    } else {
      end_times[[options$label]] <<- lubridate::now()
    }
  }
}))
```

```{r load-post, time_it = TRUE}
source("C:/Users/bstaton/Desktop/source_rmd_chunk.R")
rmd_file = "C:/Users/bstaton/Desktop/Staton/1_critfc/analyses/GR-sslcm/03-post-process/output-plots.Rmd"
source_rmd_chunk(rmd_file, "setup")
source_rmd_chunk(rmd_file, "dimension-ids")
knitr::opts_chunk$set(out.width = "100%", dev = "cairo_pdf")
```

```{r load-packages}
source("../00-packages.R")
```

```{r plot-settings}
solid_col = "grey30"
tranp_col = alpha(solid_col, 0.25)
pt_cex = 1.3
```

```{r captions}
beta_caption = "
  Estimated relationship between parr capacity and weighted usable habitat length.
  Darker grey/thicker error bars represent 80% credible regions and lighter grey/thinner error bars represent 95% credible regions.
"

relationship_caption = "
  Estimated relationships showing density effects on recruitment (panels _a_ and _b_) and mean length (panel _c_), and length effects on future length (panel _d_) and survival (panels _e_ and _f_). 
  Process model relationships are shown as the posterior mean (thick line) and 95% credible region (shaded); points show process model realizations (i.e., with process noise) by brood year.
  Panels within the same row show the process model relationship for each of the four populations; _x_- and _y_-axis limits are identical for all panels within a row.
"

no_fall_caption = "
  Ratios between the across-year mean (dark grey) and coefficient of variation (light grey) abundance of natural-origin smolt reaching Lower Granite Dam with (denominator) and without (numerator) the fall migrant life history strategy.
  The 'without' scenario was calculated by assuming all parr recruits experienced freshwater survival rates of spring migrants.
  Mean ratios <1 and CV ratios >1 indicate LGR smolt abundance would be lower and more variable, respectively, in the absence of the fall migrant strategy.
  Values presented are posterior means and 95% credible regions.
"

surv_compare_caption = "
  Survival probability parameters estimated by the state-space model, separated by stage transition and other demographic features (migratory type, origin, population) where applicable.
  Small points show posterior means of year-specific realized values (jitter for visual effect only) and large points show the average across years.
  Information about mortality due to sources/stages not displayed here was either assumed known without error (e.g., prespawn mortality) or expressed as strong prior information with no inter-annual variability (i.e., mortality experienced in ocean-1 $\\to$ ocean-2 and ocean-2 $\\to$ ocean-3).
"

apportion_compare_caption = "
  Transition probability parameters (unrelated to survival) estimated by the state-space model, separated by life stage and origin where applicable.
  Small points show posterior means of year-specific realized values (jitter for visual effect only) and large points show the average across years.
"

corr_compare_caption = "
  Correlation terms of the covariance matrices controlling process variability.
  Posterior means of population pair-specific correlations are displayed as points, and the posterior of the average of the 6 pairs is summarized in black (thin lines are 95% CRIs, thick lines 50% CRIs, and cross marks are means).
  Survival processes are denoted by $x \\to y$, where as transition processes are denoted by $\\Pr(x)$.
  The correlation in survival processes representing the migration downstream and upstream through the mainstem (LGR $\\to$ BON and BON $\\to$ LGR, respectively) represent among-origin correlation, hence the lack of points.
"
```

```{r beta-fig, fig.width = 3.4, fig.height = 3.4, fig.cap = msdown::prep_caption(beta_caption), time_it = TRUE, eval = params$beta_fig}
# extract posterior summaries of the capacity parameters
beta_ests = post_summ(post, "^beta[", probs = c(0.025, 0.1, 0.5, 0.9, 0.975))

# extract posterior samples of the slope parameter
beta_per = post_subset(post, "lambda", TRUE)

# create a sequence of WUL values to predict capacity at
wul_seq = seq(0, max(jags_data$wul) * 1.1, length = 30)

# obtain the regression line for each posterior sample
pred_beta = t(sapply(beta_per, function(slope) wul_seq * slope))

# summarize posterior of regression line
pred_beta_summ = apply(pred_beta, 2, function(x) c(mean = mean(x), quantile(x, c(0.025, 0.1, 0.5, 0.9, 0.975))))

# empty plot with correct labeling/dimensions
mypar(mfrow = c(1,1), col.axis = "black")
plot(1,1, type = "n", xlim = range(wul_seq),
     # ylim = c(0, max(beta_ests["97.5%",], pred_beta_summ["97.5%",])),
     ylim = c(0, 3000) * 1000,
     xlab = "",
     ylab = "", yaxt = "n")

# draw prettier y-axis
at_y = c(0, 1000, 2000, 3000) * 1000
axis(side = 2, at = at_y, labels = at_y/1000)
usr = par("usr"); xdiff = diff(usr[1:2]); ydiff = diff(usr[3:4])

# draw the regression uncertainty
polygon(x = c(wul_seq, rev(wul_seq)), y = c(pred_beta_summ["2.5%",], rev(pred_beta_summ["97.5%",])), border = NA, col = tranp_col)
polygon(x = c(wul_seq, rev(wul_seq)), y = c(pred_beta_summ["10%",], rev(pred_beta_summ["90%",])), border = NA, col = tranp_col)

# draw the posterior mean regression line
lines(pred_beta_summ["mean",] ~ wul_seq, lwd = 2, lty = 2, col = solid_col)

# draw the population-specific capacity estimates w/error bars and labels
segments(jags_data$wul, beta_ests["2.5%",], jags_data$wul, beta_ests["97.5%",], col = solid_col)
segments(jags_data$wul, beta_ests["10%",], jags_data$wul, beta_ests["90%",], col = solid_col, lwd = 3)
points(beta_ests["mean",] ~ jags_data$wul, cex = 1.5, pch = 21, col = solid_col, bg = solid_col)

# draw the population labels
xoff = 0.015
yoff = 0.03
text(x = jags_data$wul      + xdiff * c(1.5,-1,1,1) * xoff,
     y = beta_ests["mean",] + ydiff * c(1,-1,1,1) * yoff,
     labels = c("CAT", "LOS", "MIN", "UGR"), pos = c(2,4,2,2), font = 1, cex = 0.8)

# add axis labels
axis_labels("Weighted Usable Habitat Length (km)", "Parr Capacity (Thousands)")
```

\newpage

```{r relationship-fig, fig.width = 7.2, fig.height = 9, fig.cap = msdown::prep_caption(relationship_caption), time_it = TRUE, eval = params$relationship_fig}
solid_col = "grey30"
tranp_col = alpha(solid_col, 0.25)
pt_cex = 1.3

##### EGG-TO-PARR SURVIVAL VS. EGG DENSITY #####

phi_E_Pa_VS_E_per_WUL = function(j, xlim = NULL, ylim = NULL) {
  
  # extract posterior summaries of total egg production by brood year
  E = post_summ(post, sub_index("^E[.+,pop]", pop = j))
  
  # extract posterior summaries of egg to parr survival rates
  phi_E_Pb = post_summ(post, sub_index("^phi_E_Pb[.+,pop]", pop = j))
  
  # extract posterior samples of the BH parameters
  bh_params = post_subset(post, sub_index(c("alpha[pop]", "^beta[pop]$"), pop = j), matrix = TRUE)
  
  # construct vector of egg abundances to predict at
  E_pred = seq(0.1, max(E[1,]), length = 30)
  
  # obtain predicted curves for each posterior sample
  phi_E_Pb_pred = t(sapply(1:post_dim(post, "saved"), function(i) 1/((1/bh_params[i,1]) + E_pred/bh_params[i,2])))
  
  # obtain posterior summary of predicted curve
  colnames(phi_E_Pb_pred) = paste0("phi_E_Pb_pred[", 1:length(E_pred), "]")
  phi_E_Pb_pred = post_convert(cbind(postpack:::id_mat(post), phi_E_Pb_pred))
  phi_E_Pb_pred = post_summ(phi_E_Pb_pred, "phi_E_Pb_pred")
  
  # set xaxis limits
  if (is.null(xlim)) xlim = c(0, max(E[1,]))
  
  # set yaxis limits
  if (is.null(ylim)) ylim = range(0, phi_E_Pb["mean",], phi_E_Pb_pred["2.5%",], phi_E_Pb_pred["97.5%",])
  
  # empty plot with correct dimensions
  plot(phi_E_Pb["mean",] ~ E["mean",],
       ylim = ylim,
       xlim = xlim, type = "n",
       xaxt = "n")
  
  # panel label
  panel_label(paste0("(", paste0("a", j), ")"), "topright", y_inp = 0.075)
  
  # draw prettier x-axis
  x_ticks = axisTicks(par("usr")[1:2], log = F)
  axis(side = 1, at = x_ticks, labels = x_ticks/1e6)
  
  # add credible region for predicted curve
  polygon(c(E_pred, rev(E_pred)), c(phi_E_Pb_pred["2.5%",], rev(phi_E_Pb_pred["97.5%",])), col = tranp_col, border = NA)
  
  # add posterior mean predicted curve
  lines(phi_E_Pb_pred["mean",] ~ E_pred, lwd = 2, col = solid_col)
  
  # add posterior mean of realized pairs
  points(phi_E_Pb["mean",] ~ E["mean",], pch = 21, col = solid_col, bg = tranp_col, cex = pt_cex)
  
  # draw boundary box
  box()
}

##### PARR RECRUITMENT VS. EGG PRODUCTION #####

Pb_VS_E = function(j, xlim = NULL, ylim = NULL) {
  
  # extract posterior summaries of total egg production by brood year
  E = post_summ(post, sub_index("^E[.+,pop]", pop = j))
  
  # extract posterior summaries of total parr production by brood year
  Pb = post_summ(post, sub_index("^Pb[.+,pop]", pop = j))
  
  # extract posterior samples of the BH parameters
  bh_params = post_subset(post, sub_index(c("alpha[pop]", "^beta[pop]$"), pop = j), matrix = TRUE)
  
  # construct vector of egg abundances to predict at
  E_pred = seq(0.1, max(E[1,]), length = 30)
  
  # obtain predicted curves for each posterior sample
  Pb_pred = t(sapply(1:post_dim(post, "saved"), function(i) E_pred/((1/bh_params[i,1]) + E_pred/bh_params[i,2])))
  
  # obtain posterior summary of predicted curve
  colnames(Pb_pred) = paste0("Pb_pred[", 1:length(E_pred), "]")
  Pb_pred = post_convert(cbind(postpack:::id_mat(post), Pb_pred))
  Pb_pred = post_summ(Pb_pred, "Pb_pred")
  
  # set xaxis limits
  if (is.null(xlim)) xlim = c(0, max(E[1,]))
  
  # set yaxis limit
  if (is.null(ylim)) ylim = c(0, max(Pb[1,]))
  
  # empty plot with correct dimensions
  plot(Pb["mean",] ~ E["mean",],
       ylim = ylim,
       xlim = xlim, type = "n",
       xaxt = "n",
       yaxt = "n")
  
  # panel label
  panel_label(paste0("(", paste0("b", j), ")"), "topright", y_inp = 0.075)
  
  # draw prettier x-axis
  x_ticks = axisTicks(par("usr")[1:2], log = F)
  axis(side = 1, at = x_ticks, labels = x_ticks/1e6)
  
  # draw prettier y-axis
  y_ticks = axisTicks(par("usr")[3:4], log = F)
  axis(side = 2, at = y_ticks, labels = y_ticks/1e3)
  
  # add credible region for predicted curve
  polygon(c(E_pred, rev(E_pred)), c(Pb_pred["2.5%",], rev(Pb_pred["97.5%",])), col = tranp_col, border = NA)
  
  # add posterior mean predicted curve
  lines(Pb_pred["mean",] ~ E_pred, lwd = 2, col = solid_col)
  
  # add posterior mean of realized pairs
  points(Pb["mean",] ~ E["mean",], pch = 21, col = solid_col, bg = tranp_col, cex = pt_cex)
  
  # draw boundary box
  box()
}

##### PARR SIZE VS. EGG DENSITY #####

L_Pb_VS_E_per_WUL = function(j, xlim = NULL, ylim = NULL) {
  # obtain posterior samples of total egg abundance scaled to WUL
  E = post_subset(post, sub_index("^E[.+,pop]", pop = j), matrix = TRUE)
  E_scaled = (E/jags_data$E_scale)/jags_data$wul[j]
  colnames(E_scaled) = gsub("E", "E_scaled", x = colnames(E_scaled))
  post_E = post_convert(cbind(postpack:::id_mat(post), E_scaled))
  
  # summarize scaled egg abundance
  E_scaled_mean = post_summ(post_E, "E_scaled")["mean",]
  
  # create a vector of scaled egg abundances to predict at
  E_scaled_seq = seq(min(E_scaled_mean), max(E_scaled_mean), length = 30)
  
  # extract posteriors of coefficients
  omega0 = post_subset(post, sub_index("omega0[pop]", pop = j), matrix = TRUE)
  omega1 = post_subset(post, sub_index("omega1[pop]", pop = j), matrix = TRUE)
  
  # extract posterior summaries of summer length outcomes
  L_Pb_mean = post_summ(post, sub_index("^L_Pb[.+,pop]", pop = j))["mean",]
  
  # function to create predicted survival curves for one posterior sample
  pred_fn = function(i) {
    pred_L_Pb = exp(omega0[i] + omega1[i] * log(E_scaled_seq))
    names(pred_L_Pb) = paste0("pred_L_Pb[", 1:30, "1]")
    pred_L_Pb
  }
  
  # calculate predicted length
  pred_L_Pb = t(sapply(1:post_dim(post, "saved"), pred_fn))
  post_pred_L_Pb = post_convert(cbind(postpack:::id_mat(post), pred_L_Pb))
  
  # extract summarized predicted length
  pred_L_Pb_mean = post_summ(post_pred_L_Pb, ".")["mean",]
  pred_L_Pb_lwr = post_summ(post_pred_L_Pb, ".")["2.5%",]
  pred_L_Pb_upr = post_summ(post_pred_L_Pb, ".")["97.5%",]
  
  E_scaled_seq = (E_scaled_seq * jags_data$wul[j] * jags_data$E_scale)/1e6
  E_scaled_mean = (E_scaled_mean * jags_data$wul[j] * jags_data$E_scale)/1e6
  
  # set xaxis limit
  if (is.null(xlim)) xlim = range(0, E_scaled_seq)
  
  # set yaxis limit
  if (is.null(ylim)) ylim = range(L_Pb_mean, pred_L_Pb_lwr, pred_L_Pb_upr, na.rm = TRUE)
  
  # empty plot with correct dimensions
  plot(1,1, type = "n", 
       ylim = ylim,
       xlim = xlim
  )
  
  # panel label
  panel_label(paste0("(", paste0("c", j), ")"), "topright", y_inp = 0.075)
  
  # add credible region for predicted curve
  polygon(c(E_scaled_seq, rev(E_scaled_seq)), c(pred_L_Pb_lwr, rev(pred_L_Pb_upr)), border = NA, col = tranp_col)
  
  # add posterior mean predicted curve
  lines(pred_L_Pb_mean ~ E_scaled_seq, col = solid_col, lwd = 2)
  
  # add posterior mean of realized pairs
  points(L_Pb_mean ~ E_scaled_mean, pch = 21, col = solid_col, bg = tranp_col, cex = pt_cex)
  
  # draw boundary box
  box()
}

##### OVERWINTER SURVIVAL VS. PARR SIZE #####

phi_Pa_Mb_VS_L_Pb = function(j, i, xlim = NULL, ylim = NULL) {
  
  pch = c(21, 23)
  lty = c(1, 2)
  
  # extract posterior summaries of summer length outcomes
  L_Pb_mean = post_summ(post, sub_index("^L_Pb[year,pop]", year = ".+", pop = j))["mean",]
  
  # obtain scaled/centered versions
  L_Pb_star_mean = (L_Pb_mean - jags_data$L_Pb_center[j])/jags_data$L_Pb_scale[j]
  
  # summarize posterior of overwinter survival outcomes
  phi_Pa_Mb_mean = array_format(post_summ(post, sub_index("^phi_Pa_Mb[.+,LH_type,pop]", pop = j, LH_type = i))["mean",])[-1,i,j]
  
  # create vector of lengths to predict at
  L_Pb_seq = seq(min(L_Pb_mean), max(L_Pb_mean), length = 30)
  L_Pb_star_seq = seq(min(L_Pb_star_mean), max(L_Pb_star_mean), length = 30)
  
  # extract posteriors of coefficients
  gamma0 = post_subset(post, sub_index("gamma0[LH_type,pop]", pop = j, LH_type = i), matrix = TRUE)
  gamma1 = post_subset(post, sub_index("gamma1[LH_type,pop]", pop = j, LH_type = i), matrix = TRUE)
  
  # function to create predicted survival curve for one posterior sample
  pred_fn = function(i) {
    pred_phi_Pa_Mb = plogis(gamma0[i] + gamma1[i] * L_Pb_star_seq)
    names(pred_phi_Pa_Mb) = paste0("pred_phi_Pa_Mb[", 1:30, "]")
    pred_phi_Pa_Mb
  }
  
  # calculate predicted survivals and add to posterior samples
  pred_phi_Pa_Mb = t(sapply(1:post_dim(post, "saved"), pred_fn))
  post_pred_phi_Pa_Mb = post_convert(cbind(postpack:::id_mat(post), pred_phi_Pa_Mb))
  
  # summarize predicted survival
  pred_phi_Pa_Mb_mean = post_summ(post_pred_phi_Pa_Mb, ".")["mean",]
  pred_phi_Pa_Mb_lwr = post_summ(post_pred_phi_Pa_Mb, ".")["2.5%",]
  pred_phi_Pa_Mb_upr = post_summ(post_pred_phi_Pa_Mb, ".")["97.5%",]
  
  # set xaxis limits
  if (is.null(xlim)) xlim = range(L_Pb_seq)
  
  # set yaxis limits
  if (is.null(ylim)) ylim = range(0, pred_phi_Pa_Mb_lwr, pred_phi_Pa_Mb_upr, phi_Pa_Mb_mean)
  
  # empty plot with correct dimensions
  if (i == 1) {
    plot(1,1, type = "n", 
         ylim = ylim,
         xlim = xlim,
         xlab = "", ylab = ""
    )
  }
  
  # panel label
  panel_label(paste0("(", paste0("d", j), ")"), "topright", y_inp = 0.075)
  
  # add credible region for predicted curve
  polygon(c(L_Pb_seq, rev(L_Pb_seq)), c(pred_phi_Pa_Mb_lwr, rev(pred_phi_Pa_Mb_upr)), border = NA, col = tranp_col)
  
  # add posterior mean predicted curve
  lines(pred_phi_Pa_Mb_mean ~ L_Pb_seq, col = solid_col, lwd = 2, lty = lty[i])
  
  # add posterior mean of realized pairs
  points(phi_Pa_Mb_mean ~ L_Pb_mean, pch = pch[i], col = solid_col, bg = tranp_col, cex = pt_cex)
  
  legend_pop = 2
  if (j == legend_pop & i == 1) {
    legend("topleft", legend = c("Fall", "Spring"), title = "Mig. Type", pch = pch, pt.bg = tranp_col, col = solid_col, pt.cex = pt_cex, cex = 0.8, bty = "n")
  }
  
  # draw boundary box
  box()
}


##### SMOLT SIZE VS PARR SIZE #####

L_Mb_VS_L_Pb = function(j, xlim = NULL, ylim = NULL) {
  
  # extract posterior summaries of summer length outcomes
  L_Pb_mean = post_summ(post, sub_index("^L_Pb[year,pop]", year = ".+", pop = j))["mean",]
  
  # extract posterior summaries of spring length outcomes
  L_Mb_mean = post_summ(post, sub_index("^L_Mb[year,pop]", year = ".+", pop = j))["mean",]
  
  # create a vector of scaled summer lengths to predict at
  L_Pb_seq = seq(min(L_Pb_mean), max(L_Pb_mean), length = 30)
  L_Pb_star_seq = (L_Pb_seq - jags_data$L_Pb_center[j])/jags_data$L_Pb_scale[j]
  
  # extract posteriors of coefficients
  theta0 = post_subset(post, sub_index("theta0[pop]", pop = j), matrix = TRUE)
  theta1 = post_subset(post, sub_index("theta1[pop]", pop = j), matrix = TRUE)
  
  # function to create predicted curves for one posterior sample
  pred_fn = function(i) {
    pred_L_Mb = exp(theta0[i] + theta1[i] * L_Pb_star_seq) * L_Pb_seq
    names(pred_L_Mb) = paste0("pred_L_Mb[", 1:30, "1]")
    pred_L_Mb
  }
  
  # calculate predicted growth values and add to posterior samples
  pred_L_Mb = t(sapply(1:post_dim(post, "saved"), pred_fn))
  post_pred_L_Mb = post_convert(cbind(postpack:::id_mat(post), pred_L_Mb))
  
  # summarize predicted growth
  pred_L_Mb_mean = post_summ(post_pred_L_Mb, ".")["mean",]
  pred_L_Mb_lwr = post_summ(post_pred_L_Mb, ".")["2.5%",]
  pred_L_Mb_upr = post_summ(post_pred_L_Mb, ".")["97.5%",]
  
  # set xaxis limits
  if (is.null(xlim)) xlim = range(L_Pb_seq)
  
  # set yaxis limits
  if (is.null(ylim)) ylim = range(pred_L_Mb_lwr, pred_L_Mb_upr, L_Mb_mean, na.rm = TRUE)
  
  # empty plot with the correct dimensions
  plot(1,1, type = "n", 
       ylim = ylim,
       xlim = xlim, 
       xlab = "", ylab = ""
  )
  
  # panel label
  panel_label(paste0("(", paste0("e", j), ")"), "topright", y_inp = 0.075)
  
  # add credible region for predicted curve
  polygon(c(L_Pb_seq, rev(L_Pb_seq)), c(pred_L_Mb_lwr, rev(pred_L_Mb_upr)), border = NA, col = tranp_col)
  
  # add posterior mean of predicted curve
  lines(pred_L_Mb_mean ~ L_Pb_seq, col = solid_col, lwd = 2)
  
  # add posterior mean of realized pairs
  points(L_Mb_mean ~ L_Pb_mean, pch = 21, col = solid_col, bg = tranp_col, cex = pt_cex)
  
  # draw boundary box
  box()
}

##### SURVIVAL TO LGR VS. SMOLT SIZE #####

phi_Mb_Ma_VS_L_Mb = function(j, xlim = NULL, ylim = NULL) {
  
  # extract posterior summaries of spring length outcomes
  L_Mb_mean = post_summ(post, sub_index("^L_Mb[year,pop]", year = ".+", pop = j))["mean",]
  
  # obtain scaled/centered versions
  L_Mb_star_mean = (L_Mb_mean - jags_data$L_Mb_center[j])/jags_data$L_Mb_scale[j]
  
  # summarize posterior of migration to LGR survival outcomes
  phi_Mb_Ma_mean = array_format(post_summ(post, sub_index("^phi_Mb_Ma[.+,LH_type,origin,pop]", pop = j, LH_type = 1, origin = 1))["mean",])[-1,1,1,j]
  
  # create vectors to predict survival at: for credible regions and mean curve
  L_Mb_seq = seq(min(L_Mb_mean), max(L_Mb_mean), length = 30)
  L_Mb_star_seq = seq(min(L_Mb_star_mean), max(L_Mb_star_mean), length = 30)
  
  # extract posteriors of coefficients
  tau0 = post_subset(post, sub_index("tau0[pop]", pop = j), matrix = TRUE)
  tau1 = post_subset(post, sub_index("tau1[pop]", pop = j), matrix = TRUE)
  
  # function to create predicted survival curve for one posterior sample
  pred_fn = function(i) {
    pred_phi_Mb_Ma = plogis(tau0[i] + tau1[i] * L_Mb_star_seq)
    names(pred_phi_Mb_Ma) = paste0("pred_phi_Mb_Ma[", 1:30, "]")
    pred_phi_Mb_Ma
  }
  
  # calculate predicted survivals for each posterior sample
  pred_phi_Mb_Ma = t(sapply(1:post_dim(post, "saved"), pred_fn))
  post_pred_phi_Mb_Ma = post_convert(cbind(postpack:::id_mat(post), pred_phi_Mb_Ma))
  
  # summarize predicted survival
  pred_phi_Mb_Ma_mean = post_summ(post_pred_phi_Mb_Ma, ".")["mean",]
  pred_phi_Mb_Ma_lwr = post_summ(post_pred_phi_Mb_Ma, ".")["2.5%",]
  pred_phi_Mb_Ma_upr = post_summ(post_pred_phi_Mb_Ma, ".")["97.5%",]
  
  # set xaxis limits
  if (is.null(xlim)) xlim = range(L_Mb_seq)
  
  # set yaxis limits
  if (is.null(ylim)) ylim = range(pred_phi_Mb_Ma_lwr, pred_phi_Mb_Ma_upr, phi_Mb_Ma_mean)
  
  # empty plot with correct dimensions
  plot(1,1, type = "n", 
       ylim = ylim,
       xlim = xlim,
       xlab = "", ylab = ""
  )
  
  # panel label
  panel_label(paste0("(", paste0("f", j), ")"), "topright", y_inp = 0.075)
  
  # add credible region for predicted curve
  polygon(c(L_Mb_seq, rev(L_Mb_seq)), c(pred_phi_Mb_Ma_lwr, rev(pred_phi_Mb_Ma_upr)), border = NA, col = tranp_col)
  
  # add posterior mean of predicted curve
  lines(pred_phi_Mb_Ma_mean ~ L_Mb_seq, col = solid_col, lwd = 2)
  
  # add posterior mean of realized pairs
  points(phi_Mb_Ma_mean ~ L_Mb_mean, pch = 21, col = solid_col, bg = tranp_col, cex = pt_cex)
}

##### LARGE MULTI-PANEL PLOT #####

make_layout = function(nrow, ncol, show = FALSE) {
  m = NULL
  for (r in 1:nrow) {
    if (r == 1) {
      f = 1
    } else {
      f = max(m) + 1
    }
    l = f+ncol-1
    tmp = rbind(f:l, rep(l+1, ncol))
    m = rbind(m, tmp)
  }
  layout(m, heights = rep(c(1, 0.25), nrow))
  if (show) layout.show(max(m))
}

g = function(ylim = c(-3,3), xlim = c(-3,3)) {
  x = rnorm(30)
  y = rnorm(30)
  plot(y ~ x, xlab = "", ylab = "", xlim = xlim, ylim = ylim)
}

yaxis_label = function(label_main, label_sub) {
  mtext(side = 2, outer = FALSE, label_main, line = 2.25, cex = 0.9)
  mtext(side = 2, outer = FALSE, label_sub, line = 1.25, cex = 0.75, font = 3)
}

xaxis_label = function(label) {
  plot(1, 1, type = "n", xlim = c(0,1), ylim = c(0,1), axes = FALSE)
  text(0.5, 0.3, label = label, cex = 1.25, xpd = TRUE)
}



make_layout(nrow = 6, ncol = 4, show = FALSE)

par(mar = c(0.5,1.5,0,0), oma = c(0,2,1.5,1), tcl = 0, mgp = c(200,0.05,0),
    lend = "square", ljoin = "mitre")

# egg to parr survival vs. egg density
# ylim = make_lim(post_summ(post, "^phi_E_Pb[")["mean",])
ylim = c(0,0.4)
xlim = make_lim(post_summ(post, "^E[")["mean",]); xlim[1] = 0
junk = sapply(1:4, function(j) {
  phi_E_Pa_VS_E_per_WUL(j, xlim = xlim, ylim = ylim)
  if (j == 1) yaxis_label("Egg \u2192 Parr Survival", "")
  mtext(side = 3, outer = FALSE, line = 0, pops[j], font = 2)
}); xaxis_label("Total Egg Production (Millions)")

# parr recruitment vs. total egg production
ylim = make_lim(post_summ(post, "^Pb[")["mean",]); ylim[1] = 0
xlim = make_lim(post_summ(post, "^E[")["mean",]); xlim[1] = 0
junk = sapply(1:4, function(j) {
  Pb_VS_E(j, xlim = xlim, ylim = ylim)
  if (j == 1) yaxis_label("Parr Recruitment", "Thousands")
}); xaxis_label("Total Egg Production (Millions)")

# parr size vs. egg production
ylim = make_lim(post_summ(post, "^L_Pb[")["mean",])
xlim = make_lim(post_summ(post, "^E[")["mean",]/1e6); xlim[1] = 0
junk = sapply(1:4, function(j) {
  L_Pb_VS_E_per_WUL(j, xlim = xlim, ylim = ylim)
  if (j == 1) yaxis_label("Parr Mean Length", "mm")
}); xaxis_label("Total Egg Production (Millions)")

# overwinter survival vs. parr size
ylim = make_lim(post_summ(post, "^phi_Pa_Mb[")["mean",])
xlim = make_lim(post_summ(post, "^L_Pb[")["mean",])
junk = sapply(1:4, function(j) {
  phi_Pa_Mb_VS_L_Pb(j, 1, xlim = xlim, ylim = ylim)
  phi_Pa_Mb_VS_L_Pb(j, 2, xlim = xlim, ylim = ylim)
  if (j == 1) yaxis_label("Parr \u2192 Smolt Survival", "")
}); xaxis_label("Parr Mean Length (mm)")

# smolt size vs. parr size
xlim = make_lim(post_summ(post, "^L_Pb[")["mean",])
ylim = make_lim(post_summ(post, "^L_Mb[")["mean",])
junk = sapply(1:4, function(j) {
  L_Mb_VS_L_Pb(j, xlim = xlim, ylim = ylim)
  if (j == 1) yaxis_label("Smolt Mean Length", "mm")
}); xaxis_label("Parr Mean Length (mm)")

# migration to LGR vs. smolt size
xlim = make_lim(post_summ(post, "^L_Mb[")["mean",])
ylim = make_lim(post_summ(post, sub_index("^phi_Mb_Ma[year,LH_type,origin,pop]", year = ".+", LH_type = "1", origin = 1, pop = ".")))

junk = sapply(1:4, function(j) {
  phi_Mb_Ma_VS_L_Mb(j, xlim = xlim, ylim = ylim)
  if (j == 1) yaxis_label("Smolt \u2192 LGR Survival", "")
}); xaxis_label("Smolt Mean Length (mm)")

```

\newpage

```{r no-fall-fig, fig.width = 3.4, fig.height = 3.4, fig.cap = msdown::prep_caption(no_fall_caption), time_it = TRUE, eval = params$no_fall_fig}
cv = function(x) {sd(x, na.rm = TRUE)/mean(x, na.rm = TRUE)}

##### STEP 1: EXTRACT POSTERIOR SAMPLES OF QUANTITIES NEEDED #####

# total parr recruitment (regardless of LH type)
Pb = post_subset(post, "^Pb[", matrix = TRUE)

# total smolt at LGR (separated by LH type)
Ma = post_subset(post, "^Ma[", matrix = TRUE)

# overwinter survival (separated by LH type)
phi_Pa_Mb = post_subset(post, "^phi_Pa_Mb[", matrix = TRUE)

# migration survival (separated by LH type, but assumed constant)
phi_Mb_Ma = post_subset(post, "^phi_Mb_Ma[", matrix = TRUE)

##### STEP 2: DEFINE A FUNCTION TO CALCULATE THE DESIRED STATS FOR A GIVEN POSTERIOR SAMPLE #####
f = function(i) {
  # put the values from this draw into the format used in the model
  Pb_i = array_format(Pb[i,])
  Ma_i = array_format(Ma[i,])
  phi_Pa_Mb_i = array_format(phi_Pa_Mb[i,])[,i_spring,]
  phi_Mb_Ma_i = array_format(phi_Mb_Ma[i,])[,i_spring,o_nor,]
  
  # calculate hypothetical NOR smolt reaching LGR if all parr were spring migrants
  Ma_tot_hyp_i = Pb_i * phi_Pa_Mb_i * phi_Mb_Ma_i
  
  # calculate actual NOR smolt reaching LGR
  Ma_tot_real_i = Ma_i[,i_fall,o_nor,] + Ma_i[,i_spring,o_nor,]
  
  # add columns storing the aggregate across populations
  Ma_tot_hyp_i = cbind(Ma_tot_hyp_i, rowSums(Ma_tot_hyp_i))
  Ma_tot_real_i = cbind(Ma_tot_real_i, rowSums(Ma_tot_real_i))
  
  # calculate the ratios between the actual and hypothetical
  mean_p_ratio = colMeans(Ma_tot_hyp_i/Ma_tot_real_i, na.rm = TRUE)
  cv_ratio = apply(Ma_tot_hyp_i, 2, cv)/apply(Ma_tot_real_i, 2, cv)
  
  names(mean_p_ratio) = paste0("mean_p_ratio[", 1:5, "]")
  names(cv_ratio) = paste0("cv_ratio[", 1:5, "]")
  c(mean_p_ratio, cv_ratio)
}

##### STEP 3: APPLY FUNCTION TO ALL POSTERIOR SAMPLES, FORMAT, AND SUMMARIZE #####

# apply
ratio_out = t(sapply(1:nrow(Pb), f))

# format
ratio_post = post_convert(cbind(postpack:::id_mat(post), ratio_out))

# summarize
mean_summ = post_summ(ratio_post, "mean")
cv_summ = post_summ(ratio_post, "cv")

# format the summaries for barplotting
mns = rbind(mean_summ["mean",], cv_summ["mean",])
lwrs = rbind(mean_summ["2.5%",], cv_summ["2.5%",])
uprs = rbind(mean_summ["97.5%",], cv_summ["97.5%",])

# set the colors
cols = c("grey50", "grey80")

# make the plot
mypar(mfrow = c(1,1), col.axis = "black")
mp = barplot(mns, beside = TRUE, names.arg = c(pops, "TOTAL"),
             ylim = c(0, 1.35), border = NA, col = cols)

# draw error bars
segments(mp, lwrs, mp, uprs)

# draw x-axis
segments(par("usr")[1], par("usr")[3], par("usr")[2], par("usr")[3], xpd = TRUE, col = par("col.axis"))
axis_labels("Population", "Without:With Fall Migrant Strategy")

# draw a reference line
abline(h = 1, lty = 2)

# draw a legend
legend("topright", title = "LGR Smolt", legend = c("Mean", "CV"), pch = 15,
       col = cols, pt.cex = 1.5, bty = "n", text.col = par("col.axis"), cex = 0.8)
```

\newpage

```{r compare-fn, eval = params$surv_compare_fig | params$apportion_compare_fig}
pch = c(21, 23)

cex_main = 2.5
cex_sub = 1.1

solid_col = "grey40"
tranp_col = alpha(solid_col, 0.25)

f_horiz = function(ests1, ests2, lim, label) {
  # prepare the first group of estimates
  ests1 = ests1[-1,]; x1 = colMeans(ests1)
  
  # figure out the correct axis labels
  if (ncol(ests1) == 4) tick_labels = pops else tick_labels = c("NOR", "HOR")
  jitter = runif(nrow(ests1), -0.25, 0.25)
  
  if (is.null(ests2)) {
    # empty barplot with correct dimensions
    mp = barplot(x1, col = "white", border = "white", xlim = lim, ylim = c(ncol(ests1) + 0.5, 0.05), horiz = TRUE)
    
    # figure out location of jittered points
    mp_all = t(sapply(1:nrow(ests1), function(i) mp))
    mp_all = apply(mp_all, 2, function(x) x + jitter)
    
    # draw year-specific estimates
    points(ests1, mp_all, col = solid_col, bg = tranp_col, pch = pch[1], cex = cex_sub)
    
    # draw year averages
    points(x1, mp, pch = pch[1], col = "white", bg = "black", cex = cex_main, lwd = 1.5)
    
    # draw axis
    omgp = par("mgp"); nmgp = omgp; nmgp[2] = 0.15
    par(mgp = nmgp)
    usr = par("usr"); xdiff = diff(usr[1:2]); ydiff = diff(usr[3:4])
    segments(usr[1], usr[3], usr[1], usr[4], xpd = TRUE, col = par("col.axis"))
    axis(side = 2, at = mp, labels = tick_labels, las = 1)
    par(mgp = omgp)
    
  } else {
    # prepare the second group of estimates if supplied
    ests2 = ests2[-1,]; x2 = colMeans(ests2)
    
    # empty barplot with correct dimensions
    mp = barplot(rbind(x1, x2), beside = TRUE, space = c(0.25,1), col = "white", border = "white", xlim = lim, ylim = c(ncol(ests1) * 3 + 1, 0.15), horiz = TRUE)
    mp1 = mp[1,]; mp2 = mp[2,]
    
    # figure out location of jittered points
    mp1_all = t(sapply(1:nrow(ests1), function(i) mp1))
    mp1_all = apply(mp1_all, 2, function(x) x + jitter)
    mp2_all = t(sapply(1:nrow(ests2), function(i) mp2))
    mp2_all = apply(mp2_all, 2, function(x) x + jitter)
    
    # draw year-specific estimates
    points(ests1, mp1_all, col = solid_col, bg = tranp_col, pch = pch[1], cex = cex_sub)
    points(ests2, mp2_all, col = solid_col, bg = tranp_col, pch = pch[2], cex = cex_sub)
    
    # draw year averages
    points(x1, mp1, pch = pch[1], cex = cex_main, bg = "black", col = "white", lwd = 1.5)
    points(x2, mp2, pch = pch[2], cex = cex_main, bg = "black", col = "white", lwd = 1.5)
    
    # draw axis
    omgp = par("mgp"); nmgp = omgp; nmgp[2] = 0.15
    par(mgp = nmgp)
    usr = par("usr"); xdiff = diff(usr[1:2]); ydiff = diff(usr[3:4])
    segments(usr[1], usr[3], usr[1], usr[4], xpd = TRUE, col = par("col.axis"))
    axis(side = 2, at = (mp1 + mp2)/2, labels = tick_labels, las = 1)
    par(mpg = omgp)
  }
  
  # draw panel label
  panel_label(label, y_inp = ifelse(ncol(ests1) == 4, 0.05, 0.1), cex = 1.2)
}

legend_f = function(title, grp1, grp2, loc = "topright") {
  legend(loc, title = title, legend = c(grp1, grp2), pch = pch, pt.cex = 1.3, cex = 0.9, bty = "n",
         text.col = par("col.axis"), col = "black", pt.bg = "black")
}
```

```{r surv-compare-fig, fig.width = 3.4, fig.height = 8, fig.cap = msdown::prep_caption(surv_compare_caption), time_it = TRUE, eval = params$surv_compare_fig}

# extract the posterior means to plot
phi_E_Pb = array_format(post_summ(post, sub_index("^phi_E_Pb[year,pop]", year = observable, pop = ".+"))["mean",])
phi_Pa_Mb_fall = array_format(post_summ(post, sub_index("^phi_Pa_Mb[year,LH_type,pop]", year = observable, pop = ".+", LH_type = i_fall))["mean",])[,i_fall,]
phi_Pa_Mb_spring = array_format(post_summ(post, sub_index("^phi_Pa_Mb[year,LH_type,pop]", year = observable, pop = ".+", LH_type = i_spring))["mean",])[,i_spring,]
phi_Mb_Ma_nor = array_format(post_summ(post, sub_index("^phi_Mb_Ma[year,LH_type,origin,pop]", year = observable, pop = ".+", LH_type = i_spring, origin = o_nor))["mean",])[,i_spring,o_nor,]
phi_Mb_Ma_hor = array_format(post_summ(post, sub_index("^phi_Mb_Ma[year,LH_type,origin,pop]", year = observable, pop = ".+", LH_type = i_spring, origin = o_hor))["mean",])[,i_spring,o_hor,]
phi_Ma_O0 = array_format(post_summ(post, sub_index("^phi_Ma_O0[year,origin]", year = observable, origin = ".+"))["mean",])
phi_O0_O1_nor = array_format(post_summ(post, sub_index("^phi_O0_O1[year,origin,pop]", year = observable, pop = ".+", origin = o_nor))["mean",])[,o_nor,]
phi_O0_O1_hor = array_format(post_summ(post, sub_index("^phi_O0_O1[year,origin,pop]", year = observable, pop = ".+", origin = o_hor))["mean",])[,o_hor,]
phi_Rb_Ra = array_format(post_summ(post, sub_index("^phi_Rb_Ra[year,origin]", year = observable, origin = ".+"))["mean",])

# set MIN to NA for HOR values
phi_Mb_Ma_hor[,j_min] = NA
phi_O0_O1_hor[,j_min] = NA

mypar(mfrow = c(1,1), oma = c(1.5,1,0,1), col.axis = "black")
layout(matrix(1:5, ncol = 1), height = c(1,1,1,0.5,1))
f_horiz(ests1 = phi_E_Pb, ests2 = NULL, lim = c(0, 0.5), label = "(a) Egg \u2192 Parr")

f_horiz(ests1 = phi_Pa_Mb_fall, ests2 = phi_Pa_Mb_spring, lim = c(0,1), label = "(b) Parr \u2192 Smolt")
legend_f("Mig. Type", "Fall", "Spring")

f_horiz(ests1 = phi_Mb_Ma_nor, ests2 = phi_Mb_Ma_hor, lim = c(0,1), label = "(c) Smolt \u2192 LGR")
legend_f("Origin", "NOR", "HOR")

f_horiz(ests1 = phi_Ma_O0, ests2 = phi_Rb_Ra, lim = c(0,1), label = "(d) Mainstem")
legend_f("Direction", "LGR \u2192 BON", "BON \u2192 LGR", "bottomleft")

f_horiz(ests1 = phi_O0_O1_nor, ests2 = phi_O0_O1_hor, lim = c(0,0.4), label = "(e) Ocean-0 \u2192 Ocean-1")
legend_f("Origin", "NOR", "HOR", "bottomright")
axis_labels("Survival Probability")
```

\newpage

```{r apportion-compare-fig, fig.width = 3.4, fig.height = 8 * (3/4.5), fig.cap = msdown::prep_caption(apportion_compare_caption), time_it = TRUE, eval = params$apportion_compare_fig}

# extract the posterior means to plot
pi_fall = array_format(post_summ(post, sub_index("^pi[year,LH_type,pop]", year = observable, pop = ".+", LH_type = i_fall))["mean",])[,i_fall,]
psi_O1_nor = array_format(post_summ(post, sub_index("^psi_O1[year,origin,pop]", year = observable, pop = ".+", origin = o_nor))["mean",])[,o_nor,]
psi_O1_hor = array_format(post_summ(post, sub_index("^psi_O1[year,origin,pop]", year = observable, pop = ".+", origin = o_hor))["mean",])[,o_hor,]
psi_O2_nor = array_format(post_summ(post, sub_index("^psi_O2[year,origin,pop]", year = observable, pop = ".+", origin = o_nor))["mean",])[,o_nor,]
psi_O2_hor = array_format(post_summ(post, sub_index("^psi_O2[year,origin,pop]", year = observable, pop = ".+", origin = o_hor))["mean",])[,o_hor,]

# set MIN to NA for HOR values
psi_O1_hor[,j_min] = NA
psi_O1_hor[,j_min] = NA

mypar(mfrow = c(1,1), oma = c(1.5,1,0,1), col.axis = "black")
layout(matrix(1:3, ncol = 1), height = c(1,1,1))
f_horiz(ests1 = pi_fall, ests2 = NULL, lim = c(0, 0.6), label = "(a) Pr(Fall Migrant)")

f_horiz(ests1 = psi_O1_nor, ests2 = psi_O1_hor, lim = c(0,0.4), label = "(b) Pr(Mature Age-3)")
legend_f("Origin", "NOR", "HOR")

f_horiz(ests1 = psi_O2_nor, ests2 = psi_O2_hor, lim = c(0,1), label = "(c) Pr(Mature Age-4)")
legend_f("Origin", "NOR", "HOR", "bottomleft")

axis_labels("Transition Probability (Non-Survival)")
```

\newpage

```{r corr-compare-fig, fig.width = 3.4, fig.height = 3.4, fig.cap = msdown::prep_caption(corr_compare_caption), eval = params$corr_compare_fig}

# get posterior summaries of the mean correlation across all pop pairs
# for each process separately
rho_params1 = match_params(post, "rho", type = "base_only")
rho_params2 = match_params(post, "rho_.+_pr", type = "base_only")
rho_params = rho_params1[!(rho_params1 %in% rho_params2)]

# function to extract posterior summaries of the rho parameters for a given process
f = function(p) {
  x = rowMeans(post_subset(post, paste0("^", p, "["), matrix = TRUE))
  c(mean = mean(x), sd = sd(x), quantile(x, c(0.025, 0.1, 0.25, 0.5, 0.75, 0.9, 0.975)))
}

# apply it and order
rho_mean_out = t(sapply(rho_params, f))
rho_mean_out = rho_mean_out[order(rho_mean_out[,"mean"]),]

# assign names to the different rho parameters
rho_labels = c(
  "rho_Lphi_E_Pb" = "Egg \u2192 Parr",
  "rho_Lphi_O0_O1" = "Ocean-0 \u2192 Ocean-1",
  "rho_Lpsi_O1" = "Pr(Mature Age-3)",
  "rho_Lpsi_O2" = "Pr(Mature Age-4)",
  "rho_lDelta_L_Pb_Mb" = "\u0394 Mean Length",
  "rho_Lphi_Mb_Ma" = "Smolt \u2192 LGR",
  "rho_lL_Pb" = "Mean Parr Length",
  "rho_Lphi_Pa_Mb" = "Parr \u2192 Smolt",
  "rho_Lphi_Rb_Ra" = "BON \u2192 LGR",
  "rho_Lpi" = "Pr(Fall Migrant)",
  "rho_Lphi_Ma_O0" = "LGR \u2192 BON"
)

# set up empty plotting region
mypar(mar = c(2.5,6,1,0.75), yaxs = "i", mfrow = c(1,1), oma = c(0,0,0,0), mgp = c(2,0.1,0), col.axis = "black", cex.axis = 0.75)
mp = barplot(rho_mean_out[,"mean"], 
             horiz = TRUE, xlim = c(-1,1),
             names.arg = rho_labels[rownames(rho_mean_out)],
             las = 1, col = "white", border = "white")
usr = par("usr")

box_upr = mp - rbind(diff(mp)/2, NA)
box_lwr = mp + rbind(diff(mp)/2, NA)
box_upr[nrow(box_upr),] = box_upr[nrow(box_upr)-1,] + diff(box_upr[1:2])
box_lwr[nrow(box_lwr),] = box_lwr[nrow(box_upr)-1,] + diff(box_lwr[1:2])

pop_rhos = function(param, at_mp) {
  
  # if the process is not one of the hydropower migration survival ones, do this
  # those processes are correlated across origins, because all populations share the same values each year
  if (!(param %in% c("rho_Lphi_Ma_O0", "rho_Lphi_Rb_Ra"))) {
    x = post_summ(post, paste0(param, vcov_inds), probs = c(0.1, 0.25, 0.75, 0.9))
    y = at_mp + runif(6, -0.3, 0.3)
    points(y ~ x["mean",], pch = 21, col = solid_col, bg = tranp_col)
  } 
}
abline(v = 0, lty = 1, lwd = 2, col = "grey")

junk = sapply(1:nrow(mp), function(i) pop_rhos(rownames(rho_mean_out)[i], mp[i,]))
segments(rho_mean_out[,"25%"], mp, rho_mean_out[,"75%"], mp, lwd = 7, col = "white")
segments(rho_mean_out[,"2.5%"], mp, rho_mean_out[,"97.5%"], mp, col = "white", lwd = 2)
points(mp ~ rho_mean_out[,"mean"], pch = 3, cex = 1, col = "white", lwd = 4)
segments(rho_mean_out[,"25%"], mp, rho_mean_out[,"75%"], mp, lwd = 6, col = "black")
segments(rho_mean_out[,"2.5%"], mp, rho_mean_out[,"97.5%"], mp, col = "black")
points(mp ~ rho_mean_out[,"mean"], pch = 3, cex = 1, col = "black", lwd = 3)

abline(h = mp + rbind(diff(mp)/2, NA), xpd = FALSE, col = "grey", lty = 2)
# par(tcl = -7)
# axis(side = 2, at = mp + rbind(diff(mp)/2, NA), col = "grey", line = NA, labels = FALSE, lty = 2)
box(col = par("col.axis"))
axis_labels(xlab = "Process Noise Correlation", xline = 1.25, outer = FALSE)
```

\clearpage

```{r time-table}
# calculate times elapsed for each chunk
tab = data.frame(
  Item = names(start_times),
  Minutes = round(sapply(1:length(start_times), function(i) lubridate::int_length(lubridate::int_diff(c(start_times[[i]], end_times[[i]])))/60), 1)
)

# add a total time elapsed
tab = rbind(tab, data.frame(Item = "Total", "Minutes" = sum(tab$Minutes)))

# create the table
kbl(tab, format = "latex", booktabs = TRUE, longtable = FALSE, linesep = "", caption = "Time elapsed in calculating the content in this document.") %>%
  kable_styling(full_width = FALSE, latex_options = "HOLD_position") %>%
  row_spec(0, bold = TRUE) %>%
  column_spec(1, monospace = TRUE) %>%
  row_spec(nrow(tab), bold = TRUE)
```
