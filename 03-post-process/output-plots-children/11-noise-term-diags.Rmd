---
editor_options: 
  chunk_output_type: console
---

# Random Noise Diagnostics {.tabset .tabset-pills}

```{r misc-resid-fns}
get_yr_index = function(params) {
  yr_index = stringr::str_extract(params, "\\[[0-9]+,")
  yr_index = stringr::str_remove(yr_index, "\\[")
  yr_index = stringr::str_remove(yr_index, ",")
  as.numeric(yr_index)
}

make_legend_text = function(mn_post, sd_post, first_last_mn_diff_post) {
  f = function(x) {
    xs = c(mean(x), quantile(x, c(0.025, 0.975)))
    xs = round(xs, 2)
    paste0(xs[1], " (", xs[2], " - ", xs[3], ")")
  }
  c(paste0("Mean: ", f(mn_post)), paste0("SD: ", f(sd_post)), paste0("Diff: ", f(first_last_mn_diff_post)))
}

no_data_plot = function(main = NULL) {
  empty_plot(text = "No Data", label_text = main)
}
```

This section is devoted to evaluating how consistent the estimated noise terms are with the assumptions of the random processes they are assumed to be generated by.
Diagnostics are separate by process model and observation model and the time series of noise terms is displayed to visually detect issues.
Each model component (process or observation) includes summary tables that quantitatively summarize the results displayed on the time series figures.

#### Why Does this Matter?

The presence of egregious assumption violations is an indication that the model may give predictions that are inconsistent with the historical data and assumed hypotheses/mechanisms.
If the assumptions are reasonably met, the noise (or "residual", representing inter-annual variability) terms should be:

1. **Non-existent on average**: each year has an expected value and the noise term represents how far the realized value falls from the expectation, either higher or lower. Thus, the expectation for any given noise term is "no noise"; i.e., if the same year was replicated many times over under the same random process, the average of the realized values would be the expected value.
2. **IID**: all noise terms for a process are generated by the same random process, i.e., with mean zero and common variance; noise terms are assumed independent from year to year, except in cases with an auto-regressive process included.
3. **Free of time series patterns**: this is implied by the above two assumptions, i.e., there should be no time trends or cyclical "regime shifts."

#### What was Calculated?

Because the model used several different types of probability distributions for accounting for process and observational noise (logit-normal, log-normal, binomial, and multinomial), we wished to use a standardization technique that would enable using the same metrics to assess assumption validity for all random processes.
We chose to use a quantile standardization, wherein the noise term for a given process in a given year is expressed as a value between zero and one and is obtained as the cumulative probability of the realized value when treating the posterior predictive distribution for that year as the CDF.

For example, consider an arbitrary outcome $x_y$ in a given year from a random process with density/mass function $f()$ with parameter vector $\mathbf{\theta}$ and lower bound of $l$ (e.g., $l=-\infty$ or $l = 0$, depending on the domain of $f()$).
The standardized residual is then:

$$
\Pr(X \leq x_y) = \int_{l}^{x_y} f(v; \mathbf{\theta}) dv
$$

If repeated realizations $x_y, x_{y+1},\dots,x_{y+n}$ are consistent with the random process $f$, then their quantile-standardized values will be distributed uniformly between zero and one (i.e., $\Pr(X \leq x_y) \sim \mathrm{U}(0,1)$).
If the parameter vector $\mathbf{\theta}$ varies annually, then $\mathbf{\theta}_y$ can be substituted and the same uniform property should hold if the realized outcomes are consistent with both (_a_) the random process $f()$ and (_b_) the (probably deterministic) process generating inter-annual variability in $\mathbf{\theta}_y$.

The interpretation of these quantile-standardized noise terms is:

* **Equal to 0.5**: The realized outcome was exactly in the center of $f()$
* **Less than 0.5**: The realized outcome was somewhere in the lower tail of $f()$, values closer to zero are more extreme noise outcomes
* **Greater than 0.5**: The realized outcome was somewhere in the upper tail of $f()$, values closer to one are more extreme noise outcomes

Because the parameter vector $\theta$ has a posterior distribution, we calculated these standardized noise terms for each MCMC sample, which provides posterior distributions of the noise terms as well.

We performed this calculation for each random process (of both the observation and process components) in the model using the built-in cumulative distribution functions in JAGS.
For multinomial random variables (i.e., adult age/origin composition), we used category-specific binomial distributions to assess noise.
This allowed assessing the validity of age/origin-specific noise terms needed to accommodate the data.

##### JAGS Code Example

Consider one process in the model in which the survival probability varies annually (`phi[y]`) around a time constant mean (`mu_phi`) with logit-normal variability and standard deviation of `sigma_Lphi`.
Further, suppose we have counts of tagged fish we know survived (`x_surv[y]`) and the total number of fish tagged (`n_tagged[y]`) each year.
We wish to calculate the process model noise terms as quantile-standardized residuals (`phi_qresid[y]` and `x_surv_qresid[y]`).
The code below illustrates this calculation for this reduced example:

<details>
<summary>Click to Show Example Code</summary>
<pre>
# priors
mu_phi ~ dbeta(1,1)
sigma_Lphi ~ dunif(0,5)
&nbsp;
for (y in 1:ny) {
  # random process
  Lphi[y] ~ dnorm(logit(mu_phi), 1/sigma_Lphi^2)
  phi[y] &lt;- ilogit(Lphi[y])
  &nbsp;
  # standardized process noise term
  phi_qresid[y] &lt;- pnorm(logit(phi[y]), logit(mu_phi), 1/sigma_Lphi^2)
  &nbsp;
  # likelihood statement for fitting model
  x_surv[y] ~ dbin(phi[y], n_tagged[y])
  &nbsp;
  # standardized observation noise term
  x_surv_qresid[y] <- pbin(x_surv[y], phi[y], n_tagged[y])
} </pre>
</details>  

#### What is Shown?

For each random process in the model, the time series of standardized noise terms is plotted below:

* red points/bars: year-specific posterior mean/95% CRI
* blue horizontal lines: first and last half of time series mean values
* grey horizontal lines: expected 25%, 50%, and 75% quantiles of the standardized residuals).

To summarize these time series quantitatively, we report three across-year summary statistics:

* **Across-year mean** -- intended to verify that noise terms are centered on the expected value overall (ideally equal to 0.5; the expected value of a $\mathrm{U}(0,1)$ distribution)
* **Across-year SD** --- intended to verify that noise terms are as variable as expected overall (ideally equal to $\sqrt{1/12}$ = `r round(sqrt(1/12), 2)`; the standard deviation of a $\mathrm{U}(0,1)$ distribution)
* **mean(last half) - mean(first half)** -- intended to verify that noise is not time-trending (ideally equal to 0)

These values were calculated for each posterior sample and were summarized as the posterior mean and 95% CRI.
They are shown at the top left of each time series plot and summarized across processes in the "Summary Tables" sections.
`r if (params$include_sim_years) "**Although the time series plots show simulated years beyond the observed period, the across-year summary statistics were calculated only using years that have been monitored for at least one population.**"`

## Process Model Noise Terms {.tabset .tabset-pills}

```{r make-process-noise-terms, results = "hide"}
# create quantile residuals for a time series from one process
# e.g., Pr(mature age-3) for all years for one population, origin, and age combination
make_qresid = function(real_param, mean_param, sig_param, f_real = qlogis, f_mean = qlogis, yrs = observable, ...) {
  
  # extract posterior samples of the correct quantities for all years, and apply the correct transformation where needed
  real_samps = f_real(post_subset(post, sub_index(real_param, year = yrs, ...), matrix = TRUE))  # realized value from ppd
  mean_samps = f_mean(post_subset(post, sub_index(mean_param, year = yrs, ...), matrix = TRUE))  # mean parameter ppd
  sig_samps = as.numeric(post_subset(post, sub_index(sig_param, ...), matrix = TRUE))            # sd parameter of ppd
  
  # remove any ^ or $ symbols used in specifying specific parameters
  real_param = postpack:::rm_regex_lock(real_param)
  mean_param = postpack:::rm_regex_lock(mean_param)
  
  # calculate the quantile of the realized value given the mean and sd parameter
  # performed MCMC draw by draw for each year separately
  out = sapply(1:length(yrs), function(y) {
    pnorm(
      real_samps[,sub_index(real_param, year = yrs[y], ...)],
      mean_samps[,sub_index(mean_param, year = yrs[y], ...)],
      sig_samps
    )
  })
  
  # create new names for the output
  # basically add "_qresid" to the end of the realized node name
  new_names = sub_index(real_param, year = yrs, ...)
  new_names = stringr::str_replace(new_names, "\\[", "_qresid[")
  
  # include the correct letter to indicate transformation performed (L = logit or l = log) and drop any ^
  new_names = paste0(ifelse(f_real(1) == log(1), "l", "L"), new_names)
  colnames(out) = new_names
  
  # return the output: a matrix of posterior samples for the desired process
  return(out)
}

# create quantile residuals for all time series from one process
# e.g., Pr(mature age-3) for all years, all populations, and age-combinations
# type = "pop" is for processes that vary by population
# type = "origin" is for processes that very by origin
make_qresid_all = function(real_param, mean_param, sig_param, f_real = qlogis, f_mean = qlogis, type = "pop", ...) {
  
  # print an indicator for which process is being analyzed
  process_name = postpack:::rm_regex_lock(real_param)
  process_name = postpack:::drop_index(process_name)
  cat("  ", process_name, "\n")
  
  # loop over populations if appropriate
  if (type == "pop") {
    qresid_out = lapply(1:jags_data$nj, function(j) {
      cat("\r    Population: ", c("CAT", "LOS", "MIN", "UGR")[j], sep = "")
      out = make_qresid(real_param, mean_param, sig_param, f_real = f_real, f_mean = f_mean, pop = j, ...)
      return(out)
    })
  }
  
  # loop over origins if appropriate
  if (type == "origin") {
    qresid_out = lapply(1:jags_data$no, function(o) {
      cat("\r    Origin: ", c("NOR", "HOR")[o], sep = "")
      out = make_qresid(real_param, mean_param, sig_param, f_real = f_real, f_mean = f_mean, origin = o, ...)
      return(out)
    });
  }
  
  # print a newline
  cat("\n")
  
  # combine list elements into one matrix
  qresid_out = do.call(cbind, qresid_out)
  
  # return the output
  return(qresid_out)
}

# container object to append output to
qresid_post = postpack:::id_mat(post)

# egg to parr survival
qresid_post = cbind(qresid_post,
                    make_qresid_all("^phi_E_Pb[year,pop]",
                                    "phi_E_Pb_dot2[year,pop]",
                                    "sig_Lphi_E_Pb[pop]",
                                    type = "pop")
)

# parr mean length
qresid_post = cbind(qresid_post,
                    make_qresid_all("^L_Pb[year,pop]",
                                    "^L_Pb_dot[year,pop]",
                                    "sig_lL_Pb[pop]",
                                    type = "pop", f_real = log, f_mean = log)
)

# Pr(fall migrant)
qresid_post = cbind(qresid_post,
                    make_qresid_all("^pi[year,LH_type,pop]",
                                    "mu_pi[LH_type,pop]",
                                    "sig_Lpi[pop]",
                                    type = "pop", LH_type = jags_data$i_fall)
)

# overwinter survival: fall migrants
qresid_post = cbind(qresid_post,
                    make_qresid_all("^phi_Pa_Mb[year,LH_type,pop]",
                                    "^phi_Pa_Mb_dot[year,LH_type,pop]",
                                    "sig_Lphi_Pa_Mb[pop]",
                                    type = "pop", LH_type = jags_data$i_fall)
)

# overwinter survival: spring migrants
qresid_post = cbind(qresid_post,
                    make_qresid_all("^phi_Pa_Mb[year,LH_type,pop]",
                                    "^phi_Pa_Mb_dot[year,LH_type,pop]",
                                    "sig_Lphi_Pa_Mb[pop]",
                                    type = "pop", LH_type = jags_data$i_spring)
)


# "growth" factor
qresid_post = cbind(qresid_post,
                    make_qresid_all("^Delta_L_Pb_Mb[year,pop]",
                                    "^Delta_L_Pb_Mb_dot[year,pop]",
                                    "sig_lDelta_L_Pb_Mb[pop]",
                                    type = "pop", f_real = log, f_mean = log)
)


# trib to LGR survival: NOR
qresid_post = cbind(qresid_post,
                    make_qresid_all("^phi_Mb_Ma[year,LH_type,origin,pop]",
                                    "^phi_Mb_Ma_dot[year,LH_type,origin,pop]",
                                    "sig_Lphi_Mb_Ma[pop]",
                                    type = "pop", LH_type = jags_data$i_spring, origin = jags_data$o_nor)
)

# trib to LGR survival: HOR
qresid_post = cbind(qresid_post,
                    make_qresid_all("^phi_Mb_Ma[year,LH_type,origin,pop]",
                                    "^mu_phi_Mb_Ma[LH_type,origin,pop]",
                                    "sig_Lphi_Mb_Ma[pop]",
                                    type = "pop", LH_type = jags_data$i_spring, origin = jags_data$o_hor)
)

# LGR to ocean survival
qresid_post = cbind(qresid_post,
                    make_qresid_all("^phi_Ma_O0[year,origin]",
                                    "mu_phi_Ma_O0[origin]",
                                    "sig_Lphi_Ma_O0[origin]",
                                    type = "origin")
)

# Yr1 ocean survival
qresid_post = cbind(qresid_post,
                    make_qresid_all("^phi_O0_O1[year,origin,pop]",
                                    "^phi_O0_O1_dot2[year,origin,pop]",
                                    "sig_Lphi_O0_O1[pop]",
                                    type = "pop", origin = jags_data$o_nor)
)

# Pr(mature age-3): NOR
qresid_post = cbind(qresid_post,
                    make_qresid_all("^psi_O1[year,origin,pop]",
                                    "^mu_psi_O1[origin,pop]",
                                    "sig_Lpsi_O1[pop]",
                                    type = "pop", origin = jags_data$o_nor)
)

# Pr(mature age-3): HOR
qresid_post = cbind(qresid_post,
                    make_qresid_all("^psi_O1[year,origin,pop]",
                                    "^mu_psi_O1[origin,pop]",
                                    "sig_Lpsi_O1[pop]",
                                    type = "pop", origin = jags_data$o_hor)
)

# Pr(mature age-3): NOR
qresid_post = cbind(qresid_post,
                    make_qresid_all("^psi_O2[year,origin,pop]",
                                    "^mu_psi_O2[origin,pop]",
                                    "sig_Lpsi_O2[pop]",
                                    type = "pop", origin = jags_data$o_nor)
)

# Pr(mature age-3): HOR
qresid_post = cbind(qresid_post,
                    make_qresid_all("^psi_O2[year,origin,pop]",
                                    "^mu_psi_O2[origin,pop]",
                                    "sig_Lpsi_O2[pop]",
                                    type = "pop", origin = jags_data$o_hor)
)

# BON to LGR survival
qresid_post = cbind(qresid_post,
                    make_qresid_all("^phi_Rb_Ra[year,origin]",
                                    "mu_phi_Rb_Ra[origin]",
                                    "sig_Lphi_Rb_Ra[origin]",
                                    type = "origin")
)

qresid_post = qresid_post[,-c(1:2)]

post = post_bind(post, qresid_post)
```

```{r plot-proc-resid-fn}

plot_proc_qresid = function(qresid_param, year = ts_yrs, pop = NULL, origin = NULL, LH_type = NULL, age = NULL, main = NULL) {
  
  # extract posterior samples of residual time series
  qresid_post = post_subset(post, sub_index(qresid_param, year = year, pop = pop, origin = origin, LH_type = LH_type, age = age), matrix = TRUE)
  
  # extract the year indices available
  y_ind = get_yr_index(colnames(qresid_post))
  y_ind_obs = y_ind %in% observable
  
  # calculate posterior across-year mean and sd for each posterior sample
  # only for years that are observable; don't want to include any simulated years in these stats
  mn_post = apply(qresid_post[,y_ind_obs], 1, mean)
  sd_post = apply(qresid_post[,y_ind_obs], 1, sd)
  
  # calculate posterior mean(last half of years) - mean(first half of years)
  y_first = 1:round(length(y_ind[y_ind_obs])/2)
  y_last = (max(y_first) + 1):length(y_ind[y_ind_obs])
  mn_post_first = apply(qresid_post[,y_first], 1, mean)
  mn_post_last = apply(qresid_post[,y_last], 1, mean)
  first_last_mn_diff_post = mn_post_last - mn_post_first
  
  # calculate posterior summaries of standardized qresidual time series
  qresid = apply(qresid_post, 2, function(x) c(mean = mean(x), sd = sd(x), quantile(x, c(0.5, 0.025, 0.975, 0.25, 0.75))))
  
  # set the y-axis limits: leave room at top for legend
  ylim = c(0,1.3)
  
  # blank plot with correct dimensions
  plot(qresid["mean",] ~ all_yrs[y_ind], type = "n",
       ylim = ylim, xlim = range(all_yrs[y_ind]), xaxt = "n", yaxt = "n", xlab = "", ylab = "")
  
  # draw x-axis: years
  at_x = seq(min(all_yrs[observable]), max(all_yrs[observable]), 4)
  axis(side = 1, at = at_x, labels = paste0("'", substr(at_x, 3, 4)))
  axis(side = 2, at = seq(0, 1, 0.25), labels = TRUE)
  
  # draw reference line at 25%, 50%, and 75% quantiles
  abline(h = c(0.25, 0.5, 0.75), lty = 3, col = "grey", lwd = 2)
  
  # draw posterior mean for first and half of time series
  lines(x = all_yrs[y_ind[y_first]], y = rep(mean(mn_post_first), length(y_first)), col = main_cols["model2"], lty = 3, lwd = 2)
  lines(x = all_yrs[y_ind[y_last]], y = rep(mean(mn_post_last), length(y_last)), col = main_cols["model2"], lty = 3, lwd = 2)
  
  # draw the noise time series: mean and 95% CRI
  segments(all_yrs[observable], qresid["2.5%",], all_yrs[observable], qresid["97.5%",], col = main_cols["model"])
  segments(all_yrs[observable], qresid["25%",], all_yrs[observable], qresid["75%",], col = main_cols["model"], lwd = 4)
  points(qresid["mean",] ~ all_yrs[observable], pch = 21, col = "white", bg = "white", cex = 1.25)
  points(qresid["mean",] ~ all_yrs[observable], pch = 21, col = main_cols["model"], bg = tran_cols["model"], cex = 1.25)
  
  # draw legend that shows estimate summaries
  usr = par("usr"); xdiff = diff(usr[1:2]); ydiff = diff(usr[3:4])
  rect(usr[1], 1, usr[2], usr[4], border = par("col.axis"), col = "grey95")
  legend(x = usr[1] - xdiff * 0.05, y = usr[4] + ydiff * 0.025, text.col = par("col.axis"), legend = make_legend_text(mn_post, sd_post, first_last_mn_diff_post), bty = "n", cex = 0.8)
  box(col = par("col.axis"))
  panel_label(main, "topright")
  
  
  # create output for building summary tables
  data.frame(param = qresid_param,
             pop = ifelse(!is.null(pop), pop, NA),
             origin = ifelse(!is.null(origin), origin, NA),
             LH_type = ifelse(!is.null(LH_type), LH_type, NA),
             age = ifelse(!is.null(age), age, NA),
             n_yrs = ncol(qresid_post[,y_ind %in% observable]),
             year_mean_mean = mean(mn_post),
             year_mean_lwr = unname(quantile(mn_post, 0.025)),
             year_mean_upr = unname(quantile(mn_post, 0.975)),
             year_sd_mean = mean(sd_post),
             year_sd_lwr = unname(quantile(sd_post, 0.025)),
             year_sd_upr = unname(quantile(sd_post, 0.975)),
             diff_mean = mean(first_last_mn_diff_post), 
             diff_lwr = unname(quantile(first_last_mn_diff_post, 0.025)), 
             diff_upr = unname(quantile(first_last_mn_diff_post, 0.975))
  )
  
}

# container for across-year summary statistics
# is rbinded many times for each random process and pop/origin/LH_type/age combo
proc_error_ests = NULL
```

### FW Juvenile {.tabset .tabset-pills}

#### Egg $\to$ Parr Survival

```{r egg-to-parr-noise, fig.width = p4_width, fig.height = p4_height}
mypar()
tmp = lapply(1:jags_data$nj, function(j) plot_proc_qresid("Lphi_E_Pb_qresid[year,pop]", pop = j, main = pops[j]))
axis_labels("Brood Year", "logit(Egg \u2192 Parr Survival) QResidual")
proc_error_ests = rbind(proc_error_ests, do.call(rbind, tmp))
```

#### Parr Mean Length

```{r summer-length-noise, fig.width = p4_width, fig.height = p4_height}
mypar()
tmp = lapply(1:jags_data$nj, function(j) plot_proc_qresid("lL_Pb_qresid[year,pop]", pop = j, main = pops[j]))
axis_labels("Brood Year", "log(Summer Parr Mean Length) QResidual")
proc_error_ests = rbind(proc_error_ests, do.call(rbind, tmp))
```

#### Migratory Strategy Apportionment

```{r pi-noise, fig.width = p4_width, fig.height = p4_height}
mypar()
tmp = lapply(1:jags_data$nj, function(j) plot_proc_qresid("Lpi_qresid[year,LH_type,pop]", pop = j, main = pops[j], LH_type = i_fall))
axis_labels("Brood Year", "logit(Proportion Fall Migrants) QResidual")
proc_error_ests = rbind(proc_error_ests, do.call(rbind, tmp))
```

#### Over-winter Survival {.tabset .tabset-pills}

##### Fall Migrants

```{r overwinter-surv-noise-fall, fig.width = p4_width, fig.height = p4_height}
mypar()
tmp = lapply(1:jags_data$nj, function(j) plot_proc_qresid("Lphi_Pa_Mb_qresid[year,LH_type,pop]", pop = j, LH_type = 1, main = pops[j]))
axis_labels("Brood Year", "logit(Over-winter Survival [Fall Migrants]) QResidual")
proc_error_ests = rbind(proc_error_ests, do.call(rbind, tmp))
```

##### Spring Migrants

```{r overwinter-surv-noise-spring, fig.width = p4_width, fig.height = p4_height}
mypar()
tmp = lapply(1:jags_data$nj, function(j) plot_proc_qresid("Lphi_Pa_Mb_qresid[year,LH_type,pop]", pop = j, LH_type = 2, main = pops[j]))
axis_labels("Brood Year", "logit(Over-winter Survival [Spring Migrants]) QResidual")
proc_error_ests = rbind(proc_error_ests, do.call(rbind, tmp))
```

#### Parr $\to$ Smolt "Growth Factor"

```{r growth-noise, fig.width = p4_width, fig.height = p4_height}
mypar()
tmp = lapply(1:jags_data$nj, function(j) plot_proc_qresid("lDelta_L_Pb_Mb_qresid[year,pop]", pop = j, main = pops[j]))
axis_labels("Brood Year", "log(Parr \u2192 Smolt 'Growth' Factor) QResidual")
proc_error_ests = rbind(proc_error_ests, do.call(rbind, tmp))
```

#### Trib $\to$ LGR {.tabset .tabset-pills}

##### NOR

```{r trib-to-LGR-surv-nor, fig.width = p4_width, fig.height = p4_height}
mypar()
tmp = lapply(1:jags_data$nj, function(j) plot_proc_qresid("Lphi_Mb_Ma_qresid[year,LH_type,origin,pop]", pop = j, origin = 1, LH_type = 2, main = pops[j]))
axis_labels("Brood Year", "logit(Trib \u2192 LGR Survival [NOR]) QResidual")
proc_error_ests = rbind(proc_error_ests, do.call(rbind, tmp))
```

##### HOR

```{r trib-to-LGR-surv-hor, fig.width = p4_width, fig.height = p4_height}
mypar()
tmp = lapply(1:jags_data$nj, function(j) plot_proc_qresid("Lphi_Mb_Ma_qresid[year,LH_type,origin,pop]", pop = j, origin = 2, LH_type = 2, main = pops[j]))
axis_labels("Brood Year", "logit(Trib \u2192 LGR Survival [HOR]) QResidual")
proc_error_ests = rbind(proc_error_ests, do.call(rbind, tmp))
```

#### LGR $\to$ BON Survival

```{r LGR-to-BON-surv-noise, fig.width = p2_width, fig.height = p2_height}
mypar(mfrow = c(1,2))
tmp = lapply(1:jags_data$no, function(o) plot_proc_qresid("Lphi_Ma_O0_qresid[year,origin]", origin = o, main = origins[o]))
axis_labels("Brood Year", "logit(LGR \u2192 BON Survival) QResidual")
proc_error_ests = rbind(proc_error_ests, do.call(rbind, tmp))
```

### SW Juvenile {.tabset .tabset-pills}

#### Yr1 Ocean Survival

```{r yr1-ocean-surv-noise, fig.width = p4_width, fig.height = p4_height}
mypar()
tmp = lapply(1:jags_data$nj, function(j) plot_proc_qresid("Lphi_O0_O1_qresid[year,origin,pop]", origin = 1, year = c(ts_yrs), pop = j, main = pops[j]))
axis_labels("Brood Year", "logit(Yr1 Ocean Survival) QResidual")
proc_error_ests = rbind(proc_error_ests, do.call(rbind, tmp))
```

#### Pr(Mature at age-3) {.tabset .tabset-pills}

##### NOR

```{r pr-mat-3-nor-noise, fig.width = p4_width, fig.height = p4_height}
mypar()
tmp = lapply(1:jags_data$nj, function(j) plot_proc_qresid("Lpsi_O1_qresid[year,origin,pop]", origin = 1, pop = j, main = pops[j]))
axis_labels("Brood Year", "logit(Mature at Age-3 [NOR]) QResidual")
proc_error_ests = rbind(proc_error_ests, do.call(rbind, tmp))
```

##### HOR

```{r pr-mat-3-hor-noise, fig.width = p4_width, fig.height = p4_height}
mypar()
tmp = lapply(1:jags_data$nj, function(j) plot_proc_qresid("Lpsi_O1_qresid[year,origin,pop]", origin = 2, pop = j, main = pops[j]))
axis_labels("Brood Year", "logit(Mature at Age-3 [HOR]) QResidual")
proc_error_ests = rbind(proc_error_ests, do.call(rbind, tmp))
```

#### Pr(Mature at age-4) {.tabset .tabset-pills}

##### NOR

```{r pr-mat-4-nor-noise, fig.width = p4_width, fig.height = p4_height}
mypar()
tmp = lapply(1:jags_data$nj, function(j) plot_proc_qresid("Lpsi_O2_qresid[year,origin,pop]", origin = 1, pop = j, main = pops[j]))
axis_labels("Brood Year", "logit(Mature at Age-4 [NOR]) QResidual")
proc_error_ests = rbind(proc_error_ests, do.call(rbind, tmp))
```

##### HOR

```{r pr-mat-4-hor-noise, fig.width = p4_width, fig.height = p4_height}
mypar()
tmp = lapply(1:jags_data$nj, function(j) plot_proc_qresid("Lpsi_O2_qresid[year,origin,pop]", origin = 2, pop = j, main = pops[j]))
axis_labels("Brood Year", "logit(Mature at Age-4 [HOR]) QResidual")
proc_error_ests = rbind(proc_error_ests, do.call(rbind, tmp))
```

### FW Adult {.tabset .tabset-pills}

#### BON $\to$ LGR Survival

```{r BON-to-LGR-surv-noise, fig.width = p2_width, fig.height = p2_height}
mypar(mfrow = c(1,2))
tmp = lapply(1:jags_data$no, function(o) plot_proc_qresid("Lphi_Rb_Ra_qresid[year,origin]", origin = o, main = origins[o]))
axis_labels("Return Year", "logit(BON \u2192 LGR Survival) QResidual")
proc_error_ests = rbind(proc_error_ests, do.call(rbind, tmp))
```

### **SUMMARY TABLES** {.tabset .tabset-pills}

These tables show posterior summary statistics of the time series of noise terms across years (i.e., the values shown on each figure panel). Bold values denote that the target value for verifying model assumptions was not within the 95% CRI of the across-year summary statistic and indicates a potential problem.

```{r proc-error-table-prep}
# rename parameters to human-readable format
proc_error_ests$param = stringr::str_replace(proc_error_ests$param, "Lphi_E_Pb_qresid\\[year,pop\\]", "Egg to Parr Survival")
proc_error_ests$param = stringr::str_replace(proc_error_ests$param, "lL_Pb_qresid\\[year,pop\\]", "Summer Parr Length")
proc_error_ests$param = stringr::str_replace(proc_error_ests$param, "Lpi_qresid\\[year,LH_type,pop\\]", "Migratory Strategy Apportionment")
proc_error_ests$param = stringr::str_replace(proc_error_ests$param, "Lphi_Pa_Mb_qresid\\[year,LH_type,pop\\]", "Overwinter Survival")
proc_error_ests$param = stringr::str_replace(proc_error_ests$param, "lDelta_L_Pb_Mb_qresid\\[year,pop\\]", "Summer to Spring 'Growth Factor'")
proc_error_ests$param = stringr::str_replace(proc_error_ests$param, "Lphi_Mb_Ma_qresid\\[year,LH_type,origin,pop\\]", "Trib to LGR Survival")
proc_error_ests$param = stringr::str_replace(proc_error_ests$param, "Lphi_Ma_O0_qresid\\[year,origin\\]", "LGR to BON Survival")
proc_error_ests$param = stringr::str_replace(proc_error_ests$param, "Lphi_O0_O1_qresid\\[year,origin,pop\\]", "Yr1 Ocean Survival")
proc_error_ests$param = stringr::str_replace(proc_error_ests$param, "Lpsi_O1_qresid\\[year,origin,pop\\]", "Pr(Mature Age-3)")
proc_error_ests$param = stringr::str_replace(proc_error_ests$param, "Lpsi_O2_qresid\\[year,origin,pop\\]", "Pr(Mature Age-4)")
proc_error_ests$param = stringr::str_replace(proc_error_ests$param, "Lphi_Rb_Ra_qresid\\[year,origin\\]", "BON to LGR Survival")

# correct origin indices
proc_error_ests$origin[is.na(proc_error_ests$origin)] = 1

# correct LH_type indices
proc_error_ests$LH_type[is.na(proc_error_ests$LH_type)] = 3

# correct pop indices
proc_error_ests$pop[is.na(proc_error_ests$pop)] = 5

# remove the age column
proc_error_ests = proc_error_ests[,-which(colnames(proc_error_ests) == "age")]

# replace indices with names
proc_error_ests$pop = c("CAT", "LOS", "MIN", "UGR", "Combined")[proc_error_ests$pop]
proc_error_ests$origin = c("NOR", "HOR", "Combined")[proc_error_ests$origin]
proc_error_ests$LH_type = c("Fall Mig.", "Spring Mig.", "Combined")[proc_error_ests$LH_type]

# which processes are in each life phase?
fw_juv = c("Egg to Parr Survival", "Summer Parr Length", "Migratory Strategy Apportionment", "Overwinter Survival", "Summer to Spring 'Growth Factor'", "Trib to LGR Survival", "LGR to BON Survival")
sw_juv = c("Yr1 Ocean Survival", "Pr(Mature Age-3)", "Pr(Mature Age-4)")
fw_adult = c("BON to LGR Survival")

# add a life phase column
proc_error_ests$phase = NA
proc_error_ests$phase = ifelse(proc_error_ests$param %in% fw_juv, 1, proc_error_ests$phase)
proc_error_ests$phase = ifelse(proc_error_ests$param %in% sw_juv, 2, proc_error_ests$phase)
proc_error_ests$phase = ifelse(proc_error_ests$param %in% fw_adult, 3, proc_error_ests$phase)
proc_error_ests$phase = c("FW Juvenile", "SW Juvenile", "FW Adult")[proc_error_ests$phase]

# add levels to each variable
proc_error_ests$phase = factor(proc_error_ests$phase, levels = c("FW Juvenile", "SW Juvenile", "FW Adult"))
proc_error_ests$param = factor(proc_error_ests$param, levels = c(fw_juv, sw_juv, fw_adult))
proc_error_ests$origin = factor(proc_error_ests$origin, levels = c("NOR", "HOR", "Combined"))
proc_error_ests$LH_type = factor(proc_error_ests$LH_type, levels = c("Fall Mig.", "Spring Mig.", "Combined"))
proc_error_ests$pop = factor(proc_error_ests$pop, levels = c("CAT", "LOS", "MIN", "UGR", "Combined"))

# determine whether posterior of across-year quantities overlaps the target value
proc_error_ests$yr_mean_incl_target = ifelse(proc_error_ests$year_mean_lwr <= 0.5 & proc_error_ests$year_mean_upr >= 0.5, TRUE, FALSE)
proc_error_ests$yr_sd_incl_target = ifelse(proc_error_ests$year_sd_lwr <= sqrt(1/12) & proc_error_ests$year_sd_upr >= sqrt(1/12), TRUE, FALSE)
proc_error_ests$diff_incl_target = ifelse(proc_error_ests$diff_lwr <= 0 & proc_error_ests$diff_upr >= 0, TRUE, FALSE)

# format the mean values to present in table
# round and make bold if target value not in interval
proc_error_ests$year_mean_mean = round(proc_error_ests$year_mean_mean, 2)
proc_error_ests$year_mean_mean = ifelse(!proc_error_ests$yr_mean_incl_target, paste0("<b>", proc_error_ests$year_mean_mean, "</b>"), proc_error_ests$year_mean_mean)
proc_error_ests$year_sd_mean = round(proc_error_ests$year_sd_mean, 2)
proc_error_ests$year_sd_mean = ifelse(!proc_error_ests$yr_sd_incl_target, paste0("<b>", proc_error_ests$year_sd_mean, "</b>"), proc_error_ests$year_sd_mean)
proc_error_ests$diff_mean = round(proc_error_ests$diff_mean, 2)
proc_error_ests$diff_mean = ifelse(!proc_error_ests$diff_incl_target, paste0("<b>", proc_error_ests$diff_mean, "</b>"), proc_error_ests$diff_mean)

# drop unneeded columns
proc_error_ests = proc_error_ests[,c("phase", "param", "pop", "origin", "LH_type","year_mean_mean", "year_sd_mean", "diff_mean")]
```

```{r proc-error-table-fn}
proc_error_table = function(var) {
  out = reshape2::dcast(proc_error_ests, phase + param + origin + LH_type ~ pop, value.var = var)
  out[is.na(out)] = ""

  knitr::kable(out, "html", col.names = c("Life Phase", "Process", "Origin", "Migratory Type", "CAT", "LOS", "MIN", "UGR", "Combined"), escape = FALSE, align = "llllccccc") %>%
    kableExtra::kable_styling(full_width = FALSE, bootstrap_options = c("condensed")) %>%
    collapse_rows(columns = 1:4)
}
```

#### Across-Year Mean

The posterior mean of the mean standardized noise value across all years; bold indicates the 95% CRI did not encompass the target value of 0.5.

**Interpretation of Values**:

* **Close to 0.5** indicate that the time series of noise terms was not biased relative to the expected value (i.e., assumption met)
* **Below 0.5** indicate that the time series of noise terms was biased low relative to the center of the distribution
* **Above 0.5** indicate that the time series of noise terms was biased high relative the center of the distribution

```{r proc-error-mean-table}
proc_error_table("year_mean_mean")
```

#### Across-Year SD

The posterior mean of the SD of noise value across all years; bold indicates the 95% CRI did not encompass $\sqrt{1/12}$ = `r round(sqrt(1/12), 2)`; the standard deviation of a $\mathrm{U}(0,1)$ distribution.

**Interpretation of Values**:

* **Close to `r round(sqrt(1/12), 2)`** indicate that the time series of noise terms was as variable as expected (i.e., assumption met)
* **Below `r round(sqrt(1/12), 2)`** indicate that the time series of noise terms was less variable than expected
* **Above `r round(sqrt(1/12), 2)`** indicate that the time series of noise terms was more variable than expected

```{r proc-error-sd-table}
proc_error_table("year_sd_mean")
```

#### Last Half Mean - First Half Mean

The posterior mean of `mean(noise term in last half of years) - mean(noise term in first half of years)`; bold indicates the 95% CRI did not encompass 0.

**Interpretation of Values**:

* **Close to 0** indicate a lack of an overall time trend (i.e., assumption met)
* **Below 0** indicate an overall declining time trend in noise terms
* **Above 0** indicate an overall increasing time trend in noise terms

```{r proc-error-diff-table}
proc_error_table("diff_mean")
```

## Observation Model Noise Terms {.tabset .tabset-pills}

```{r plot-obs-resid-fn}
obs_qresid_yrs = all_yrs[c(1,observable)]

# function to plot a residual time series for one pop/origin/LH_type/age combo
# returns a data frame with identifiers and across-year summary statistics
plot_obs_qresid = function(qresid_param, year = ".+", pop = NULL, origin = NULL, LH_type = NULL, age = NULL, main = NULL) {
  
  # extract posterior samples of residual time series
  qresid_post = post_subset(post, sub_index(qresid_param, year = year, pop = pop, origin = origin, LH_type = LH_type, age = age), matrix = TRUE)
  
  # extract the year indices available
  y_ind = get_yr_index(colnames(qresid_post))
  
  # calculate posterior across-year mean and sd for each posterior sample
  mn_post = apply(qresid_post, 1, mean)
  sd_post = apply(qresid_post, 1, sd)
  
  # calculate posterior summaries of qresidual time series
  qresid = apply(qresid_post, 2, function(x) c(mean = mean(x), sd = sd(x), quantile(x, c(0.5, 0.025, 0.975, 0.25, 0.75))))
  
  # place qresiduals at correct place in a time series
  # ie., insert missing values
  empty = matrix(NA, nrow = 7, ncol = length(obs_qresid_yrs))
  empty[,y_ind] = qresid
  qresid = empty[,observable]
  rownames(qresid) = c("mean", "sd", "50%", "2.5%", "97.5%", "25%", "75%")
  empty_names = rep(NA, length(obs_qresid_yrs))
  empty_names[y_ind] = colnames(qresid_post)
  
  # calculate posterior mean(last half of years) - mean(first half of years)
  y_first = 1:round(length(observable)/2)
  y_last = (max(y_first) + 1):length(observable)
  i_first = as.character(na.omit(empty_names[y_first]))
  i_last = as.character(na.omit(empty_names[y_last]))
  mn_post_first = apply(as.matrix(qresid_post[,i_first]), 1, mean)
  mn_post_last = apply(as.matrix(qresid_post[,i_last]), 1, mean)
  first_last_mn_diff_post = mn_post_last - mn_post_first

  # set the y-axis limits: leave room at top for legend
  ylim = c(0,1.3)
  
  # blank plot with correct dimensions
  plot(qresid["mean",] ~ all_yrs[observable], type = "n", ylim = ylim, xlim = range(all_yrs[observable]), xaxt = "n", xlab = "", ylab = "",yaxt = "n")
  
  # draw x-axis: years
  at_x = seq(min(all_yrs[observable]), max(all_yrs[observable]), 4)
  axis(side = 1, at = at_x, labels = paste0("'", substr(at_x, 3, 4)))
  axis(side = 2, at = seq(0, 1, 0.25), labels = TRUE)

  # draw the noise time series: mean and 95% CRI
  segments(all_yrs[observable], qresid["2.5%",], all_yrs[observable], qresid["97.5%",], col = main_cols["model"])
  segments(all_yrs[observable], qresid["25%",], all_yrs[observable], qresid["75%",], col = main_cols["model"], lwd = 4)
  points(qresid["mean",] ~ all_yrs[observable], pch = 21, col = "white", bg = "white", cex = 1.25)
  points(qresid["mean",] ~ all_yrs[observable], pch = 21, col = main_cols["model"], bg = tran_cols["model"], cex = 1.25)
  
  # draw reference line at 25%, 50%, and 75% quantiles
  abline(h = c(0.25, 0.5, 0.75), lty = 3, col = "grey", lwd = 2)
  
  # draw posterior mean for first and half of time series
  lines(x = all_yrs[observable[y_first]], y = rep(mean(mn_post_first), length(y_first)), col = main_cols["model2"], lty = 3, lwd = 2)
  lines(x = all_yrs[observable[y_last]], y = rep(mean(mn_post_last), length(y_last)), col = main_cols["model2"], lty = 3, lwd = 2)
  
  # draw legend that shows estimate summaries
  usr = par("usr"); xdiff = diff(usr[1:2]); ydiff = diff(usr[3:4])
  rect(usr[1], 1, usr[2], usr[4], border = par("col.axis"), col = "grey95")
  legend(x = usr[1] - xdiff * 0.05, y = usr[4] + ydiff * 0.025, text.col = par("col.axis"), legend = make_legend_text(mn_post, sd_post, first_last_mn_diff_post), bty = "n", cex = 0.8)
  box(col = par("col.axis"))
  panel_label(main, "topright")
  
  # create output for building summary tables
  data.frame(param = qresid_param,
             pop = ifelse(!is.null(pop), pop, NA),
             origin = ifelse(!is.null(origin), origin, NA),
             LH_type = ifelse(!is.null(LH_type), LH_type, NA),
             age = ifelse(!is.null(age), age, NA),
             n_yrs = ncol(qresid_post[,y_ind %in% observable]),
             year_mean_mean = mean(mn_post),
             year_mean_lwr = unname(quantile(mn_post, 0.025)),
             year_mean_upr = unname(quantile(mn_post, 0.975)),
             year_sd_mean = mean(sd_post),
             year_sd_lwr = unname(quantile(sd_post, 0.025)),
             year_sd_upr = unname(quantile(sd_post, 0.975)),
             diff_mean = mean(first_last_mn_diff_post), 
             diff_lwr = unname(quantile(first_last_mn_diff_post, 0.025)), 
             diff_upr = unname(quantile(first_last_mn_diff_post, 0.975))
  )
}

# container for across-year summary statistics
# is rbinded many times for each random process and pop/origin/LH_type/age combo
obs_error_ests = NULL
```

### Abundance Data {.tabset .tabset-pills}

#### Fall Parr Abundance

```{r fall-trap-resid, fig.width = p4_width, fig.height = p4_height}
mypar()
tmp = lapply(1:jags_data$nj, function(j) plot_obs_qresid("lPa_obs_qresid[year,LH_type,pop]", LH_type = 1, pop = j, main = pops[j]))
axis_labels("Brood Year", "log(Fall Parr Abundance) QResidual")
obs_error_ests = rbind(obs_error_ests, do.call(rbind, tmp))
```

#### Spring Smolt Abundance

```{r spring-trap-resid, fig.width = p4_width, fig.height = p4_height}
mypar()
tmp = lapply(1:jags_data$nj, function(j) plot_obs_qresid("lMb_obs_qresid[year,LH_type,origin,pop]", LH_type = 2, origin = 1, pop = j, main = pops[j]))
axis_labels("Brood Year", "log(Spring Trap Count) QResidual")
obs_error_ests = rbind(obs_error_ests, do.call(rbind, tmp))
```

#### Adult Return Abundance

```{r adult-resid, fig.width = p4_width, fig.height = p4_height}
mypar()
tmp = lapply(1:jags_data$nj, function(j) plot_obs_qresid("lRa_obs_qresid[year,pop]", pop = j, main = pops[j]))
axis_labels("Return Year", "log(Total Adult Count) QResidual")
obs_error_ests = rbind(obs_error_ests, do.call(rbind, tmp))
```

### Survival Data {.tabset .tabset-pills}

#### Summer Parr $\to$ LGR

```{r summer-surv-resid, fig.width = p4_width, fig.height = p4_height}
mypar()
tmp = lapply(1:jags_data$nj, function(j) plot_obs_qresid("Lphi_obs_Pb_Ma_qresid[year,pop]", pop = j, main = pops[j]))
axis_labels("Brood Year", "logit(Summer Parr \u2192 LGR Survival) QResidual")
obs_error_ests = rbind(obs_error_ests, do.call(rbind, tmp))
```

#### Fall Parr $\to$ LGR

```{r fall-surv-resid, fig.width = p4_width, fig.height = p4_height}
mypar()
tmp = lapply(1:jags_data$nj, function(j) plot_obs_qresid("Lphi_obs_Pa_Ma_qresid[year,LH_type,pop]", LH_type = 1, pop = j, main = pops[j]))
axis_labels("Brood Year", "logit(Fall Parr \u2192 LGR Survival) QResidual")
obs_error_ests = rbind(obs_error_ests, do.call(rbind, tmp))
```

#### Winter Parr $\to$ LGR

```{r winter-surv-resid, fig.width = p4_width, fig.height = p4_height}
mypar()
tmp = lapply(1:jags_data$nj, function(j) {
  if (j == 3) {
    no_data_plot(main = pops[j])
  } else {
    plot_obs_qresid("Lphi_obs_Pa_Ma_qresid[year,LH_type,pop]", LH_type = 2, pop = j, main = pops[j])
  }
})
axis_labels("Brood Year", "logit(Winter Parr \u2192 LGR Survival) QResidual")
obs_error_ests = rbind(obs_error_ests, do.call(rbind, tmp))
```

#### Spring Smolt $\to$ LGR {.tabset .tabset-pills}

##### NOR

```{r spring-surv-resid-nor, fig.width = p4_width, fig.height = p4_height}
mypar()
tmp = lapply(1:jags_data$nj, function(j) plot_obs_qresid("Lphi_obs_Mb_Ma_qresid[year,LH_type,origin,pop]", LH_type = 2, pop = j, origin = 1, main = pops[j]))
axis_labels("Brood Year", "logit(NOR Smolt \u2192 LGR Survival) QResidual")
obs_error_ests = rbind(obs_error_ests, do.call(rbind, tmp))
```

##### HOR

```{r spring-surv-resid-hor, fig.width = p4_width, fig.height = p4_height}
mypar()
tmp = lapply(1:jags_data$nj, function(j) {
  if (j == 3) {
    no_data_plot(main = pops[j])
  } else {
    plot_obs_qresid("Lphi_obs_Mb_Ma_qresid[year,LH_type,origin,pop]", LH_type = 2, pop = j, origin = 2, main = pops[j])
  }
})
axis_labels("Brood Year", "logit(HOR Smolt \u2192 LGR Survival) QResidual")
obs_error_ests = rbind(obs_error_ests, do.call(rbind, tmp))
```

#### LGR Smolt $\to$ BON

```{r hydro-surv-resid, fig.width = p2_width, fig.height = p2_height}
mypar(mfrow = c(1,2))
tmp = lapply(1:jags_data$no, function(o) plot_obs_qresid("Lphi_obs_Ma_O0_qresid[year,origin]", origin = o, main = origins[o]))
axis_labels("Brood Year", "logit(LGR \u2192 BON Survival) QResidual")
obs_error_ests = rbind(obs_error_ests, do.call(rbind, tmp))
```

#### BON Adults $\rightarrow$ LGR

```{r bon-adult-surv-resid, fig.width = 6, fig.height = 3.5}
mypar(mfrow = c(1,2))
tmp = lapply(1:jags_data$no, function(o) plot_obs_qresid("x_LGR_obs_qresid[year,origin]", origin = o, main = origins[o]))
axis_labels("Return Year", "Count of PIT Tagged Adults at LGR QResidual")
obs_error_ests = rbind(obs_error_ests, do.call(rbind, tmp))
```

#### Pre-spawn

```{r pre-spawn-surv-resid, fig.width = p4_width, fig.height = p4_height}
mypar()
tmp = lapply(1:jags_data$nj, function(j) plot_obs_qresid("x_carcass_spawned_obs_qresid[year,pop]", pop = j, main = pops[j]))
axis_labels("Return Year", "Count of Female Spawned-out Carcasses QResidual")
obs_error_ests = rbind(obs_error_ests, do.call(rbind, tmp))
```

### Length Data {.tabset .tabset-pills}

#### Parr Mean Length

```{r summer-length-resid, fig.width = p4_width, fig.height = p4_height}
mypar()
tmp = lapply(1:jags_data$nj, function(j) plot_obs_qresid("lL_Pb_obs_qresid[year,pop]", pop = j, main = pops[j]))
axis_labels("Brood Year", "log(Parr Mean Length) QResidual")
obs_error_ests = rbind(obs_error_ests, do.call(rbind, tmp))
```

#### Smolt Mean Length

```{r spring-length-resid, fig.width = p4_width, fig.height = p4_height}
mypar()
tmp = lapply(1:jags_data$nj, function(j) plot_obs_qresid("lL_Mb_obs_qresid[year,pop]", pop = j, main = pops[j]))
axis_labels("Brood Year", "log(Smolt Mean Length) QResidual")
obs_error_ests = rbind(obs_error_ests, do.call(rbind, tmp))
```

### Composition Data {.tabset .tabset-pills}

#### Weir Sampling {.tabset .tabset-pills}

```{r weir-comp-resid-plots-fn}
ko_names = c("Age-3 (NOR)", "Age-4 (NOR)", "Age-5 (NOR)",
             "Age-3 (HOR)", "Age-4 (HOR)", "Age-5 (HOR)")

weir_comp_qresid_plots = function(j) {
  mypar(mfrow = c(2,3))
  tmp = lapply(1:jags_data$nko, function(ko) plot_obs_qresid("x_Ra_obs_qresid[year,age,pop]", year = unname(which(jags_data$nx_Ra[,j] > 0)), age = ko, main = ko_names[ko], pop = j))
  axis_labels("Return Year", "Weir Age/Origin Composition QResidual")
  do.call(rbind, tmp)
}
```

##### CAT

```{r cat-weir-comp-resids, fig.width = p6_width, fig.height = p6_height}
tmp = weir_comp_qresid_plots(j_cat)
obs_error_ests = rbind(obs_error_ests, tmp)
```

##### LOS

```{r los-weir-comp-resids, fig.width = p6_width, fig.height = p6_height}
tmp = weir_comp_qresid_plots(j_los)
obs_error_ests = rbind(obs_error_ests, tmp)
```

##### MIN

_No weir data for MIN_

##### UGR

```{r ugr-weir-comp-resids, fig.width = p6_width, fig.height = p6_height}
tmp = weir_comp_qresid_plots(j_ugr)
obs_error_ests = rbind(obs_error_ests, tmp)
```

#### Carcass Sampling {.tabset .tabset-pills}

```{r carcass-comp-resid-plots-fn}
carcass_comp_qresid_plots = function(j) {
  mypar(mfrow = c(2,3))
  tmp = lapply(1:jags_data$nko, function(ko) plot_obs_qresid("x_Sa_prime_obs_qresid[year,age,pop]", year = unname(which(jags_data$nx_Sa_prime[,j] > 0)), age = ko, main = ko_names[ko], pop = j))
  axis_labels("Return Year", "Carcass Age/Origin Composition QResidual")
  do.call(rbind, tmp)
}
```

##### CAT

```{r cat-carcass-comp-resids, fig.width = p6_width, fig.height = p6_height}
tmp = carcass_comp_qresid_plots(j_cat)
obs_error_ests = rbind(obs_error_ests, tmp)
```

##### LOS

```{r los-carcas-comp-resids, fig.width = p6_width, fig.height = p6_height}
tmp = carcass_comp_qresid_plots(j_los)
obs_error_ests = rbind(obs_error_ests, tmp)
```

##### MIN

```{r min-carcas-comp-resids, fig.width = p6_width, fig.height = p6_height}
tmp = carcass_comp_qresid_plots(j_min)
obs_error_ests = rbind(obs_error_ests, tmp)
```

##### UGR

```{r ugr-carcass-comp-resids, fig.width = p6_width, fig.height = p6_height}
tmp = carcass_comp_qresid_plots(j_ugr)
obs_error_ests = rbind(obs_error_ests, tmp)
```

### **SUMMARY TABLES** {.tabset .tabset-pills}

These tables show posterior summary statistics of the time series of noise terms across years (i.e., the values shown on each figure panel). Bold values denote that the target value for verifying model assumptions was not within the 95% CRI of the across-year summary statistic and indicates a potential problem.

```{r obs-error-table-prep}
# rename parameters to human-readable format
obs_error_ests$param = stringr::str_replace(obs_error_ests$param, "lPa_obs_qresid\\[year,LH_type,pop\\]", "Fall Screw Trap")
obs_error_ests$param = stringr::str_replace(obs_error_ests$param, "lMb_obs_qresid\\[year,LH_type,origin,pop\\]", "Spring Screw Trap")
obs_error_ests$param = stringr::str_replace(obs_error_ests$param, "lRa_obs_qresid\\[year,pop\\]", "Adult Return")
obs_error_ests$param = stringr::str_replace(obs_error_ests$param, "Lphi_obs_Pb_Ma_qresid\\[year,pop\\]", "Summer Tagging -> LGR")
obs_error_ests$param = stringr::str_replace(obs_error_ests$param, "Lphi_obs_Pa_Ma_qresid\\[year,LH_type,pop\\]", "Fall Tagging -> LGR")
obs_error_ests$param = stringr::str_replace(obs_error_ests$param, "Lphi_obs_Mb_Ma_qresid\\[year,LH_type,origin,pop\\]", "Spring Tagging -> LGR")
obs_error_ests$param = stringr::str_replace(obs_error_ests$param, "Lphi_obs_Ma_O0_qresid\\[year,origin\\]", "LGR Smolt -> Ocean")
obs_error_ests$param = stringr::str_replace(obs_error_ests$param, "x_LGR_obs_qresid\\[year,origin\\]", "BON Adults -> LGR")
obs_error_ests$param = stringr::str_replace(obs_error_ests$param, "x_carcass_spawned_obs_qresid\\[year,pop\\]", "Pre-spawn")
obs_error_ests$param = stringr::str_replace(obs_error_ests$param, "lL_Pb_obs_qresid\\[year,pop\\]", "Summer Parr")
obs_error_ests$param = stringr::str_replace(obs_error_ests$param, "lL_Mb_obs_qresid\\[year,pop\\]", "Spring Smolt")
obs_error_ests$param = stringr::str_replace(obs_error_ests$param, "x_Ra_obs_qresid\\[year,age,pop\\]", "Weir")
obs_error_ests$param = stringr::str_replace(obs_error_ests$param, "x_Sa_prime_obs_qresid\\[year,age,pop\\]", "Carcass")

# correct parameter names
obs_error_ests$param[obs_error_ests$param == "Fall Tagging -> LGR" & obs_error_ests$LH_type == 2] = "Winter Tagging -> LGR"
obs_error_ests$param[obs_error_ests$param == "Spring Tagging -> LGR" & obs_error_ests$origin == 2] = "Smolt Release -> LGR"
obs_error_ests$origin[obs_error_ests$param == "Fall Screw Trap"] = 1
obs_error_ests$origin[obs_error_ests$param == "Adult Return"] = 3

# correct origin indices
obs_error_ests$origin[stringr::str_detect(obs_error_ests$param, "Tagging")] = 1
obs_error_ests$origin[obs_error_ests$param == "Pre-spawn"] = 3
obs_error_ests$origin[obs_error_ests$param %in% c("Summer Parr", "Spring Smolt")] = 1

# correct LH_type indices
obs_error_ests$LH_type[is.na(obs_error_ests$LH_type)] = 3

# correct pop indices
obs_error_ests$pop[is.na(obs_error_ests$pop)] = 5

# correct origin indices based on age indices
obs_error_ests$origin[obs_error_ests$age %in% c(1,2,3)] = 1
obs_error_ests$origin[obs_error_ests$age %in% c(4,5,6)] = 2

# replace indices with names
obs_error_ests$pop = c("CAT", "LOS", "MIN", "UGR", "Combined")[obs_error_ests$pop]
obs_error_ests$origin = c("NOR", "HOR", "Combined")[obs_error_ests$origin]
obs_error_ests$LH_type = c("Fall Mig.", "Spring Mig.", "Combined")[obs_error_ests$LH_type]
obs_error_ests$age = c("Age-3", "Age-4", "Age-5", "Age-3", "Age-4", "Age-5")[obs_error_ests$age]
obs_error_ests$age[is.na(obs_error_ests$age)] = "Combined"

# add a type column
obs_error_ests$type = NA
obs_error_ests$type = ifelse(obs_error_ests$param %in% c("Fall Screw Trap", "Spring Screw Trap", "Adult Return"), 1, obs_error_ests$type)
obs_error_ests$type = ifelse(stringr::str_detect(obs_error_ests$param, "->"), 2, obs_error_ests$type)
obs_error_ests$type = ifelse(stringr::str_detect(obs_error_ests$param, "Pre-spawn"), 2, obs_error_ests$type)
obs_error_ests$type = ifelse(obs_error_ests$param %in% c("Weir", "Carcass"), 3, obs_error_ests$type)
obs_error_ests$type = ifelse(obs_error_ests$param %in% c("Summer Parr", "Spring Smolt"), 4, obs_error_ests$type)
obs_error_ests$type = c("Abundance", "Survival", "Composition", "Mean Length")[obs_error_ests$type]

# add levels to each variable
obs_error_ests$type = factor(obs_error_ests$type, levels = c("Abundance", "Survival", "Mean Length", "Composition"))
obs_error_ests$param = factor(obs_error_ests$param, levels = c("Fall Screw Trap", "Spring Screw Trap", "Adult Return", "Summer Tagging -> LGR", "Fall Tagging -> LGR", "Winter Tagging -> LGR", "Spring Tagging -> LGR", "Smolt Release -> LGR", "LGR Smolt -> Ocean", "BON Adults -> LGR", "Pre-spawn", "Summer Parr", "Spring Smolt", "Weir", "Carcass"))
obs_error_ests$origin = factor(obs_error_ests$origin, levels = c("NOR", "HOR", "Combined"))
obs_error_ests$LH_type = factor(obs_error_ests$LH_type, levels = c("Fall Mig.", "Spring Mig.", "Combined"))
obs_error_ests$age = factor(obs_error_ests$age, levels = c("Age-3", "Age-4", "Age-5", "Combined"))
obs_error_ests$pop = factor(obs_error_ests$pop, levels = c("CAT", "LOS", "MIN", "UGR", "Combined"))

# determine whether posterior of across-year quantities overlaps the target value
obs_error_ests$yr_mean_incl_target = ifelse(obs_error_ests$year_mean_lwr <= 0.5 & obs_error_ests$year_mean_upr >= 0.5, TRUE, FALSE)
obs_error_ests$yr_sd_incl_target = ifelse(obs_error_ests$year_sd_lwr <= sqrt(1/12) & obs_error_ests$year_sd_upr >= sqrt(1/12), TRUE, FALSE)
obs_error_ests$diff_incl_target = ifelse(obs_error_ests$diff_lwr <= 0 & obs_error_ests$diff_upr >= 0, TRUE, FALSE)

# format the mean values to present in table
# round and make bold if target value not in interval
obs_error_ests$year_mean_mean = round(obs_error_ests$year_mean_mean, 2)
obs_error_ests$year_mean_mean = ifelse(!obs_error_ests$yr_mean_incl_target, paste0("<b>", obs_error_ests$year_mean_mean, "</b>"), obs_error_ests$year_mean_mean)
obs_error_ests$year_sd_mean = round(obs_error_ests$year_sd_mean, 2)
obs_error_ests$year_sd_mean = ifelse(!obs_error_ests$yr_sd_incl_target, paste0("<b>", obs_error_ests$year_sd_mean, "</b>"), obs_error_ests$year_sd_mean)
obs_error_ests$diff_mean = round(obs_error_ests$diff_mean, 2)
obs_error_ests$diff_mean = ifelse(!obs_error_ests$diff_incl_target, paste0("<b>", obs_error_ests$diff_mean, "</b>"), obs_error_ests$diff_mean)

# drop unneeded columns
obs_error_ests = obs_error_ests[,c("type", "param", "pop", "origin", "LH_type", "age", "year_mean_mean", "year_sd_mean", "diff_mean")]
```

```{r obs-error-table-fn}
obs_error_table = function(var) {
  out = reshape2::dcast(obs_error_ests, type + param + origin + LH_type + age ~ pop, value.var = var)
  out[is.na(out)] = ""
  out$param = stringr::str_replace(out$param, "->", "$\\\\rightarrow$")

  knitr::kable(out, "html", col.names = c("Class", "Type", "Origin", "Migratory Type", "Age-of-Maturity", "CAT", "LOS", "MIN", "UGR", "Combined"), escape = FALSE, align = "lllllccccc") %>%
    kableExtra::kable_styling(full_width = FALSE, bootstrap_options = c("condensed")) %>%
    collapse_rows(columns = 1:5)
}
```

#### Across-Year Mean

The posterior mean of the mean standardized noise value across all years; bold indicates the 95% CRI did not encompass the target value of 0.5.

**Interpretation of Values**:

* **Close to 0.5** indicate that the time series of noise terms was not biased relative to the expected value (i.e., assumption met)
* **Below 0.5** indicate that the time series of noise terms was biased low relative to the center of the distribution
* **Above 0.5** indicate that the time series of noise terms was biased high relative the center of the distribution

```{r obs-error-mean-table}
obs_error_table("year_mean_mean")
```

#### Across-Year SD

The posterior mean of the SD of noise value across all years; bold indicates the 95% CRI did not encompass $\sqrt{1/12}$ = `r round(sqrt(1/12), 2)`; the standard deviation of a $\mathrm{U}(0,1)$ distribution.

**Interpretation of Values**:

* **Close to `r round(sqrt(1/12), 2)`** indicate that the time series of noise terms was as variable as expected (i.e., assumption met)
* **Below `r round(sqrt(1/12), 2)`** indicate that the time series of noise terms was less variable than expected
* **Above `r round(sqrt(1/12), 2)`** indicate that the time series of noise terms was more variable than expected

```{r obs-error-sd-table}
obs_error_table("year_sd_mean")
```

#### Last Half Mean - First Half Mean

The posterior mean of `mean(noise term in last half of years) - mean(noise term in first half of years)`; bold indicates the 95% CRI did not encompass 0.

**Interpretation of Values**:

* **Close to 0** indicate a lack of an overall time trend (i.e., assumption met)
* **Below 0** indicate an overall declining time trend in noise terms
* **Above 0** indicate an overall increasing time trend in noise terms

```{r obs-error-diff-table}
obs_error_table("diff_mean")
```

